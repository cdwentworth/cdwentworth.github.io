[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Science",
    "section": "",
    "text": "Welcome\nThis is the web version of the book Computational Science: An Introduction for Scientists and Engineers. This book will introduce students with no coding experience to computational thinking, the basics of coding computer programs using Python, how to develop models and simulations of systems studied in the natural and engineering sciences, and how to communicate scientific information using visual techniques. The material available on this website and the pdf and epub versions of the book are available to users under the Creative Commons Attribution-NonCommercial-ShareAlike license available at the link shown below.\nThe pdf and epub editions of the book are available at the book website:\n\nComputationalScienceBook.info\n\n\n© 2025 C.D. Wentworth, Crete, Nebraska, USA Licensed under CC BY-NC-SA 4.0. To view a copy of this license, visit creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n2025, First Edition ISBN 979-8-9928002-1-0",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "acknowledgements.html",
    "href": "acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "In the many years I have taught computational science there are many people to whom I am indebted. I will list a few here.\nMost important are the many students who experienced me as their instructor. They asked the critical questions and provided valuable feedback about explanations and assignments that proved helpful to them. I have been privileged to hear back from several of these students as they progressed in their careers letting me know about the challenges and successes in applying computational science concepts in their work. All of these communications with students were central to how I wrote this book.\nColleagues at Doane University who helped develop an interest in computational science and offered significant advice on how it should be structured include Tessa Durham Brooks, Susan Enders, Alec Engebretson, Peg Hart, and Mark Meysenburg. Lavi Zamstein proofread several of the chapters and caught mistakes. Remaining errors are, of course, my responsibility.\nI greatly benefited from resources provided by The Shodor Education Foundation, in particular, conversations with Robert Panoff, President and Executive Director of the foundation.\nFinally, I want to thank my wife, Sally, for her patience and encouragement throughout the writing process, particularly while I was being treated for leukemia.",
    "crumbs": [
      "Acknowledgements"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "Computational science involves using mathematics, computer science, and domain knowledge to solve complex problems in the domain of interest. The ability to represent real-world systems with mathematical models and use computers to simulate and analyze the behavior of these models is now an essential part of research in the natural, social, and engineering sciences and in design work performed by engineers. The goal of this book is to introduce new students in science and engineering to fundamental concepts and tools of computational science and apply these ideas to example problems in several areas of science and engineering.\nWe will begin our study of computational science with an introduction to computational thinking, which is concerned with mental skills and practices that facilitate using computation to solve problems. Computational thinking is then applied to developing a strategy to create mathematical models that can be studied using computer simulation. Next, basic programming concepts are introduced within the context of a science or engineering problem. We introduce the Numpy package, which is critical for performing numerical computations in Python. Principles of scientific visualization are developed with examples created using Python visualization packages. We introduce the concept of a dynamical system and how to develop a model of such a system. We develop techniques for the numerical simulation of dynamical system models. Next, we investigate several kinds of stochastic models and using Monte Carlo methods to study such models. The book concludes with several project suggestions that require practicing the modeling and programming tools developed in the rest of the book.\nMany books on computational science or computational methods in science and engineering assume that the student has a well-developed mathematical background, including courses in calculus and differential equations. Since the goal of this book is to expose first-year students to computational science techniques, and these students have typically not taken calculus in high school, we assume the student is ready to take calculus but has not yet done so. Some calculus concepts are introduced in the book, but mainly through geometrical interpretation rather than through rigorous mathematical definitions. Dynamical systems models, defined using differential equations, are introduced, but their properties are explored primarily through computer simulation rather than through analytical techniques.\nNo programming experience is assumed by the book. The necessary techniques are developed simultaneously with computational science ideas. Students will gain programming experience in the context of using programming to solve science and engineering problems.\nTwo kinds of programming exercises are provided at the end of each chapter: program modification problems and program development problems. The modification problems require adapting a code developed in the chapter to a new but related problem. The development problems ask students to solve a non-trivial problem not yet addressed in the text, including developing all code required for the solution. These development problems will often require integrating ideas from previous chapters in addition to ideas developed in the chapter posing the problem.\nStudents who master the concepts developed in this book and complete the program modification and program development problems should be ready to use computation in many advanced courses required by science and engineering majors. Students should also be ready to increase their knowledge of computational science through the independent study of many library and online resources.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/Ch01/Ch01_Introduction.html",
    "href": "chapters/Ch01/Ch01_Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Defining Computational Science\nBefore embarking on our journey to learning how computational science is used to solve scientific and engineering problems, we should first establish more formally what we mean by computational science. When you think of the word “computation,” what comes to mind? Perhaps you recall practicing long division in elementary school, balancing your checkbook, or estimating groceries required for a dinner party. These are instances of equating computation to arithmetic, but the modern conception of computation in science and engineering goes well beyond this concept.\nWe will begin our overview of computational science by defining it and showing the breadth of disciplines and enterprises that make use of it to solve problems. Computational science sounds a lot like computer science, but it is a different discipline, although it does involve computer science. Here is a good working definition that we will use:\nComputational science is the development or application of techniques that use computation to solve scientific and engineering problems.\nThere are certainly other definitions that can be found in the literature, but this definition will work for us.\nComputational science is inherently interdisciplinary, involving concepts and techniques from computer science, mathematics, and a domain-specific science or engineering discipline.\nTraditionally, a scientific discipline involves two reinforcing ways of working: experiment (or observation) and theory. Figure 1 illustrates these two essential aspects of science.\nThe existence of powerful computing technologies has changed the conduct of scientific and engineering work profoundly by allowing large data sets to be studied and realistic models of systems to be simulated. Computation aids both theoretical and experimental work, so that computational science becomes an indispensable third leg of our concept of scientific work, as illustrated in Figure 2.\nConsider the scientific discipline astronomy. Current observational techniques have created huge amounts of data that include objects located (stars, galaxies, exoplanets, etc.), motion data of each object, intensity of electromagnetic radiation at different wavelengths associated with these objects, and other properties. Table 1 shows the amount of data generated by several observational projects. Note that TB stands for terabyte (1012), PB stands for petabyte (1015), and EB stands for exabyte (1018). We see that each of these individual projects creates enormous amounts of data.\nCataloging, storing, uncovering systematic errors, and performing exploratory data analysis all require significant computational resources and specialized techniques.\nAnother way to think of computational science is that it involves the intersection between computer science, mathematics, and an applied discipline, as illustrated in Figure 3.\nMathematical modeling is a central activity for working physicists and engineers. As other sciences have become more quantitative, mathematical modeling has assumed an increasingly important role in those disciplines as well. This includes areas such as biology and environmental sciences. A significant amount of work in contemporary computational science involves developing and exploring mathematical models using computation. This focus will be important to us throughout this course, so it is worth keeping in mind how modeling connects with other aspects of doing science. Figure 4 illustrates the connections.\nA model starts with experimental data or observations and describes patterns in the data, connecting those patterns with more fundamental theoretical ideas from the area of science being investigated. The process of uncovering patterns typically involves elements of computation such as statistical analysis and visualizations. The outer elements of Figure 4 illustrate key elements of computational science itself: a scientific activity (application) that is facilitated by using mathematics and algorithmic thinking (algorithms), which, in turn, requires computation to fully explore (computing environment).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/Ch01/Ch01_Introduction.html#defining-computational-science",
    "href": "chapters/Ch01/Ch01_Introduction.html#defining-computational-science",
    "title": "Introduction",
    "section": "",
    "text": "Figure 1: Traditional concept of science.\n\n\n\n\n\n\n\n\n\n\nFigure 2: The modern concept of science.\n\n\n\n\n\n\n\nTable 1: Data volumes of different sky survey projects (Zhang & Zhao, 2015).\n\n\n\n\n\nSky Survey Projects\nData Volume\n\n\n\n\nDPOSS (The Palomar Digital Sky Survey)\n3 TB\n\n\n2MASS (The Two Micron All-Sky Survey)\n10 TB\n\n\nGBT (Green Bank Telescope)\n20 PB\n\n\nGALEX (The Galaxy Evolution Explorer )\n30 TB\n\n\nSDSS (The Sloan Digital Sky Survey)\n40 TB\n\n\nSkyMapper Southern Sky Survey\n500 TB\n\n\nLSST (The Large Synoptic Survey Telescope)\n\\(\\sim\\)200 PB expected\n\n\nSKA (The Square Kilometer Array)\n\\(\\sim\\)4.6 EB expected\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Conceptual model of computational science (The Shodor Education Foundation, 2000) .\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: The relationships between models, the basic elements of science, and elements of computational science (The Shodor Education Foundation, 2000).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/Ch01/Ch01_Introduction.html#examples-of-computational-science-applications",
    "href": "chapters/Ch01/Ch01_Introduction.html#examples-of-computational-science-applications",
    "title": "Introduction",
    "section": "Examples of Computational Science Applications",
    "text": "Examples of Computational Science Applications\nLet’s look at some specific examples of scientific and engineering problems that use computation science.\n\nGlobal Climate Change\nClimate change is an important topic that impacts many areas of everyday life and promises to have even more profound effects in the future. It is important for us to understand how to describe climate, recognize the important determinants of climate, and develop realistic models that can help us predict the future climate.\nDescribing the global climate starts with some basic observational data such as the average surface temperature. Figure 5 shows data on the average surface temperature. Notice that the graph does not directly show the temperature, but rather the temperature anomaly, which is the difference between the actual temperature and the average temperature measured over a specified base time period. Using the temperature anomaly avoids including effects of systematic errors in an individual thermometer.\n\n\n\n\n\n\nFigure 5: Average surface temperature anomaly (Temperature Composite, n.d.).\n\n\n\nProducing just this one graph involved many aspects of computational science.\n\nThe individual data sets contain a large number of measurements that must be made available in a user-friendly form.\nEach data set must undergo statistical analysis to uncover and correct for problems in the data.\nA moving average is calculated to remove some of the random variation present in the observations. Such smoothing of the data helps to identify trends\nThe graph of the moving average must be generated.\n\nEach of these actions requires computation to accomplish.\nThe graph helps us to identify patterns, namely, that average global surface temperature increased from 1910 to 1940, leveled off and decreased slightly between 1940 and 1950, then increased again at a faster rate from 1950 to the present.\nAnother way of visualizing the data that requires significant computational work is to show the temperature anomaly in different regions of the earth and follow the geographic distribution over time. Figure 6 shows the result of performing this kind of analysis. The level of the temperature anomaly is indicated by the intensity of the color.\n\n\n\n\n\n\nFigure 6: Geographic distribution of the temperature anomaly (NASA’s Scientific Visualization Studio, 2021).\n\n\n\nCreating visualizations of the temperature data is only the beginning of investigating climate change. Models based on fundamental science including physics, chemistry, and meteorology must be constructed to help us understand the underlying causes for the changes we see. These models typically are mathematically sophisticated and can usually only be explored using numerical calculations performed by a computer.\n\n\nEvolution of Cosmic Structures\nUnderstanding how specific cosmic structures, such as galaxies, evolve over the history of the universe is an important problem of current interest. Observational astronomers can locate and characterize galaxies that have existed since a few million years after the Big Bang. Figure 7 shows some of the different kinds of galaxies found in the universe. Progress in understanding how the observed distribution of galaxy morphologies has recently been made by using computer simulations based on fundamental astrophysics principles incorporating hydrodynamics and gravitation principles (Vogelsberger et al., 2014). The researchers began with a system approximating the state of the universe at 12 million years after the Big Bang.\n\n\n\n\n\n\nFigure 7: Three general galaxy morphologies with specific examples of each. (Feild, 2019).\n\n\n\nThe computer simulation over about 13 billion years of evolution was able to show realistic distributions of galaxy morphologies. Figure 8 shows some of the simulated galaxies produced from the simulation.\n\n\n\n\n\n\nFigure 8: Simulated galaxy morphologies produce by computer simulation of galactic structure evolution (Vogelsberger et al., 2014).\n\n\n\n\n\nDesigning the Boeing 777\nThe Boeing 777, shown in Figure 9, is a twin-engine, wide-body, commercial jet that was first introduced in 1994 but is still in production.\n\n\n\n\n\n\nFigure 9: . The Boeing 777 commercial jet (Koske, 18 October 2009, 11:52).\n\n\n\nIt was a significant achievement of engineering because it was the first airplane to be completely designed using computer-assisted design tools (CAD). This eliminated the need for most full-scale mock-ups. This reduced the time and cost of designing and revising all the systems involved in the aircraft. The CAD system combined significant engineering mechanics knowledge with extremely sophisticated computer graphics to ensure that all parts of the system fit to within required tolerances and could move correctly. The CAD system also had properties of the materials used for parts built in so that stresses and strains could be measured in the simulated system to ensure part failure would not occur. Each system of the plane could be simulated through multiple cycles of revisions with both software and human-based visual checks. Figure Figure 10 shows examples of the visual product from the CAD system.\n\n\n\n\n\n\nFigure 10: Graphics output from the CAD software used for designing the Boeing 777 (Dietrich et al., 2005).\n\n\n\nEvery major area of science and engineering now has an established subarea that is focused on developing appropriate computational approaches to problem-solving in the particular discipline. The following is a list of such disciplines:\n\nComputational Biology\nComputational Chemistry\nComputational Economics\nComputational Finance\nComputational Neuroscience\nComputational Physics\nComputational Sociology",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/Ch01/Ch01_Introduction.html#elements-of-computational-thinking",
    "href": "chapters/Ch01/Ch01_Introduction.html#elements-of-computational-thinking",
    "title": "Introduction",
    "section": "Elements of Computational Thinking",
    "text": "Elements of Computational Thinking\nWhile the term “computational thinking” is relatively new, having been popularized in 2006 by Jeannette Wing in an opinion piece about computer science education (Wing, 2006), but concepts associated with the term have a long history. The ancient Babylonians (1800-1600 BCE) developed tables of reciprocals and multiplications to speed up and systematize arithmetical calculations. They also developed step-by-step procedures (i.e., algorithms) for solving certain classes of algebra problems (Knuth, 1972). Figure 11 shows an example of a Babylonian clay tablet specifying the procedure for solving a mathematical problem (Amin, 14 March 2019, 11:03:07).\n\nHistorical Examples of Computational Thinking\nThe Ancient Greek astronomer Hipparchus (190-120 BCE), shown in Figure 12, developed a theoretical framework to predict positions of sun and moon as functions of time. This framework used relationships from spherical trigonometry, and the required calculations used regular trigonometric functions such as cosine and sine. To expedite calculations involving trig functions, Hipparchus developed procedures for producing trigonometric function tables. Such tables remained useful well into the 20th century before being replaced by electronic calculators.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Babylonian clay tablet describing a mathematical procedure (Amin, 14 March 2019, 11:03:07).\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: he Greek astronomer Hipparchus (New York Public Library / Science Source / Science Photo Library, n.d.).\n\n\n\n\n\n\nAn example of a spherical triangle is shown in Figure 13.\nThe Persian mathematician Muhammad ibn Musa al-Khwarizmi, shown in Figure 14, wrote an important book published around 800 CE that specified procedures for solving quadratic equations. The Latin translation of his book on the Hindu-Arabic numeral system, Algoritmi de numero Indorum, gave us the term “algorithm”, which will play a significant role in our overview of computational thinking.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Example of triangle on a sphere (Mercator, 2013).\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Commemorative Stamp of Muḥammad ibn Mūsā al-Ḵwārizmī (unknown, 1983).\n\n\n\n\n\n\nThere is not a universal definition for the term “computational thinking”, yet it is really central to your development as a computational scientist. So, how can you be expected to learn how to do something so important when it cannot be defined?  Life is truly unfair. But do not despair; we will look at some elements of computational thinking that most computational scientists will agree are important elements of learning how to approach problems so that they can be solved computationally.  Indeed this can be a starting point for our working definition of computational thinking. Here is how Jeannette Wing of Columbia University defines it:\n\nComputational thinking is the thought processes involved in formulating a problem and expressing its solution(s) in such a way that a computer—human or machine—can effectively carry it out (Wing, 2014).\n\nAn athlete must train their body to execute physical motions required by the sport.  A computational scientist must train their mind to think about problems in a way that allows computers to help solve the problems.  Computational thinking is not used only for solving problems with a computer but can provide strategies for solving all sorts of problems.  The habits of mind and processes you will learn here can be widely applied.\n\n\nUses of Computational Thinking\nComputational thinking is used in many disciplines and activities with significant real-world applications:\n\nMapping the human genome\nPredicting the spread of infectious disease\nDeveloping methods for weather prediction\nPredicting the effect of government policies\nDeveloping a method of scheduling meetings efficiently in a large organization\n\n\n\nPillars of Computational Thinking\nThe general principles of computational thinking can be represented using four pillars, or principle concepts. They are\n\nDecomposition\nPattern Recognition\nData Representation and Abstraction (we can shorten this to just Abstraction)\nAlgorithms\n\nLet’s consider each of these pillars.\nDecomposition involves breaking a complex problem into smaller, more-manageable sub-problems or parts. Consider the problem of writing a paper for a course. We might break this problem into at least three parts: writing an introduction, writing the main body, and finally writing a conclusion.\nActivity: Consider the problem of cleaning your apartment or house. Apply the process of decomposition to this problem.\nPattern recognition involves finding similarities or shared characteristics within or between problems. If two problems share characteristics, then the same solution can be used to solve both problems.\nActivity: Think of a problem for which you could use computational thinking, describe it, and then describe how you would apply pattern recognition.\nThe third pillar of computational thinking is called data representation and abstraction. We will shorten this to just abstraction. The key element of abstraction is to determine the characteristics of a problem that are important and those that can be ignored. Next, we decide on a way to represent the chosen important characteristics. This would be the data representation.\nExample: developing an online book catalog. Important information:\n\nTitle\nAuthors\nISBN\nYear of publication\nEdition\n\nUnimportant information:\n\nBook jacket color\nAuthor birthplace\n\nActivity: Think of a problem for which you could use computational thinking, describe it, and then describe how you would apply data representation and abstraction.\nThe final pillar of computational thinking is algorithms. We will explore algorithms throughout this course. For now, we define their essential properties as:\n\nA collection of individual steps to be used in solving the problem;\nEach step must be defined precisely;\nThe steps must be performed sequentially.\n\nWe can represent an algorithm using a flow chart.\nThe elements of flowcharts include\n\nTerminals: an oval that represents a start or stop.\n\nInput/Output: a parallelogram that represents the program either getting data input or creating data output.\n\nProcessing: a box that represents executing some action such as performing arithmetic.\n\nDecision: a diamond represents making a decision.\n\nFlow Lines: arrows that indicate the sequence taken by instruction. The arrows are called directed edges by computer scientists.\n\n\nAnother way of representing an algorithm is using pseudocode, which we will explore later.\n\n\nLogical Arguments\nA good starting point for computational thinking is the idea of logical thinking. Logic is a systematic approach to distinguish between incorrect and correct arguments. Logical reasoning starts with premises, which are statements about initial knowns concerning the problem.  Premises must be determined to be true or false. If the premises are true then the final step in a logical argument is to reason that a conclusion follows.  \nThere are two general categories of logical arguments with which we are concerned: deductive and inductive arguments. In a deductive argument, once the premises are established to be true then the conclusion will necessarily follow with complete certainty.  In an inductive argument the veracity of statements, whether they be premises or a conclusion, can be expressed only with a particular probability rather than with certainty.\nExample of deductive reasoning:\n\nSocrates is a man.\nAll men are mortal.\nTherefore, Socrates is mortal\n\nStatements 1 and 2 are the premises.  If they are both true then the conclusion necessarily follows.  \nA deductive argument can fail in two ways:\n\nOne or more of the premises could be false, which means that the conclusion is not necessarily true.\nThe conclusion does not necessarily follow from the premises, even if they are all true.  There is a logic problem in the argument.\n\nExample of inductive reasoning:\nIn an inductive argument there will be an element of probability involved in the truth of premises and conclusion.  In an inductive argument we establish that the conclusion is probably true but we cannot say it is true with certainty, as we can with a deductive argument.  Here is an example:\n\n90% of the senior class at Belmont High were accepted into college.\nRobert is a senior at Belmont High\nTherefore, Robert was accepted into college.\n\nThe conclusion is probably true but not necessarily true.\nComputers most easily perform deductive reasoning.  In the next Module, we will learn about a particular way of performing deductive arguments called Boolean logic that is implemented in all programming languages, including Python.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/Ch01/Ch01_Introduction.html#mathematical-modeling-in-science-and-engineering",
    "href": "chapters/Ch01/Ch01_Introduction.html#mathematical-modeling-in-science-and-engineering",
    "title": "Introduction",
    "section": "Mathematical Modeling in Science and Engineering",
    "text": "Mathematical Modeling in Science and Engineering\nModeling is a fundamental element of science and engineering. We can think of a model as a simplified representation of a system of interest. A model could be physical such as letting a basketball represent the sun and a golf ball represent the earth and carry the golf ball around the basketball to illustrate a planetary orbit. Automobile manufacturers historically used clay models of a vehicle to explore how the shape influenced airflow around the vehicle. In science and engineering models are usually represented using mathematics such as representing the position of a planet by its spatial coordinates \\((r,\\theta,\\phi)\\) in a spherical coordinate system and then representing the orbit by the equation for an ellipse, Equation 1\n\\[  \nr = \\frac{a\\left(1- e^2\\right)}{1 + e\\cos \\left(\\phi \\right)} \\tag{1}\\]\nWe can usefully classify the kinds of models used in science and engineering into the following categories.\n\nDeterministic\nStochastic\nEmpirical\nTheory-based\n\n\nDeterministic Models\nDeterministic models describe systems in which knowledge of the state at one time will determine the state at subsequent times. There is no element of randomness in the state of the system. An example would be applying Newton’s laws of motion to a rock thrown in the air. Knowing the rock’s position and velocity at one time will allow us to predict the position and velocity at subsequent times. Figure 15 illustrates this situation.\n\n\n\n\n\n\nFigure 15: Trajectory of a rock ejected from a volcano. (Paul Peter Urone & Roger Hinrichs, 2012)\n\n\n\n\n\nStochastic Models\nStochastic models involve some element of randomness. When such models are described mathematically, they will involve use of probability theory. An example is modeling the trajectory of smoke coming from a burning candle, as shown in Figure 16. The first part of the smoke trajectory after it leaves the wick could be described using a deterministic model, but most of the smoke motion involves an element of randomness, suggesting that a stochastic model would be required.\n\n\n\n\n\n\nFigure 16: Candle smoke (Wicks, 2022)\n\n\n\n\n\nEmpirical Models\nEmpirical models attempt to find the mathematical form relating variables used to describe raw observational data or experimental results. The model is purely descriptive and not interpreted as an explanation of a pattern based on more fundamental principles. For example, suppose we take stroboscopic photographs of a falling ball at equal time intervals, as shown in the photo of Figure 17. If we measure the ball’s position as a function of time from the photograph and make a graph, we will obtain the graph in Figure 17.\n\n\n\n\n\n\nFigure 17: (a) Stroboscopic photographs of a falling ball (Maggs, 2007). (b) Graph of position data.\n\n\n\nLooking at the graph of the position data taken from strobe photos, we would rule out a linear relationship between y and t. The next type of equation to try would probably be a second-order polynomial, a quadratic. Such a model does fit the data well, as shown by the solid line in the graph.\n\n\nTheory-based Models\nTheory-based models use the more fundamental elements of a scientific theory, such as Newton’s Laws of Motion in physics, to develop the mathematical model of a system. In the example of the dropped ball, described above, we can apply Newton’s Second Law and Newton’s Law of Gravitation to the ball and predict that that relationship between the ball’s position and time should be a second-order polynomial equation, assuming that we ignore the effects of air resistance. We would arrive at the same equation as we hypothesized just on the basis of looking at the data, but the equation now is seen to be implied by the theory called Newton’s Laws of Motion.\nThe categories described above are not exclusive of each other. We can have theory-based deterministic models or theory-based stochastic models, for example.\nWe will use a variation on our four-step problem-solving strategy discussed in Chapter 2 when developing a mathematical model of a system. Here are the basic steps.\n\nAnalyze the problem\nFormulate a model\nSolve the model\nVerify and interpret the model’s solution\nReport on the model\nMaintain the model\n\nOur discussion of dynamical systems models will illustrate the use of this strategy.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/Ch01/Ch01_Introduction.html#introduction-to-textbook-computing-environment",
    "href": "chapters/Ch01/Ch01_Introduction.html#introduction-to-textbook-computing-environment",
    "title": "Introduction",
    "section": "Introduction to Textbook Computing Environment",
    "text": "Introduction to Textbook Computing Environment\nMany principles of computational science are independent of the programming language used to implement the computations, but it is easier to learn these principles using specific examples that involve a particular programming language. We will use Python as our primary programming language. To enable quick development and application of computational science principles we should establish a working Python programming environment now, so that it can be used immediately.\n\nTypes of Programming Environments\nThere are several ways to establish a good programming environment that uses Python:\n\nWe can download and install a Python distribution, such as the Anaconda Distribution and then use the IPython command line shell that comes with that distribution. This allows the user to execute Python interactively, one code line at a time.Install a Python distribution, such as Anaconda, that comes with a Jupyter server then use Jupyter notebooks to compose executable code and text blocks.\nInstall a Python distribution, such as Anaconda, then use a plain text editor (notepad, gedit, TextEdit) application to compose code and then execute the code from the command line using the appropriate command line console for your operating system.\nInstall a Python distribution, then install an IDE application (PyCharm, Spyder, VSCode) that bundle a smart text editor, an interactive console, and enhanced debugging tools into a nice GUI.\nUse a cloud computing platform such as CoCalc, pythonanywhere, or Google Colab that allows the user to use Jupyter notebooks without installing any software, except for a browser. The cloud service maintains the Python distribution.\n\n\n\nThe Google Colab Environment\nThe last method is easiest and quickest to use, so we will focus on it here. The other methods are discussed in the appendix. We will use Google Colab for our example. To use Jupyter notebooks in Colab do the following.\n\nSign into your Google account.\nGo to your Google Drive and create a folder that will contain your Colab notebooks, which will be named Colab Notebooks. Open the folder that you just created.\nOpen a new browser tab and goto https://colab.research.google.com. You will see the following window showing available file spaces:\n\n\n\n\nInitial Google Colab window.\n\n\n\nSelect the examples tab and select the Overview of Colaboratory Features notebook.\nRead through this notebook to get oriented to the Colab Jupyter notebook features.\n\nNote that there are two kinds of cells in the notebook: text cells and code cells. Code cells contain executable Python code. The cell contents can be executed by selecting the Play icon on the left of the cell or by clicking anywhere in the cell and typing Shift+Enter.\nLet’s now create a new Colab notebook from your Google Drive folder.\nNavigate to your Colab notebook folder that you created previously:\n\n\n\n\n\n\nFigure 18: Initial Google Colab window.\n\n\n\nSelect\n\n+ New\nMore\nGoogle Colaboratory\n\n\n\n\n\n\n\nFigure 19\n\n\n\nYou will get a new Colab Jupyter notebook in your folder, as shown in Figure Figure 20.\n\n\n\n\n\n\nFigure 20: New Colab notebook.\n\n\n\nThe new notebook is named Untitled0.ipynb by default. You can change the name as you would any Google Doc file. Leave the ipynb extension since that indicates that the file is a Jupyter notebook file.\nThe new notebook starts with one code cell. It is good practice to include documentation in your notebook, so let us put a text cell above the first code cell.\nPlace the mouse pointer right above the code cell so that the add code or text buttons appear.\nChoose the + Text option.\n\n\n\n\n\n\nFigure 21\n\n\n\nA text cell will appear above the code cell. Double click in the cell to begin text editing.\nYou should see an editing box on the left and a preview of the rendered text on the right.\n\n\n\n\n\n\nFigure 22\n\n\n\nYou can provide formatting of the text using Markdown syntax. The example below shows how to create a heading. We will discuss Markdown syntax later.\n\n\n\n\n\n\nFigure 23\n\n\n\nAfter you finish entering any text then click the Close Markdown icon (circled above).\nWhen you create a Colab notebook you can easily save the file in your Google Drive by selecting\nFile &gt; Save\nColab will also create a temporary folder accessible to the notebook while it is open. You can view the contents of this folder by selecting the File Explorer tool on the left.\n\n\n\n\n\n\nFigure 24\n\n\n\nThis folder will disappear when the notebook file is closed, so if your code writes to a file you will want to ensure that the file gets placed where it will not be lost. One way to do this is to connect your Google Drive to the Colab notebook while it is running. This can be done using the Mount Google Drive tool.\n\n\n\n\n\n\nFigure 25\n\n\n\nYou will now see your Google Drive as a folder in the File Explorer area.\n\n\n\n\n\n\nFigure 26\n\n\n\nLater, we will learn how to write directly to a file in the MyDrive folder using Python code in the notebook.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/Ch01/Ch01_Introduction.html#ch01-exercises",
    "href": "chapters/Ch01/Ch01_Introduction.html#ch01-exercises",
    "title": "Introduction",
    "section": "Exercises",
    "text": "Exercises\n1. Choose an area of science or engineering that interests you. Table 2 below lists areas that have a well-established record of computational solutions. Perform a web-based search using Google and library search resources to find a specific problem in the area that required computation to solve. Create a bibliography of these sources.\n\n\n\nTable 2: Wikipedia pages for areas of computational science.\n\n\n\n\n\nComputational archaeology\nComputational mathematics\n\n\n\n\nComputational astrophysics\nComputational mechanics\n\n\nComputational biology\nComputational neuroscience\n\n\nComputational chemistry\nComputational particle physics\n\n\nComputational materials science\nComputational physics\n\n\nComputational economics\nComputational sociology\n\n\nComputational electromagnetics\nComputational statistics\n\n\nComputational engineering\nComputational sustainability\n\n\nComputational finance\nComputer algebra\n\n\nComputational fluid dynamics\nFinancial modeling\n\n\nComputational forensics\nGeographic information system (GIS)\n\n\nComputational geophysics\nHigh-performance computing\n\n\nComputational history\nMachine learning\n\n\nComputational informatics\nNetwork analysis\n\n\nComputational intelligence\nNeuroinformatics\n\n\nComputational law\nNumerical weather prediction\n\n\nComputational linguistics\n\n\n\n\n\n\n\nYou should create a document that includes the following:\n\nA paragraph that describes the problem.\nA paragraph that describes why computation was required for solving or investigating the problem.\nFour (or more) references that give information on the problem. At least two of the references should be peer-reviewed sources such as research journal papers and academic books.\n\n2. Computational science can be thought of as the intersection between a scientific or engineering discipline such as biology, mathematics, and _______________________ .\n3. Computer science is the study of algorithms whereas computational science is the study of how _____________________ can be used to solve scientific problems.\n4. Traditional science would study a system by experimenting with the actual system and developing theories to help understand the system. Computational science adds to this approach by using _____________ to analyze and visualize data and to explore properties of mathematical _____.\n5. Which of the following are considered pillars of Computational Thinking, as defined in this course? (Choose all that are true.)\n\nalgorithms\narithmatic\nPython\nabstraction\ndecomposition\napplied science\npattern recognition\n\n6. Algorithms can be represented using\n\nflowcharts\ngraphs\nequations\nmathematical variables\n\n7. Select the statements below that are true concerning deductive reasoning.\n\nThe conclusion is probably rather than certain.\nThe conclusion necessarily follows from the premises.\nAn argument could be valid but unsound.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/Ch01/Ch01_Introduction.html#references",
    "href": "chapters/Ch01/Ch01_Introduction.html#references",
    "title": "Introduction",
    "section": "References",
    "text": "References\n\nAmin, O. S. M. (2019). Babylonian Clay Tablet [Photograph]. Own work. https://commons.wikimedia.org/wiki/File:Clay_tablet,_mathematical,_geometric-algebraic,_similar_to_the_Pythagorean_theorem._From_Tell_al-Dhabba%27i,_Iraq._2003-1595_BCE._Iraq_Museum.jpg\nDietrich, A., Wald, I., & Slusallek, P. (2005). Large-scale CAD Model Visualization on a Scalable Shared-memory Architecture. In G. Greiner, J. Hornegger, H. Niemann, & M. Stamminger (Eds.), Vision, Modeling, and Visualization 2005 (pp. 303–310). Akademische Verlagsgesellschaft Aka.\nFeild, A. (2019). Galaxy Types. https://hubblesite.org/contents/media/images/4508-Image.html\nKnuth, D. E. (1972). Ancient Babylonian algorithms. Communications of the ACM, 15(7), 671–677. https://doi.org/10.1145/361454.361514\nKoske, K. (2009). United Airlines B777-222 N780UA. United Airlines Boeing 777-222 (N780UA) Uploaded by Altair78. https://commons.wikimedia.org/wiki/File:United_Airlines_B777-222_N780UA.jpg\nMaggs, M. (2007). Falling Ball [Digital]. https://commons.wikimedia.org/wiki/File:Falling_ball.jpg\nMercator, P. (2013). Spherical trigonometry [Digital]. https://commons.wikimedia.org/wiki/File:Spherical_trigonometry_basic_triangle.svg\nNASA’s Scientific Visualization Studio. (2021, January 14). SVS: Global Temperature Anomalies from 1880 to 2020. NASA Scientific Visualizations Studio. https://svs.gsfc.nasa.gov/4882\nNew York Public Library / Science Source / Science Photo Library. (n.d.). Hipparchus, Greek Astronomer and Mathematician [Digital]. https://www.sciencephoto.com/media/1011097/view\nTemperature Composite. (n.d.). Skeptical Science. Retrieved January 9, 2022, from https://skepticalscience.com//graphics.php?g=7\nThe Shodor Education Foundation. (2000). Overview of Computational Science. ChemViz Curriculum Support Resources. http://www.shodor.org/chemviz/overview/compsci.html\nunknown. (1983). Commemorative Stamp of Muḥammad ibn Mūsā al-Ḵwārizmī. https://commons.wikimedia.org/wiki/File:1983_CPA_5426_(1).png\nUrone, P. P., & Hinrichs, R. (2012). 3.4 Projectile Motion. In College Physics. OpenStax.\nVogelsberger, M., Genel, S., Springel, V., Torrey, P., Sijacki, D., Xu, D., Snyder, G., Bird, S., Nelson, D., & Hernquist, L. (2014). Properties of galaxies reproduced by a hydrodynamic simulation. Nature, 509(7499), 177–182. https://doi.org/10.1038/nature13316\nWicks, R. (2022). Twelfth night [Digital]. https://unsplash.com/photos/FMARk9s_20s\nWing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33–35. https://doi.org/10.1145/1118178.1118215\nWing, J. M. (2014, January 10). Computational Thinking Benefits Society. Social Issues in Computing. http://socialissues.cs.toronto.edu/index.html%3Fp=279.html\nZhang, Y., & Zhao, Y. (2015). Astronomy in the Big Data Era. Data Science Journal, 14(0), 11. https://doi.org/10.5334/dsj-2015-011\n\n\n\n\n\nAmin, O. S. M. (14 March 2019, 11:03:07). Babylonian Clay Tablet [Graphic]. https://commons.wikimedia.org/wiki/File:Clay_tablet,_mathematical,_geometric-algebraic,_similar_to_the_Pythagorean_theorem._From_Tell_al-Dhabba%27i,_Iraq._2003-1595_BCE._Iraq_Museum.jpg\n\n\nDietrich, A., Wald, I., & Slusallek, P. (2005). Large-scale CAD Model Visualization on a Scalable Shared-memory Architecture. In G. Greiner, J. Hornegger, H. Niemann, & M. Stamminger (Eds.), Vision, Modeling, and Visualization 2005 (pp. 303–310). Akademische Verlagsgesellschaft Aka.\n\n\nFeild, A. (2019). Galaxy Types [Graphic]. https://hubblesite.org/contents/media/images/4508-Image.html\n\n\nKnuth, D. E. (1972). Ancient Babylonian algorithms. Communications of the ACM, 15(7), 671–677. https://doi.org/10.1145/361454.361514\n\n\nKoske, K. (18 October 2009, 11:52). United Airlines B777-222 N780UA [Graphic]. https://commons.wikimedia.org/wiki/File:United_Airlines_B777-222_N780UA.jpg\n\n\nMaggs, M. (2007). Falling Ball [Graphic]. https://commons.wikimedia.org/wiki/File:Falling_ball.jpg\n\n\nMercator, P. (2013). Spherical trigonometry [Graphic]. https://commons.wikimedia.org/wiki/File:Spherical_trigonometry_basic_triangle.svg\n\n\nNASA’s Scientific Visualization Studio. (2021, January 14). SVS: Global Temperature Anomalies from 1880 to 2020. NASA Scientific Visualizations Studio. https://svs.gsfc.nasa.gov/4882\n\n\nNew York Public Library / Science Source / Science Photo Library. (n.d.). Hipparchus, Greek Astronomer and Mathematician [Graphic]. https://www.sciencephoto.com/media/1011097/view\n\n\nPaul Peter Urone, & Roger Hinrichs. (2012). Trajectory of a rock [Graphic]. https://openstax.org/books/college-physics/pages/3-4-projectile-motion\n\n\nTemperature Composite. (n.d.). Skeptical Science. Retrieved January 9, 2022, from https://skepticalscience.com//graphics.php?g=7\n\n\nThe Shodor Education Foundation. (2000). Overview of Computational Science. ChemViz Curriculum Support Resources. http://www.shodor.org/chemviz/overview/compsci.html\n\n\nunknown. (1983). Commemorative Stamp of Muḥammad ibn Mūsā al-Ḵwārizmī [Graphic]. https://commons.wikimedia.org/wiki/File:1983_CPA_5426_(1).png\n\n\nVogelsberger, M., Genel, S., Springel, V., Torrey, P., Sijacki, D., Xu, D., Snyder, G., Bird, S., Nelson, D., & Hernquist, L. (2014). Properties of galaxies reproduced by a hydrodynamic simulation. Nature, 509(7499, 7499), 177–182. https://doi.org/10.1038/nature13316\n\n\nWicks, R. (2022). Twelfth night [Graphic]. https://unsplash.com/photos/FMARk9s_20s\n\n\nWing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33–35. https://doi.org/10.1145/1118178.1118215\n\n\nZhang, Y., & Zhao, Y. (2015). Astronomy in the Big Data Era. Data Science Journal, 14(0, 0), 11. https://doi.org/10.5334/dsj-2015-011",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/Ch02/Ch02_ComputationalThinking.html",
    "href": "chapters/Ch02/Ch02_ComputationalThinking.html",
    "title": "Computational Thinking and Problem Solving",
    "section": "",
    "text": "Elements of Problem Solving\nWhen faced with a difficult problem that must be solved, we often feel bewildered about how to even get started. While there is no single strategy that can guarantee success, we now understand some systematic approaches to problem solving that can usually get us started.\nGeorge Polya, author of How to Solve It (Polya, 1971), was a pioneer in the area of heuristics, the formal study of problem-solving. The book How to Solve It was addressed to teachers of mathematics with the hope of helping them teach problem-solving to mathematics students, but the model presented in the book is now widely used as a starting point in many other areas of knowledge besides mathematics. The model he presents will be our starting point in developing a general strategy for developing problem solutions that can be used by a computer.\nThe Polya model consists of four steps:\nWe will reformulate the Polya model to better match development of computer programs. Our working problem-solving model for solving computational problems will have the following general steps:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Computational Thinking and Problem Solving</span>"
    ]
  },
  {
    "objectID": "chapters/Ch02/Ch02_ComputationalThinking.html#elements-of-problem-solving",
    "href": "chapters/Ch02/Ch02_ComputationalThinking.html#elements-of-problem-solving",
    "title": "Computational Thinking and Problem Solving",
    "section": "",
    "text": "Understand the problem\nPlan the solution\nCarry out the plan\nLook back at the solution\n\n\n\nAnalysis: Analyze the problem\nDesign: Describe the data and develop algorithms\nImplementation: Represent data using programming language data structures and implement the algorithms with specific programming language code\nTesting: Test and debug the code using test data\n\n\nAnalysis\nThe analysis stage of problem-solving seeks to gain a fuller understanding of the problem so that possible paths towards a solution can be described. To assist in the analysis of a problem try the following:\n\nRestate the problem in your own words.\nRepresent the problem using pictures and diagrams.\nList the things you know and the things you do not know that are relevant to the problem.\nDefine the goal of your problem solution. Describe what a successful solution would look like.\n\n\n\nDesign\nOne of the fundamental methods for designing an algorithm is decomposition: breaking the problem into smaller parts. Decomposition is one of the pillars of computational thinking. The big problem is replaced by a series of smaller problems, each one being more tractable. Sometimes the subproblems are still too complex and decomposition can be applied to them too.\nAnother element of design is to recognize what kind of data that you have to facilitate a solution and how that data can be described precisely. This process can be characterized as abstraction and data representation.\nUltimately, a major part of design is to develop a specific algorithm for the solution. If you are really stumped by how to get started with your algorithm design, it can be helpful to replace the original problem with a related problem that is easier to solve. After solving the easier problem, you may find that elements of the solution can be incorporated into the original problem solution design. Sometimes you might solve several related problems each of which is easier to solve. Then you can look for patterns in your solutions that might apply to the original problem.\n\n\nImplementation\nThe design phase of problem-solving focuses on general descriptions of data representations and algorithms. When the solution requires a computer program, those general design descriptions must be made specific by coding them using a programming language, such as Python. Solution steps described using a flowchart or pseudocode representation will need to be translated into specific Python statements, and data will need to make use of existing data types and structures present in Python or new data structures that can be constructed within the Python language. Performing these steps is the implementation of the problem solution.\n\n\nTesting\nAny problem solution must be evaluated for correctness. When the solution is a computer program such an evaluation can become quite involved. A program that executes without syntax errors is not necessarily providing the output required by the problem solution. This output must be compared with the expectations provided in the analysis phase of our problem-solving strategy. We will discuss some specific ways of testing later once we acquire some additional understanding of coding Python programs.\n\n\nExample\nWe will use a physics problem to illustrate using our problem-solving strategy.\nProblem Statement: A baseball is hit with an initial velocity of 40.0 [m/s] at an angle of 20w.r.t. the ground. The ball is 1.2 [m] above the ground when it is hit. How far does the ball travel before hitting the ground?\nAnalysis: We will start by making some simplifying assumptions.\n\nThe ball will be modeled as a single particle, so any rotational effects will be ignored.\nThe effects of air resistance will be ignored, so the trajectory can be assumed to be in a single plane.\n\nThese assumptions imply the use of abstraction to focus on an initial understanding of the situation. Next, we will draw a picture to fix the geometry, shown in Figure 1.\n\n\n\n\n\n\nFigure 1: Geometry for the baseball problem.\n\n\n\nUsing information from the problem statement, we can specify given information.\n\\[\nx_0 = 0\n\\]\n\\[\ny_0 = 1\\ldotp 2\\left[\\text{m}\\right]\n\\]\n\\[\nv_0 = 40.0\\left[\\text{m/s}\\right]\n\\]\n\\[\n\\theta_0 = 20\\text{°}\n\\tag{1}\\]\n\\[\nv_{0x} = v_0\\cos \\left(\\theta_0\\right) = 40.0\\left[\\text{m/s}\\right]\\cos \\left(20\\text{°}\\right) = 37.5\\left[\\text{m/s}\\right]\n\\]\n\\[\nv_{0y} = v_0\\sin \\left(\\theta_0\\right) = 40.0\\left[\\text{m/s}\\right]\\sin \\left(20\\text{°}\\right) = 13.7\\left[\\text{m/s}\\right]\n\\]\nAs part of our analysis, we can describe physics laws that might be applicable.\nKinematic Equations for Constant Acceleration:\n\\[\n    x = x_0 + v_{0x}t \\tag{2}\\]\n\\[\n    y = y_0 + v_{0y}t- \\frac{1}{2}gt^2 \\tag{3}\\]\nThe solution to the problem will be the value of R, which is the value of \\(x\\) when \\(y=0\\).\nDesign: We can express the plan for calculating R:\n\nPut the knowns into Equation 2 and Equation 3\nSolve Equation 3 for \\(t\\) when \\(y=0\\). Call this time \\(T\\).\nSubstitute the value of \\(T\\) obtained into Equation 2 and calculate \\(x\\).\n\nImplementation: The Design plan requires some algebra, which can be done by using the quadratic formula on Equation 3. The result is\n\\[T = 2.88\\left[\\text{s}\\right]\\Rightarrow R = 108\\left[\\text{m}\\right]\\]\nTesting: For this problem solution, testing the solution involves determining whether the value we found is sensible. A distance of 108 [m] is 354 [ft], which is less than the typical distance from home plate to the stadium edge for a professional baseball stadium (~400 [ft]).\nBoth Implementation and Testing will look different when the problem involves developing a computer program. We will see many examples of performing these steps as we become more involved in coding.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Computational Thinking and Problem Solving</span>"
    ]
  },
  {
    "objectID": "chapters/Ch02/Ch02_ComputationalThinking.html#basic-elements-of-python",
    "href": "chapters/Ch02/Ch02_ComputationalThinking.html#basic-elements-of-python",
    "title": "Computational Thinking and Problem Solving",
    "section": "Basic Elements of Python",
    "text": "Basic Elements of Python\nWe will be using the Python programming language to develop our skills in computational science. Python was released in 1991 by its primary author, Guido van Rossum, who named the language after one of his favorite television shows, Monty Pythons Flying Circus, a comedy series produced by the BBC. Python has gone through many revisions since its introduction. We will use version 3.6 since the Google Colab platform currently supports it.\nHere we introduce a few of the basic elements of the Python programming language that will enable us to start implementing our own programs. In particular, we will cover\n\nLiterals\nVariables and Identifiers\nOperators\nExpressions\nData Types\nSyntax\n\nExtensive documentation for the Python programming language is provided online (Python Software Foundation, 2021).\n\nLiterals\nOne dictionary definition of the word “literal” is “taken at face value” and programming languages use a similar definition: a literal is a sequence of characters that stand for itself. We will consider numeric literals and string literals. These will form building blocks for writing code.\nA numeric literal is a character sequence containing only the digits 0-9, a + or – sign, possibly a decimal point, and possibly the letter e, which will indicate scientific notation. A numeric literal with a decimal point is called a floating-point value. A numeric literal without a decimal point is called an integer value. One additional numerical literal is the complex value. It is written as the sum of the real part and imaginary part. The imaginary part is indicated using the character j. Here is an example:\nc = 3.0 + 4.0j    \nCommas are not used in numeric literals. Table 1 gives examples of numeric literals.\n\n\n\nTable 1: Examples of numeric literals.\n\n\n\n\n\nInteger Values\nFloating-point Values\nComplex Values\nIncorrect Values\n\n\n\n\n0\n5. , 5.0, +5.0\n2.0 + 3.0j\n1,500\n\n\n10\n15.25\n4 – 5j\n1,500.00\n\n\n25\n15.25\n0.56 + 1.7j\n+1,500\n\n\n-25\n-15.25\n-6.0 + 7.0j\n-1,500.00\n\n\n\n\n\n\nA numeric literal with no + or – sign in front of it is considered positive.\nNext we consider string literals, usually called “strings”. These are sequences of alphanumeric characters. String values are indicated using matching single quotes or double quotes:\n‘My name is Bob’ , “My name is Bob”\nNote that a blank character can be in a string value. If the string literal contains an apostrophe, then the value should be enclosed by matching double quotes.\n“Bill’s Bookstore”\nA string literal with no characters in it is called the empty string and is indicated with matching single quotes or double quotes enclosing no characters:\n’’ or “”\n\n\nVariables and Identifiers\nAn identifier is a sequence of characters that is used as a name for a programming element such as a function. The rules for constructing identifiers are\nThey may contain letters and digits but cannot begin with a digit.\nThey are case-sensitive.\nThey cannot contain quotes\nThe underscore ’_’ can be used but should be avoided as the first character.\nTable 2 gives some examples of identifiers.\n\n\n\nTable 2: Examples of identifiers.\n\n\n\n\n\nValid Identifiers\nInvalid Identifiers\nReason\n\n\n\n\ngravitationalforce\ngravitationalForce’\nCannot contain quotes\n\n\ngravitationalForce\n2022_year\nCannot start with a digit\n\n\ngravitational_force\n_gravitationalForce V\nalid but should be avoided\n\n\n\n\n\n\nA variable is a name assigned to a value. Python assigns a value to a variable by using the assignment operator, =.\nnum = 15\nThe variable num now refers to the value 15. Whenever the variable num is used in a Python expression it will be replaced by the value 15. Consider the expression\nnum + 1\nThis expression will evaluate to 16 since num actually represents the number 15.\nA variable can be reassigned to a different value at different points in a program.\n\n\nKeywords\nA keyword is a predefined identifier that has a reserved specific use in a programming language. Keywords should not be used as a variable name or other user-defined identifier. If you try to do this then there will be a syntax error when the code is executed. Figure 2 shows what happens when you try to use the keyword ‘or’ as a variable.\n\n\n\n\n\n\nFigure 2: Incorrect use of keyword identifier.\n\n\n\nTable 3 shows all of the keyword identifiers used in Python 3.6. These identifiers are case-sensitive.\n\n\n\nTable 3: Python 3.6 keywords.\n\n\n\n\n\nand\ndel\nfrom\nNone\nTRUE\n\n\n\n\nas\nelif\nglobal\nnonlocal\ntry\n\n\nassert\nelse\nif\nnot\nwhile\n\n\nbreak\nexcept\nimport\nor\nwith\n\n\nclass\nFALSE\nin\npass\nyield\n\n\ncontinue\nfinally\nis\nraise\n\n\n\ndef\nfor\nlambda\nreturn\n\n\n\n\n\n\n\n\n\nOperators\nAn operator is a symbol that indicates some kind of operation performed on one or more operands. An operand is a value, such as a number, that the operator acts on. Arithmetic operators such as addition, subtraction, multiplication, and division require two operands and are called binary operators. An operator that requires only one operand, such as negation, is called a unary operator.\nAmong the most important operators for scientific and engineering programming are the arithmetic operators shown in Table 4.\n\n\n\nTable 4: Python arithmetic operators.\n\n\n\n\n\nOperator\nOperation\nExample\nResult\n\n\n\n\n-x\nnegation\n-100\n-100\n\n\nx + y\naddition\n100 + 25\n125\n\n\nx - y\nsubtraction\n100 - 25\n75\n\n\nx * y\nmultiplication\n100 * 4\n400\n\n\nx / y\ndivision\n100 / 4\n25\n\n\nx // y\ntruncating division\n100 // 3\n33\n\n\nx ** y\nexponentiation\n10 ** 3\n1000\n\n\nx % y\nmodulus\n50 % 6\n2\n\n\n\n\n\n\nNotice that unlike in many programming languages, exponentiation uses the operator ** rather than the caret symbol ^.\nThere will be times when programming requires knowing what data type is produced by an operator. Consider division using the / operator. It will always produce a float, even if both operands are integers, as shown in Figure 3.\n\n\n\n\n\n\nFigure 3: Data type produced by division.\n\n\n\nNow consider truncating division performed by the operator //. If both operands are integers (type int) then the result is an integer. If either operator is a float then the result is a float. Figure 1.6 illustrates this behavior with code snippets.\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 4: Data type produced by truncating division.\n\n\n\nThe modulus operator % may be less familiar than the other arithmetic operators. It is a binary operator that returns the remainder after performing division. If the operands are both integers (type int) then result will be an integer, otherwise the result will be a float.\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 5: Result of modulus operator.\n\n\n\nTable 5 shows the cyclic nature of the modulus operator.\n\n\n\nTable 5: Result of modulo 5 modulus operator.\n\n\n\n\n\nOperation\nResult\n\n\n\n\n0 % 5\n0\n\n\n1 % 5\n1\n\n\n2 % 5\n2\n\n\n3 % 5\n3\n\n\n4 % 5\n4\n\n\n5 % 5\n0\n\n\n6 % 5\n1\n\n\n7 % 5\n2\n\n\n8 % 5\n3\n\n\n9 % 5\n4\n\n\n10 % 5\n0\n\n\n\n\n\n\n\n\nExpressions\nAn expression is a combination of variables, values, and operators that evaluates to a single value. A sub-expression is an expression that is part of a larger expression. We will consider arithmetic expressions here. The following are examples of arithmetic expressions in Python.\n\\[1 + 2,3*n + 1,4*\\left(n - 1\\right)\\]\nIn these expressions, the variable \\(n\\) must have been assigned a value, otherwise, an error will occur.\nTo avoid ambiguity about the order in which operators are executed in an expression, Python defines a particular order in which operators are applied. Table 6 gives the operator precedence used by Python.\n\n\n\nTable 6: Python operator precedence. The vertical ordering is from high to low going down.\n\n\n\n\n\nOperator\nOperation\nAssociativity\n\n\n\n\n**\nexponentiation\nright-to-left\n\n\n-\nnegation\nleft-to-right\n\n\n* , / , // , %\nmult , division, trunc, div, modulo\nleft-to-right\n\n\n+ , -\naddition , subtraction\nleft-to-right\n\n\n\n\n\n\nThe operator associativity refers to the order in which operators are applied when they have the same precedence. Consider the expression\n\\[4**3**2\\]\nWhich exponentiation gets evaluated first: \\(4**3\\) or \\(3**2\\)? The right-to-left associativity rule for exponentiation says the \\(3**2\\) operation is performed first.\n\\[4**3**2\\rightarrow 262144\\text{ not 4096}\\]\nIf the operator precedence in this situation had been left-to-right then the result of evaluating this expression would have been 4096.\nNow consider the expression \\[2/3*4\\]\nSince the / and * operators have the same precedence we use the left-to-right associativity rule to perform\n\\[2/ 3\\rightarrow 0.6666\\text{ then  }0.6666*4\\rightarrow 2.6667\\]\nyielding the final value 2.6667.\nA good practice in coding expressions is to use parentheses to enforce a desired precedence rather than relying on the Python-defined precedence rules. Sub-expressions defined by parentheses are evaluated first.\n\n\nData Types\nThe formal definition of data type is a set of literal values, such as numbers or strings, and the operators that can be applied to them, such as addition and subtraction. Python uses several built-in data types. These are shown in Table 7.\n\n\n\nTable 7: Python built-in datatypes\n\n\n\n\n\nCategory\nAssociated Python Keyword\n\n\n\n\nText Type:\nstr\n\n\nNumeric Types:\nint, float, complex\n\n\nSequence Types:\nlist, tuple, range\n\n\nMapping Type:\ndict\n\n\nSet Types:\nset, frozenset\n\n\nBoolean Type:\nbool\n\n\nBinary Types:\nbytes, bytearray, memoryview\n\n\nNone Type:\nNoneType\n\n\n\n\n\n\nFor now, we will focus only on the text and numeric types. Understanding data types can help us avoid problematic operations. For example, division, /, does not apply to strings or mixed string and numeric expressions. The following code will produce an error:\ns1 = 'This is a string.'\ns2 = 'This is another string.'\ns1/s2 # This expression will produce an error.\nSimilarly\ns1 = 'This is a string.'\ns1/2 # This expression will produce an error.  \nThe built-in function type(v) will tell you the data type of v.\n\n\n\n\n\n\nFigure 6: Example of type( ) function use.\n\n\n\nAll programming languages use the concept of data type, but the implementation differs between languages. Some languages such as C, C++, or Java require that the data type of a variable be declared explicitly before the variable can be used in an expression. This is called static typing. Other languages, including Python, will assign the data type to a variable automatically when the program is executed based on the value referred to by the variable. This is called dynamic typing. The same variable name can be assigned a different data type at different places in the program.\nA complex expression can have sub-expressions or variables of different data types. These are called mixed-type expressions. In order for a mixed-type expression to evaluate to a single value, all the components or operands in the expression must be converted to a single type. This procedure can be done automatically by the Python interpreter, called coercion, or the programmer can explicitly perform conversions using data type conversion functions, which is called type conversion.\nWhen the Python interpreter performs coercion, it will do so in a way to avoid loss of information. For example in the expression\n1 + 2.5  \nconverting the 1 to 1.0 (int to float) does not result in loss of information but converting 2.5 to 2 (float to int) does. Therefore, the int to float conversion will be done and the final value, 3.5, will be a float. We can perform the type conversions explicitly using type conversion functions. In the above example, explicit type conversion could be done with\n\\[\\text{float}\\left(\\text{1}\\right) + 2.5\\rightarrow 1.0 + 2.5\\rightarrow 3.5\\]\n\n\n\nTable 8: Examples of explicit type conversion.\n\n\n\n\n\nType Conversion\nResult\n\n\nfloat(5)\n5\n\n\nfloat(‘5’)\n5\n\n\nfloat(‘A String’)\nerror\n\n\nint(5.0)\n5\n\n\nint(5.2)\n5\n\n\nint(‘5’)\n5\n\n\nint(‘5.2’)\nerror\n\n\n\n\n\n\n\n\nSyntax\nSyntax refers to the structure of a program and the rules about that structure. All languages have syntax. When discussing human languages such as English, syntax refers to the rules of grammar. We will introduce Python syntax rules as we learn about new elements of the language. The Python interpreter will determine if code has syntax errors and will inform you with an error message. Code that is syntactically correct can still generate a runtime error. For example\n10/0\nis syntactically correct but will generate an error when the expression is evaluated.\nA semantic error occurs when the program is syntactically correct and generates no runtime errors, but the output is still incorrect. This means that the programmer has not translated the design of the problem solution into code correctly. Semantic errors will be the most difficult ones to eliminate.\n\n\nComment Statements\nComment statements are added to code to help humans better understand what is happening in the program. Comment statements are ignored by the Python interpreter, yet they remain an important part of documenting the code. There are two methods of inserting comments:\n\nSingle line comment.\nComment Block\n\nA single line comment is indicated with the # character. Everything after the # on the line is ignored.\n# This entire line is ignored\nn = 5 # Everything on this line is ignored after the # character    \nA comment block is created with triple single quotes or triple double quotes. All lines between a triple single quote or double quote are ignored until another triple single quote or double quote is encountered.\nSingle quote block:\n'''\ncomment block line 1\ncomment block line 2\n'''  \nDouble quote block:\n\"\"\"\ncomment block line 1\ncomment block line 2\n\"\"\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Computational Thinking and Problem Solving</span>"
    ]
  },
  {
    "objectID": "chapters/Ch02/Ch02_ComputationalThinking.html#basic-input-and-output",
    "href": "chapters/Ch02/Ch02_ComputationalThinking.html#basic-input-and-output",
    "title": "Computational Thinking and Problem Solving",
    "section": "Basic Input and Output",
    "text": "Basic Input and Output\nWhen we execute a program interactively, such as in a Jupyter notebook or IPython console, obtaining information from the user and communicating messages to the user will be necessary. The Python built-in functions input and print are simple methods to perform these tasks.\nThe input function will request information from the user by printing a message and then waiting for the user to enter something using the keyboard. After hitting enter or return the string entered by the user is returned to the program. For example\nname = input('What is your name?:')  \nwill print the string given as the argument of the function, then wait until the user types in something, and then returns what was typed as a string that gets assigned to the variable name. Figure 7 shows how this input request looks in a Jupyter notebook.\n\n\n\n\n\n\nFigure 7: Example of input function use in a notebook.\n\n\n\nBasic output is achieved with the print function. It will print items in its argument list to the standard output, which will be an output cell in a Jupyter or Colab notebook. Multiple items can be printed by including them as comma separated items in the function argument list. Figure 8 shows an example of this behavior.\n\n\n\n\n\n\nFigure 8: Example of printing multiple items.\n\n\n\nThe separator between arguments printed out can be specified using the sep keyword argument. The default value is the empty string.\n\n\n\n\n\n\nFigure 9: Use of the sep keyword argument.\n\n\n\nIf the program needs to obtain a number from the user using the input function then the string that is returned will need to be converted into the appropriate numerical data type using the corresponding type conversion function. The following shows how to obtain a floating point number from the user.\nfloat_number = float ( input ( 'Submit a floating point number:') )   \nAfter execution the variable float_number will contain the number submitted and it will be of type float.\nFormatting the printed output of a program can be an important part of the solution. We will discuss here one method for formatting numbers to a specified precision. We will use the built-in format function. Consider the following number.\nn = 3.14159\nSuppose we want to print n out with 2 decimal places. We can do this with the format function, which has the following syntax:\nformat(value, format_specifier)   \nwhere\nformat_specifier: ‘[width][.precision]type’\n\nwidth – total number of characters in the field\nprecision – number of decimal places\ntype –\n\nf – float\ne – exponential\n\n\nNote that the width and precision fields are optional, which is indicated with the brackets.\nTo format the variable n to two decimal places, use the following code.\n\n\n\n\n\n\nFigure 10: Example of using the format function.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Computational Thinking and Problem Solving</span>"
    ]
  },
  {
    "objectID": "chapters/Ch02/Ch02_ComputationalThinking.html#ch02-exercises",
    "href": "chapters/Ch02/Ch02_ComputationalThinking.html#ch02-exercises",
    "title": "Computational Thinking and Problem Solving",
    "section": "Exercises",
    "text": "Exercises\n1. The Polya general problem solving model is reformulated for computational problems to consist of the following four steps (select the correct ones):\n\nAnalysis\nDesign\nImplementation\nTesting\nDebugging\nFlowcharting\n\n2. Which of the following are correctly formulated numerical literals?\n\n1,200\n1200\n\n\n\n1200.0\n\n3. Which of the following are legal Python variable names?\n\n3CPO\nn1\n‘number’\nchiefExecutive\nfor\n\n4. What value will the following expression have?\n3 + 8 * (3**2 - 8) / 10\n\n3.0\n3\n3.8\n4\n\n5. What is the value produced by each of the following expressions?\n\n12/5\n12./5.\n12.0//5.0\n12%5\n\n6. What is the data type of the variable n after the following code has been executed?\nn = 2\nn = n*3\nn = n/3 \n7. What is the data type of the variable num after the following statement is executed?\nnum = input('Type in a floating point number: ')  \n\nint\nfloat\nstr",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Computational Thinking and Problem Solving</span>"
    ]
  },
  {
    "objectID": "chapters/Ch02/Ch02_ComputationalThinking.html#ch02-program-modification-problems",
    "href": "chapters/Ch02/Ch02_ComputationalThinking.html#ch02-program-modification-problems",
    "title": "Computational Thinking and Problem Solving",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. The code presented below will request that the user submit a temperature in Fahrenheit and then converts it to a temperature in Celsius and prints out the result.\n\"\"\"\nProgram: Temperature Conversion Program (Fahrenheit to Celsius)\nAuthor: C.D. Wentworth\nVersion: 1.25.2020.1\nSummary: This program will convert a temperature entered in Fahrenheit\n         to the equivalent temperature in Celsius\n\n\"\"\"\n\n# get temperature in Fahrenheit\nTF = float(input('Enter degrees Fahrenheit: '))\n\n# calc degrees Celsius\nTC = (TF - 32) * 5 / 9\n\n# output degrees Celsius\nprint(TF, 'degrees Fahrenheit equals',\n       format(TC, '.1f'), 'degrees Celsius')\n   \nRevise the program to do the following:\n\nPrint out a program greeting that describes what the program will do.\nRequests that the user submit a temperature in Celsius.\nPrints out the temperature in Fahrenheit with an appropriate message.\n\n2. Create a program that requests a temperature from the user in Fahrenheit and then prints out the temperature in Celsius and Kelvins with appropriate messages. You can start with the code from Program Modification Problem 1.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Computational Thinking and Problem Solving</span>"
    ]
  },
  {
    "objectID": "chapters/Ch02/Ch02_ComputationalThinking.html#references",
    "href": "chapters/Ch02/Ch02_ComputationalThinking.html#references",
    "title": "Computational Thinking and Problem Solving",
    "section": "References",
    "text": "References\n\nPolya, G. (1971). How to Solve It: A New Aspect of Mathematical Method (2nd ed.). Princeton University Press.\nPython Software Foundation. (2021). Python 3.6.15 Documentation. https://docs.python.org/3.6/\n\n\n\n\n\nPolya, G. (1971). How to Solve It: A New Aspect of Mathematical Method (2nd ed.). Princeton University Press.\n\n\nPython Software Foundation. (2021). Python 3.6.15 Documentation. https://docs.python.org/3.6/",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Computational Thinking and Problem Solving</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html",
    "href": "chapters/Ch03/Ch03_ControlStructures.html",
    "title": "Control Structures",
    "section": "",
    "text": "Motivating Problem: Temperature Conversions\nScientists and engineers must use several temperature scales in their work. In the United States, most of the public still uses the Fahrenheit scale, while in scientific research the metric scales Celsius and Kelvin are preferred. Modern thermodynamic science postulates a lowest possible temperature for a physical system, which suggests using temperature scales for which 0 corresponds to this lowest possible temperature. The Kelvin scale is the absolute temperature scale in the metric system. Engineers working in the U.S. must often use the Rankine temperature scale, which associates 0 with absolute zero, but where a temperature difference of one Rankine equals one degree Fahrenheit.\nGiven the need for scientists and engineers to use different temperature scales, creating a computer program that can take a temperature given in one scale by a user and convert it to a temperature in another scale is an important problem. We will need additional ways to control the flow of a program to solve this problem, in particular, we must execute different blocks of code depending on which temperature conversion must be done.\nThis chapter introduces elements of the programming language that allow for sophisticated program control based on information submitted by the user. We will learn about Boolean expressions and how they are used by the different control structures available in Python.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#definition-of-control-structures",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#definition-of-control-structures",
    "title": "Control Structures",
    "section": "Definition of Control Structures",
    "text": "Definition of Control Structures\nControl flow refers to the sequencing of executed statements in a program. A control structure is a type of statement in a programming language that determines the control flow in a program. All programming languages provide the following control structures:\n\nsequential control\nselection control\niterative control\n\nSequential control is the execution of statements one after the other. It is what we have used previously. Selection control involves executing a different block of code depending on the value of a conditional statement, such as one that evaluates to true or false. Iterative control allows for the repetition of a block of statements based on a condition. Figure 1 illustrates these three kinds of control structures.\n\n\n\n\n\n\nFigure 1: The three kinds of flow control structures.\n\n\n\nWe see in Figure 1 that sequential control involves executing a statement, then executing the next statement, and so on. Selection control shows the program arriving at a decision point where some kind of condition statement is evaluated, often a true/false kind of statement, then the program flow goes to a different code block depending on the value of the condition. Iterative control shows the program arriving at a decision point where a condition statement is evaluated and as long as the condition is true then a code block gets executed in a loop, and when the condition becomes false the program control continues after the loop.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#boolean-expressions",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#boolean-expressions",
    "title": "Control Structures",
    "section": "Boolean Expressions",
    "text": "Boolean Expressions\nSelection and iterative control often involve a logical expression that evaluates to true or false. Such values are called Boolean data type. Programming languages use Boolean algebra to evaluate expressions involving Boolean variables or values. This type of algebra was developed by the 19th century mathematician George Boole . Instead of operations performed on numbers, as is done in traditional algebra, Boolean algebra involves operations performed on True/False values. We will introduce the Boolean (or logical) operators and, or, and not, and learn how to use them to construct complex Boolean expressions, which always evaluate to either True or False.\nIn Python, the logical values of true and false are indicated by True and False. The capitalization is important. Also note that the Boolean operators are keywords in Python, so they should not be used as variable names and other identifiers.\nThe and and or operators are binary operators requiring two Boolean variables or values as operands. The not operator is a unary operator, which simply turns the logical value to its opposite: True becomes False and False becomes True. The result of Boolean operators is defined by the Boolean Truth Table given in Table 1.\n\n\n\nTable 1: Boolean logic truth table.\n\n\n\n\n\nx\ny\nx and y\nx or y\nnot x\n\n\nFALSE\nFALSE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nFALSE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\nTRUE\nTRUE\nTRUE\nTRUE\nFALSE\n\n\n\n\n\n\nRelational operators are often involved in Boolean expressions. These operators These operators are used in comparing two values. The Python relational operators are shown in Table 2.\n\n\n\nTable 2: Python relational operators.\n\n\n\n\n\nOperator\nMeaning\nExample\nResult\n\n\n==\nequal\n15 == 20\nFALSE\n\n\n!=\nnot equal\n15 != 20\nTRUE\n\n\n&lt;\nless then\n15 &lt;20\nTRUE\n\n\n&gt;\ngreater than\n15 &gt;20\nFALSE\n\n\n&lt;=\nless than or equal\n15 &lt;= 15\nTRUE\n\n\n&gt;=\ngreater than or equal\n15 &gt;= 20\nFALSE\n\n\n\n\n\n\nThe relational operators can be applied to any kind of value that has an ordering, including strings. The ordering of string values follows a dictionary ordering based on a particular way of assigning numbers to a character. Python uses the Unicode Standard (Unicode Consortium, 2021) for encoding characters. In this system A is less than B, because the Unicode code for A is 65 and the Unicode code for B is 66. Since the Unicode code for lowercase letters is greater than it is for uppercase letters we have a is greater than B.\nWe should be careful to avoid errors in using relational operators coming from not distinguishing between meaningful mathematical expressions and meaningful programming language expressions. Consider the following.\n\\[\\label{eq:Equation3.1}\n    10 &lt;  = \\text{num} &lt;  = 20 \\tag{1}\\]\nAssume that the variable num represents the number 15. The expression is understood in mathematics to mean\n\\[\\label{eq:Equation3.2}\n\\left(10 &lt;  = \\text{num}\\right)\\text{and}\\left(\\text{num} &lt;  = 20\\right) \\tag{2}\\]\nwhich evaluates to True, but most programming languages will not make this implicit assumption. Instead the evaluation will proceed as follows.\n\\[10 &lt;  = \\text{num} &lt;  = 20\\rightarrow \\left(10 &lt;  = \\text{num}\\right) &lt;  = 20\\rightarrow \\text{True} &lt;  = 20\\rightarrow \\text{error}\\]\nThe final step yields an error since we are trying to compare two different kinds of data, Boolean and numerical. To avoid this problem, you should use parentheses explicitly, as shown in Equation 2.\nThe Boolean operators must be added to the operator precedence definitions. Table 3 gives the operator precedence order including Boolean operators.\n\n\n\nTable 3: Updated operator precedence table.\n\n\n\n\n\nOperator\nOperation\nAssociativity\n\n\n**\nexponentiation\nright-to-left\n\n\n-\nnegation\nleft-to-right\n\n\n* , / , // , %\nmult , division, trunc, div, modulo\nleft-to-right\n\n\n+ , -\naddition , subtraction\nleft-to-right\n\n\n&lt;,&gt;,&lt;=,&gt;=,!=,==\nrelational operators\nleft-to-right\n\n\nnot\nnot\nleft-to-right\n\n\nand\nand\nleft-to-right\n\n\nor\nor\nleft-to-right\n\n\n\n\n\n\nParentheses can be used in expressions to help humans reading the code to recognize the desired operator precedence. Consider the expression\n\\[1 + 2 &lt; 3 + 4\\]\nThe expression is evaluated using the operator precedence order in Table 3 as\n\\[1 + 2 &lt; 3 + 4\\rightarrow 3 &lt; 7\\rightarrow \\text{True}\\]\nTo assist a human reader of the code the operator precedence could be made explicit by writing the expression as\n\\[\\left(1 + 2\\right) &lt; \\left(3 + 4\\right)\\]\nUsing parentheses in this way is good programming practice.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#selection-control-overview",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#selection-control-overview",
    "title": "Control Structures",
    "section": "Selection Control Overview",
    "text": "Selection Control Overview\nSelection control allows for different blocks of statements to be executed depending on the value of a conditional expression, often a Boolean expression. We will discuss the Python if statement as the primary example of this control structure. Here is the basic form of the if statement:\nif condition:\n    statement block\nelse:\n    statement block\nThe condition in this statement must be a Boolean expression, that is one that evaluates to True or False. Also, the else part is optional. Here is a specific example.\nif grade &gt;= 70:\n    print('satisfactory performance')\nelse:\n    print('improvement needed') \nOne thing to note about Python syntax is that indentation is important. All statements in a particular statement block must be indented the same amount. To clarify this situation, we must introduce some additional vocabulary. Consider a simplified version of the temperature conversion task. Suppose that the problem is to convert Fahrenheit to Celsius or Celsius to Fahrenheit, depending on what the user specifies. Assume that the user inputs F-C or C-F depending on which conversion must be done. This code will be contained in temp_conversion_type. The temperature to be converted will be in the variable temp_to_convert. The converted temperature will be in the variable converted_temp. Figure 2 introduces some vocabulary to help in discussing control structures.\n\n\n\n\n\n\nFigure 2: Control structure vocabulary.\n\n\n\nThe header in a control structure is a keyword and ends in a colon. The if statement has two headers. Headers in the same control structure must be indented the same, as seen in Figure 2. A suite or block is a set of statements following a header. They must all be indented the same. The following code will generate an error.\nif temp_conversion_type == 'F-C':\n        converted_temp = (temp_to_convert - 32)*5.0/9.0\n    print(temp_to_convert,'[F] = ', converted_temp, '[C]')\nelse:\n    converted_temp = temp_to_convert*9.0/5.0 + 32.0\n    print(temp_to_convert,'[C] = ' , converted_temp, '[F]')   \nThe amount of indentation of a code block does not matter, although four spaces has become a convention for Python.\nMulti-way selection can be achieved by using nested if statements or by using the elif header. Nested if statements have the following structure.\n\n\n\nif condition:\n    statement block\nelse:\n    if condition:\n        statement block\n    else:\n        if condition:\n            statement block\n        else:\n            statement block\n\n\nFigure 3: Multi-way selection with nested if statements.\n\n\n\nThe same flow control is achieved more cleanly using the elif header shown in Figure 4.\n\n\n\nif condition:\n    statement block\nelif condition:\n    statement block\nelif condition:\n    statement block\nelse:\n    statement block\n\n\nFigure 4: Multi-way selection using the elif header.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#iterative-control-overview",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#iterative-control-overview",
    "title": "Control Structures",
    "section": "Iterative Control Overview",
    "text": "Iterative Control Overview\nIterative control structures allow a block of code to be repeated based on a condition that appears in the header for the structure. As Figure 3.1 suggests, an iterative control structure appears as a loop due to the repetitive nature of the flow. The first iterative control structure that we will introduce is the while loop, which repeatedly executes a code block based on a Boolean expression. The syntax for a while loop is\nwhile condition:\n    statement block\nThe condition must be a Boolean expression that evaluates to True or False. As long as the condition is true, the block of code will execute. When the condition becomes False, the flow control jumps to the first statement after the while loop. Here is a simple example of using the while loop to achieve iterative control:\nnum = 0\ncount = 1\nnumber_of_iterations = int(input('Enter the number of iterations:')\nwhile count &lt;= number_of_iterations:\n    num = num + 1\nAll iterative flow control can be achieved with the while loop, but if the number of iterations is known in advance, then another control structure can be used: the for loop. When this structure is used the loop is executed for each element of a given sequence. We will discuss Python sequence data types in the next chapter, but a commonly used example is provided by the range function.\nThe range function will produce a sequence of integers that can be used by a for loop. The syntax is\nrange(start, stop, step)\nwhere\nstart - An integer number specifying at which position to start the integer list. Default is 0. Optional\nstop - An integer number specifying at which number to stop. The sequence goes up to but not including this number. Required.\nstep - An integer number specifying the increment. Default is 1. Optional.\nExamples:\nrange(2,5)\ngenerates the sequence\n2,3,4\nrange(5)\ngenerates\n0,1,2,3,4\nrange(0,10,2)\ngenerates\n0,2,4,6,8\nThe syntax for a for loop is shown below.\nfor i in sequence:\n    statement block\nThe following example uses the range function to generate a sequence of integers that can be used in a for loop.\nfor i in range(1,6):\n    print('Index value is',i)\nThis for loop will produce the following output\nIndex value is 1\nIndex value is 2\nIndex value is 3\nIndex value is 4\nIndex value is 5",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#pseudocode",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#pseudocode",
    "title": "Control Structures",
    "section": "Pseudocode",
    "text": "Pseudocode\nThe Design phase of solving a computational problem can be challenging since it is where we must develop the actual algorithm for the solution. By recognizing the key logical structures of programming without concern with syntax details of a specific programming language we can often work through the basic logic of the solution. One method used by software engineers to construct an expression of this logic is writing pseudocode.\nPseudocode involves using plain language to write out the basic logic of the problem solution using structural conventions of programming languages but not being concerned with specific syntax details. Pseudocode provides a bridge between initial thoughts about a problem solution and an actual working code.\nStructural elements of programming languages that we want to recognize in our pseudocode version of the program include control structures and functions. We will use a particular style of writing the pseudocode that recognizes these structural elements.\nLet’s start with control structures. There three major kinds of program control: sequential, selection, and iterative. Sequential control involves executing a step and then moving on to the next step, one after the other. In our pseudocode we will always begin a step with a capital letter, as in the following:\n\n\nStep 1\nStep 2\nStep 3\n.\n.\n.    \nFigure 5: Sequential control in pseudocode.\n\nSelection control involves executing different blocks of code depending on the value of a Boolean conditional variable. This will involve using an if/else type of structure. Our pseudocode style for indicating a selection control block is to make the keywords IF and ELSE uppercase. We will also indicate the end of the IF/ELSE block with the keyword ENDIF.\n\n\nIF condition\n    Step 1\n    Step 2\nELSE\n    Step 1\n    Step 2\nENDIF  \nFigure 6: Selection control in pseudocode.\n\nIterative control involves setting up a loop, which can be done with the while structure or a for loop. Our pseudocode style will require making the appropriate keyword uppercase. The block will end with the keyword ENDWHILE. Here is how the while structure will be indicated:\n\n\nWHILE condition DO\n    Step 1\n    Step 2\nENDWHILE\nFigure 7: Iterative control in pseudocode. While loop.\n\nThe for loop will be written as\n\n\nFOR item IN list DO\n    Step 1\n    Step 2\nENDFOR\nFigure 8: Iterative control in pseudocode. For loop.\n\nWhen we use decomposition and abstraction to help solve a computational problem, we often write separate program units to take care of a particular step in the algorithm. In Python, these program units are typically functions. When writing pseudocode and we decide to make a step of the algorithm into a separate function then we will write a pseudocode version of the function as a separate program unit using the FUNCTION keyword. Important parts of writing the pseudocode for a function are to identify the required parameters passed to the function and the data that will be returned to the main program. We will use the following for the pseudocode style.\n\n\nFUNCTION function_name \n    INPUT:parameter1, parameter2\n    Step 1\n    Step 2\n    .\n    .\n    .\n    OUTPUT return_variable1, return_variable2\nENDFUNCTION\nFigure 9: Function definition in pseudocode.\n\nWe will indicate the main program in our pseudocode using the PROGRAM keyword.\n\n\nPROGRAM program_name\n    Step 1\n    Step 2\n    .\n    .\n    .\nENDPROGRAM\nFigure 10: Program unit in pseudocode.\n\nAs an example of developing a pseudocode version of an algorithm, let us consider the problem of cleaning up the yard of a residential property. We start with a high-level view of the algorithm.\n\n\nPROGRAM clean_up_the_yard\n    Inspect the yard for debris, excessive grass height, \\\n        unkempt hedges\n    IF there is debris\n        Pick up debris\n    ENDIF\n    IF there is excessive grass height\n        Mow the lawn\n    ENDIF\n    IF there are unkempt hedges\n        Trim the hedges\n    ENDIF\nENDPROGRAM\nFigure 11: Highlevel pseudocode version of the clean_up_the_yard algorithm.\n\nNow we will produce a more detailed version of the algorithm, as shown in Figure 12. Note that for each of the steps listed in the pseudocode of Figure 11 we add additional detailed steps.\n\n\nPROGRAM clean_up_the_yard\n    Inspect the yard for debris, excessive grass height, \\\n        unkempt hedges\n    IF there is debris\n        Determine the kind of debris\n        IF debris is mainly leaves\n            Get some 30 gallon yard bags\n            Rake up leaves\n            Put leaves in bags\n        ELSE\n            Get the wheelbarrow\n            WHILE debris remains DO\n                Fill up wheelbarrow\n                Empty wheelbarrow at wood pile\n            ENDWHILE \n        ENDIF\n    ENDIF\n    IF there is excessive grass height\n        Get the lawn mower\n        Check the gas \n        IF mower needs gas\n            Fill the gas tank\n        ENDIF\n        WHILE the lawn is not finished DO\n           Mow a lap\n        ENDWHILE  \n    ENDIF\n    IF there are unkempt hedges\n        Get the hedge clippers\n        Trim the hedges\n    ENDIF\nENDPROGRAM\nFigure 12: A more detailed version of the clean_up_the_yard algorithm.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#computational-problem-solution-temperature-conversion",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#computational-problem-solution-temperature-conversion",
    "title": "Control Structures",
    "section": "Computational Problem Solution: Temperature Conversion",
    "text": "Computational Problem Solution: Temperature Conversion\nWe return to the temperature conversion problem described at the beginning of this chapter. We will develop a program that solves this problem using programming elements developed in the chapter.\n\nAnalysis\nThe first step in problem analysis is to state the problem precisely and describe how to recognize a successful solution.\nProblem Statement: The program requests that the user submit a temperature including scale used and also requests to which scale the temperature should be converted. The Program should perform some error detection to ensure that the submitted temperature is not below absolute zero on the user chosen scale. The program will print out the converted temperature with appropriate label. Temperature scales that will be used are Celsius, Fahrenheit, and Kelvin. Temperatures should be formatted to show two digits right of the decimal point.\nPart of our analysis is to research physical principles that may be helpful in solving the problem. In this case, we can look up absolute zero for each of the scales being considered. These temperatures are shown in Table 4.\n\n\n\nTable 4: Absolute zero for the temperature scales considered.\n\n\n\n\n\nScale\nAbsolute Zero\n\n\n\n\nCelsius\n-273.15\n\n\nFahrenheit\n-459.67\n\n\nKelvin\n0\n\n\n\n\n\n\nWe continue our background research to find the equation for each of the required conversions. Equation 3 through Equation 8 show the required conversion equations.\n\\[\nT_C = T_K- 273.15\n\\tag{3}\\]\n\\[\nT_C = \\left(T_F- 32\\right) \\times \\frac{5}{9}\n\\tag{4}\\]\n\\[\nT_F = \\frac{9}{5} \\times T_C + 32\n\\tag{5}\\]\n\\[\nT_F = \\left(T_K- 273.15\\right) \\times \\frac{9}{5} + 32\n\\tag{6}\\]\n\\[\nT_K = T_C + 273.15\n\\tag{7}\\]\n\\[\nT_K = \\left(T_F- 32\\right) \\times \\frac{5}{9} + 273.15\n\\tag{8}\\]\nThese equations can be used to generate some test data that will be used to with our program. This allows us to recognize a program that works correctly. Table 5 shows relevant test data.\n\n\n\nTable 5: Test data for the temperature conversion program.\n\n\n\n\n\nSubmitted Temperature\n\nConverted Temperature\n\n\n\nT\nScale\nT\nScale\n\n\n-300\nC\nError\n\n\n\n-150\nC\n-238\nF\n\n\n-150\nC\n123.15\nK\n\n\n0\nC\n32\nF\n\n\n0\nC\n273.15\nK\n\n\n-500\nF\nError\n\n\n\n-400\nF\n-240\nC\n\n\n-400\nF\n33.15\nK\n\n\n0\nF\n-17.78\nC\n\n\n0\nF\n255.37\nK\n\n\n-100\nK\nError\n\n\n\n0\nK\n-273.15\nC\n\n\n0\nK\n-459.67\nF\n\n\n150\nK\n-123.15\nC\n\n\n150\nK\n-189.67\nF\n\n\n\n\n\n\n\n\nDesign\nThe solution design for our problem should include a description of the algorithm using pseudocode and a list of the required data structures (variable names and types) used in the code. Table 6 shows the required variables for implementing the algorithm for this problem solution. Typically, we would start this table as we begin to think about the algorithm and then add to it as the algorithm develops.\n\n\n\nTable 6: Required data structures for the algorithm.\n\n\n\n\n\n\n\n\n\n\nData Structure\nType\nDescription\n\n\n\n\nsubmission_is_incorrect\nBoolean variable\nspecifies whether submitted temperature is above absolute zero\n\n\nsubmitted_temperature\nfloat variable\ntemperature submitted by user\n\n\nsubmitted_scale\nstring variable\nscale for submitted_temperature\n\n\nconverted_temperature\nfloat variable\nthe converted temperature\n\n\nconverted_scale\nstring variable\nscale for converted_temperature\n\n\n\n\n\n\nPython uses a preferred style for creating variable names (Rossum et al., 2022). This style recommends that variable names (and function names) be all lower case with individual words in the name separated by an underscore. We should note that other programming languages use different style conventions and companies that use Python for software development will sometimes have a different style guide. We will use the PEP 8 recommended style in this book.\nAfter starting the list of required data structures (variable names, in this case), we write out a high-level pseudocode version of the algorithm, as shown in Figure 13.\n\n\nPROGRAM temperature_conversion\n    Print a program greeting\n    submission_is_incorrect = True\n    WHILE submission_is_incorrect DO\n        Request that the user submit a temperature to convert \n            (defines submitted_temperature)\n        Request that the user submit the scale of submitted \n          temperature (defines submitted_scale)\n        Check whether submitted_temperature is above absolute zero\n        IF submitted_temperature is above absolute zero \n            submission_is_incorrect = False\n        ENDIF\n    ENDWHILE\n    submission_is_incorrect = True\n    WHILE submission_is_incorrect DO\n        Request that the user submit a scale for the conversion \n         (defines convertedScale)\n        IF convertedScale is okay\n            submission_is_incorrect = False\n        ENDIF\n    ENDWHILE\n    Calculate converted_temperature\n    Print out converted_temperature\nENDPROGRAM\nPseudocode version of the problem solution algorithm.\n\nFigure 13\n\nNote that the while loops implement our error detection for submitted input.\n\n\nImplementation\nWe will now create a Python code implementation of each part. The program greeting and first while loop that checks for a correct temperature submission is shown in Figure 14 Note that the program code starts with a brief documentation comment, which includes a few key items such as the author, a version number, and a brief summary of what the program does. This is a good step towards providing documentation for the program. In addition to the iterative control structure (while loop), this section uses the mult-way selection structure (if elif).\n\n\n\"\"\"\nProgram Name: Temperature Scale Conversion\nAuthor: C.D. Wentworth\nversion: 6.23.2022.1\nSummary: Temperature Conversion Program with Input error checking of \n         temperatures. This version accepts a user-defined temperature in \n         Celsius, Fahrenheit, or Kelvin and converts the temperature \n         to a user selected scale.\n\"\"\"\n# Display program greeting\nprint('Welcome to the Temperature Scale Conversion Program!')\nprint('This program will request that the user submit a temperture.')\nprint('Next, it requests the converted scale.')\nprint('Finally, it prints out the converted temperature.')\nsubmission_is_incorrect = True\nscale_request = \"'C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin\"\nwhile submission_is_incorrect:\n    submitted_temperature = float(input('Submit a temperature to convert: '))\n    print('Specify the scale of your submitted temperature: ')\n    submitted_scale = input(scale_request)\n    if ((submitted_scale =='C') and (submitted_temperature&gt;=-273.15)):\n        submission_is_incorrect = False\n    elif ((submitted_scale == 'F') and (submitted_temperature&gt;=-459.67)):\n        submission_is_incorrect = False\n    elif ((submitted_scale == 'K') and (submitted_temperature&gt;=0)):\n        submission_is_incorrect = False\n    else:\n        print('Incorrect submitted temperature. Try again.')\n        \nFigure 14: Program greeting and temperature request.\n\nNext, we code the program part that requests that the user submit a temperature scale for the converted temperature. The while loop provides for some user input error detection.\n\n\nprint(&#39;What scale should be used for the converted temperature?&#39;)\nconverted_scale = input(scale_request)\nsubmission_is_incorrect = True\nwhile submission_is_incorrect:\n    if ((submitted_scale == &#39;C&#39;) and \n        (converted_scale == &#39;F&#39; or converted_scale == &#39;K&#39;)):\n        submission_is_incorrect = False\n    elif ((submitted_scale == &#39;F&#39;) and \n          (converted_scale == &#39;C&#39; or converted_scale == &#39;K&#39;)):\n        submission_is_incorrect = False\n    elif ((submitted_scale == &#39;K&#39;) and \n          (converted_scale == &#39;C&#39; or converted_scale == &#39;F&#39;)):\n        submission_is_incorrect = False\n    else:\n        print(&#39;There is a problem with your submission.&#39;)\n        converted_scale = input(scale_request) \nFigure 15: Converted temperature scale request.\n\nFinally, we code the actual temperature conversion calculation and print out the result.\n\n\nif submitted_scale == 'C':\n    if converted_scale == 'F':\n        # convert Celsius to Fahrenheit\n        converted_temperature = submitted_temperature*9.0/5.0 + 32.0\n    else:\n        # convert Celsius to Kelvin\n        converted_temperature = submitted_temperature + 273.15\nelif submitted_scale == 'F':\n    if converted_scale == 'C':\n        # convert Fahrenheit to Celsius\n        converted_temperature = (submitted_temperature - 32.0)*5./9.\n    else:\n        # convert Fahrenheit to Kelvin\n        converted_temperature = (submitted_temperature - 32.0)*5.0/9.0 + 273.15\nelse:\n    if converted_scale == 'C':\n        # convert Kelvin to Celsius\n        converted_temperature = submitted_temperature - 273.15\n    else:\n        # convert Kelvin to Fahrenheit\n        converted_temperature = (submitted_temperature - 273.15)*9.0/5.0 + 32.0\n# print out the result\ns1 = format(submitted_temperature,'.2f')\ns2 = format(converted_temperature,'.2f')\nprint(s1,submitted_scale,' is ', s2,converted_scale)\nFigure 16: Temperature calculation part.\n\n\n\nTesting\nTable 5 gives some test data to use with the program. We reproduce that table below Table 7 and add a column giving the actual program output. Since the output column matches the expected converted temperature column we have some evidence that the program runs correctly.\n\n\n\nTable 7: Test data with program output.\n\n\n\n\n\nSubmitted Temperature\n\nConverted Temperature\n\n\n\n\n\n\nT\nScale\nT\nScale\nProgram Output\n\n\n-300\nC\nError\n\nerror detected\n\n\n-150\nC\n-238\nF\n-238\n\n\n-150\nC\n123.15\nK\n123.15\n\n\n0\nC\n32\nF\n32\n\n\n0\nC\n273.15\nK\n273.15\n\n\n-500\nF\nError\n\nerror detected\n\n\n-400\nF\n-240\nC\n-240\n\n\n-400\nF\n33.15\nK\n33.15\n\n\n0\nF\n-17.78\nC\n-17.78\n\n\n0\nF\n255.37\nK\n255.37\n\n\n-100\nK\nError\n\nerror detected\n\n\n0\nK\n-273.15\nC\n-273.15\n\n\n0\nK\n-459.67\nF\n-459.67\n\n\n150\nK\n-123.15\nC\n-123.15\n\n\n150\nK\n-189.67\nF\n-189.67",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#ch03-exercises",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#ch03-exercises",
    "title": "Control Structures",
    "section": "Exercises",
    "text": "Exercises\n1. Describe the three kinds of program flow control.\n2. What is the value of each of the following Boolean expressions?\n\n10 &gt;= 20\n10 != 20\n(10 &gt;= 20) and (10 != 20)\n(10 &gt;= 20) or (10 != 20)\n‘Jim’&lt;‘Mike’\n12*2 == 8*3\n\n3. Correct the indentation in the following code block so that it will execute without an error.\n\n    score = 81\n    if score &gt;= 90:\n        print('Your score indicates outstanding work.')\n    elif score &gt;=80:\n        print('Your score indicates good work.')\n          print('You can resubmit your work.')\n    elif score &gt;=70:\n        print('Your work is adequate.')\n        print('Try to improve your score.')\n    else:\n        print('Your work needs improvement.')\n        print('Please try again.')\n\n4. Develop an algorithm, and pseudocode implementation of it, for the problem of cleaning an apartment with multiple bedrooms. Produce two versions: a high-level version with not many details, and then a more detailed version.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#ch03-program-modification-problems",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#ch03-program-modification-problems",
    "title": "Control Structures",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. In this exercise you are given a program (shown below) that obtains two integers from the user and then prints a message depending on whether the integers are both zero or not. You must change the code so that it tests whether both integers are zero, one is zero and one is non-zero, or both are non-zero and prints an appropriate message.\n[ language=Python , numbers=none , backgroundcolor=\\color{light-gray}]  \n\n    \"\"\"\n    Program Name: Chapter 3 Prog Mod Prob 1\n    Author: C.D. Wentworth\n    version: 6.23.2022.1\n    Summary: This program requests that the user\n             submit two integers and then\n             determines whether one is zero or\n             not and then prints a message.\n    \"\"\"\n    # Ask user for two integers\n    i1 = input('type in an integer ')\n    i1 = int(i1)\n    i2 = input('type in another integer ')\n    i2 = int(i2)\n    if i1 == 0 or i2 == 0:\n        print('One of the integers is zero')\n    else:\n        print('Neither integer is zero')\n\n2. Add the Rankine temperature scale to the available scales in the Temperature Scale Conversion Program. Remember to check that the temperature submitted by the user is greater than or equal to absolute zero.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch03/Ch03_ControlStructures.html#ch03-references",
    "href": "chapters/Ch03/Ch03_ControlStructures.html#ch03-references",
    "title": "Control Structures",
    "section": "References",
    "text": "References\n\nRossum, G. van, Warsaw, B., & Coghlan, N. (2022). PEP 8 – Style Guide for Python Code peps.python.org. https://peps.python.org/pep-0008/\nUnicode Consortium. (2021). Unicode. Unicode. https://home.unicode.org/\n\n\n\n\n\nRossum, G. van, Warsaw, B., & Coghlan, N. (2022). PEP 8 – Style Guide for Python Code | peps.python.org. https://peps.python.org/pep-0008/\n\n\nUnicode Consortium. (2021). Unicode. Unicode. https://home.unicode.org/",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Control Structures</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html",
    "href": "chapters/Ch04/Ch04_Lists.html",
    "title": "Lists",
    "section": "",
    "text": "Motivating Problem: Identifying Patterns in Global Surface Temperature Data\nClimate science generates large amounts of data, including temperature and solar irradiance at specific locations on the earth’s surface over many years and time series of greenhouse gas concentrations in the atmosphere. Identifying patterns in the data is one of the important challenges for climate scientists. In this chapter, we will develop some of the computational science skills that will help with this challenge.\nConsider one crucial climate observation: the average surface temperature of the earth. Table 1 shows some of the surface temperature data produced by the NASA Goddard Institute for Space Studies Surface Temperature Analysis group (GISTEMP Team, 2022a). The complete data set covers the years 1880-2021.\nIf you look at the entire 1800-2021 data table and try to identify patterns, you will likely be challenged, but a simple scatter graph of the annual mean quickly shows an interesting pattern, as seen in Figure 1.\nWith the help of concepts developed in this chapter, the problem we must solve is how to create a graph, as shown in Figure 4.1, using tables of numerical data such as that in Table 4.1. Solving this problem will require understanding the sequence data type, reading data from a text file, and the basic use of a plotting library. We will learn about the specific examples of sequences in Python, including lists and numpy arrays. We will briefly introduce the Matplotlib plotting library used extensively for Python-based scientific visualizations.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#motivating-problem-identifying-patterns-in-global-surface-temperature-data",
    "href": "chapters/Ch04/Ch04_Lists.html#motivating-problem-identifying-patterns-in-global-surface-temperature-data",
    "title": "Lists",
    "section": "",
    "text": "Table 1: GLOBAL Land-Ocean Temperature Index. The numbers are the surface temperature anomaly multiplied by 100 degrees Celsius using 1951-1980 as the base period. The full dataset goes through 2022.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYear\nJan\nFeb\nMar\nApr\nMay\nJun\nJul\nAug\nSep\nOct\nNov\nDec\nAnn J-D\nAnn D-N\nDJF\nMAM\nJJA\nSON\nYear\n\n\n\n\n1880\n-18\n-24\n-9\n-16\n-10\n-21\n-18\n-10\n-14\n-24\n-22\n-18\n-17\n***\n****\n-12\n-16\n-20\n1880\n\n\n1881\n-20\n-14\n3\n5\n6\n-19\n0\n-3\n-15\n-22\n-18\n-7\n-9\n-10\n-17\n5\n-7\n-18\n1881\n\n\n1882\n16\n14\n4\n-16\n-14\n-22\n-16\n-8\n-15\n-23\n-17\n-36\n-11\n-9\n8\n-8\n-15\n-18\n1882\n\n\n1883\n-29\n-37\n-12\n-19\n-18\n-7\n-7\n-14\n-22\n-11\n-24\n-11\n-18\n-20\n-34\n-16\n-9\n-19\n1883\n\n\n1884\n-13\n-8\n-36\n-40\n-33\n-35\n-33\n-28\n-27\n-25\n-33\n-31\n-28\n-27\n-11\n-37\n-32\n-28\n1884\n\n\n1885\n-58\n-33\n-26\n-42\n-45\n-43\n-33\n-31\n-29\n-23\n-24\n-10\n-33\n-35\n-41\n-38\n-36\n-25\n1885\n\n\n1886\n-44\n-51\n-43\n-28\n-24\n-35\n-18\n-31\n-24\n-28\n-27\n-25\n-31\n-30\n-35\n-32\n-28\n-26\n1886\n\n\n1887\n-72\n-57\n-35\n-35\n-30\n-25\n-26\n-35\n-26\n-35\n-26\n-33\n-36\n-36\n-51\n-33\n-29\n-29\n1887\n\n\n1888\n-34\n-36\n-41\n-20\n-22\n-17\n-10\n-16\n-12\n2\n3\n-4\n-17\n-20\n-34\n-28\n-14\n-2\n1888\n\n\n1889\n-9\n17\n6\n10\n-1\n-10\n-8\n-20\n-24\n-25\n-33\n-29\n-10\n-8\n1\n5\n-13\n-27\n1889\n\n\n1890\n-42\n-44\n-40\n-30\n-39\n-24\n-28\n-39\n-36\n-25\n-43\n-31\n-35\n-35\n-38\n-36\n-30\n-35\n1890\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Global mean temperature anomaly (GISTEMP Team, 2022b).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#general-properties-of-lists",
    "href": "chapters/Ch04/Ch04_Lists.html#general-properties-of-lists",
    "title": "Lists",
    "section": "General Properties of Lists",
    "text": "General Properties of Lists\nLists are found frequently in everyday life: grocery lists, to-do lists, and life goals for the year. Science and engineering work also requires the use of lists. The yearly global surface temperature data introduced in Table 1 can be represented as a list. Work in genetics often requires knowing the sequence of nucleotides in a molecule of DNA, and such a sequence can be thought of as a list.\nWork with lists computationally will be expedited by having an appropriate data structure representing the list structure. Python uses several such data structures. We will discuss these structures by first introducing the sequence idea, which can be considered a general definition of a list. A sequence is a linearly ordered set of values, each of which can be accessed using an index number. Table 2 gives an example of a sequence. The first value, -33, is indexed by 0 since Python uses a zero-based indexing method. Some programming languages would start indexing with the numeral 1, but not Python. This is a crucial point to keep in mind as you work with sequence data structures in Python.\n\n\n\nTable 2: Example of a sequence.\n\n\n\n\n\nindex\nValue\n\n\n\n\n0\n-33\n\n\n1\n-12\n\n\n2\n4\n\n\n3\n-37\n\n\n4\n-19\n\n\n\n\n\n\nSeveral operations can be performed on most sequence data structures. These operations include retrieving, updating, inserting, removing, and appending an element in the sequence. Figure 2 illustrates the retrieve operation. The original sequence remains unchanged.\n\n\n\n\n\n\nFigure 2: Retrieve sequence operation.\n\n\n\nUpdating a sequence value changes the value stored at a particular location. The original value is lost, and the sequence keeps the same length. Figure 3 illustrates this operation.\n\n\n\n\n\n\nFigure 3: Update sequence operation.\n\n\n\nThe insert operation places a new value at a particular position specified by the index but shifts all other values down. No values are lost, but the sequence increases in length. Figure 4 illustrates this effect.\n\n\n\n\n\n\nFigure 4: Insert sequence operation.\n\n\n\nThe remove operation takes out the value at a specific index and then shifts all the following up in the sequence, as shown in Figure 5.\n\n\n\n\n\n\nFigure 5: Remove sequence operation.\n\n\n\nThe append operation attaches a new value to the end of the sequence, as shown in Figure 6.\n\n\n\n\n\n\nFigure 6: Append sequence operation.\n\n\n\nSequences can be categorized as mutable, meaning that they can be changed, or immutable, meaning that the sequence cannot be changed after being defined. An immutable sequence can only have the retrieve operation applied to it. The built-in Python sequence data types include Python lists, tuples, and strings.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#python-lists",
    "href": "chapters/Ch04/Ch04_Lists.html#python-lists",
    "title": "Lists",
    "section": "Python Lists",
    "text": "Python Lists\nPython features a built-in sequence data structure called a list. A Python list is a mutable sequence, and the elements can have mixed data types. A Python list does not need to be all floats or all strings. It can contain a combination of floats, strings, and any other valid Python data type, including a Python list. A Python list is denoted using square brackets with elements separated by commas. Here are some examples of Python lists:\n[50.5, 12.4, 72.5]     [2, 4, 'two', 'four']\nAn empty list is indicated using an empty pair of square brackets:\n[]\nA Python variable name can be assigned to a list to facilitate working with it.\nlist_example = [10, 20, 30, 40]\nThe syntax for accessing individual elements of a list (and other sequence types) is to use the index operator [] (not the same as the empty list) with an expression representing an index number inside the brackets.\n\nRemember that Python uses zero-based indexing, so the first element of a sequence is referenced with 0. Negative index values reference elements from the right or bottom of the list rather than from the beginning.\n\nTable 3 illustrates how to perform sequence operations on a Python list.\n\n\n\nTable 3: Python list operations. list_example = [10, 20, 30, 40]\n\n\n\n\n\nOperation\nExample\nResult\n\n\n\n\nretrieving\nlist_example[2]\n30\n\n\nupdating\nlist_example[1] = 50\n[10, 50, 30, 40]\n\n\ninserting\nlist_example.insert(2,50)\n[10, 20, 50, 30, 40]\n\n\nremoving\ndel list_example[1]\n[10,30,40]\n\n\nappending\nlist_example.append(50)\n[10, 20, 30, 40, 50]\n\n\n\n\n\n\nThe dot notation used in the list insert and list append operations is an example of object-oriented programming and will be explained more fully in Chapter 11. For now, think of the name to the right of the dot, called a method in object-oriented programming, as a function that applies to the object to the left of the dot.\nThe slice operation allows us to extract multiple list elements with one simple expression. The general form is a variation of the bracket notation, [m:n], which returns elements starting with the one indexed by m and extending up to, but not including, the element indexed by n. The second through the third elements of list_example could be extracted with list_example[1:3]. If the first index number, m, is omitted, then the slice begins with the first element of the list. If the last index number, n, is omitted, then the slice includes all elements through the last one. Figure 7 illustrates the use of the slice operation.\n\n\n\n\n\n\nFigure 7: Examples of the slicing operation.\n\n\n\nOne more common operation frequently performed on a sequence, including Python lists, is traversal. Traversing a sequence involves accessing each element in order. A simple way to do this is with a for loop. For example, printing out each element of a list on a separate line we can be done as follows:\nfor e in list_example:\n    print(e)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#python-tuples",
    "href": "chapters/Ch04/Ch04_Lists.html#python-tuples",
    "title": "Lists",
    "section": "Python tuples",
    "text": "Python tuples\nA tuple is an immutable Python sequence data type. Tuples are defined using parentheses ().\n(10, 20, 30)    ('apple' , 'banana' , 'cherry')\nTo avoid ambiguity, a tuple with a single element must contain the final comma.\ntuple_example = (10,)\nIn this example, if tuple_example did not contain the final comma, then the Python interpreter would assume it is an integer. This is shown in the Colab notebook segment below.\n\nThe index syntax applies to tuples, just as it did for lists.\n\nRemember that a tuple is immutable, meaning it cannot be changed after it is defined. Attempting to change a tuple element will result in an error, as shown in the notebook output below.\n\n\n\n\n\n\nFigure 8: Error resulting from an attempt to assign to a tuple.\n\n\n\nPython strings are an immutable sequence type, similar to tuples in behavior. The characters in a string are sequence elements, so they can be accessed using the bracket syntax.\n\nBeing immutable, any attempt to reassign a character in a string will result in an error.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#numpy-arrays",
    "href": "chapters/Ch04/Ch04_Lists.html#numpy-arrays",
    "title": "Lists",
    "section": "NumPy Arrays",
    "text": "NumPy Arrays\nThe NumPy library is a crucial building block for developing Python applications for scientific and engineering computing (Numpy, 2022). This library introduces an enhanced data structure for representing multidimensional arrays, methods of operating on these arrays, and many functions that can manipulate or extract information from these arrays. The NumPy library will be used in much of the code developed in the remainder of this book. Figure 9 illustrates the structure of arrays. A one-dimensional array is a type of sequence that behaves similarly to vectors in linear algebra. Two-dimensional arrays can be considered as matrices, and higher-dimensional arrays can be considered tensors, as understood in certain areas of mathematics, such as differential geometry, engineering, and physics.\n\n\n\n\n\n\nFigure 9: Structure of 1, 2, and 3-dimensional arrays.\n\n\n\nThe array data structure or array object introduced by NumPy is called a ndarray, which stands for an n-dimensional array. The elements of a ndarray must all be of the same data type, called the dtype, such as integer or float. Two significant properties are associated with a specific ndarray: the array elements shape and the data type (dtype). The shape of a ndarray is a tuple that specifies the size of the array along each dimension.\nWe will start with one-dimensional arrays to develop our understanding of NumPy arrays and operations on them. One way to create a NumPy array is to use the array routine in NumPy.\nimport numpy as np\na = np.array([10., 20., 30, 40.], dtype='float64')\nBefore using NumPy arrays and operations on them, we must first import the NumPy package. Renaming the package ‘np,’ while unnecessary, has become traditional in data science applications. The first argument of the array routine is a Python list. The second argument specifies the data type of the elements in the array. The shape and data type of a NumPy array can be obtained as follows.\n\nNote that the shape is given as a tuple and shows that a is a one-dimensional array with four elements. The individual values in a NumPy array can be retrieved using the square bracket notation.\n\nNow let us move on to a two-dimensional NumPy array.\n\nThe shape of a2d indicates that there are two dimensions. The first value in the shape tuple gives the number of rows, and the second value gives the number of columns. We can retrieve the value of individual elements in the array using square bracket notation. For example, the element in the second row and fourth column can be accessed as follows.\n\nThe first index number gives the row, and the second index number provides the column. Recall that Python uses a zero-based indexing system.\nOne advantage of using NumPy arrays instead of Python lists is that numerical calculations can be coded more succinctly. Suppose we have an array of numbers, and we need to add a constant value to each array member. This can be done with one line of code if the array is represented in a NumPy array.\na1d = np.array({[}10., 20., 30.{]})\nb1d = a1d + 5.0\nIf a1d were a Python list, then the arithmetic expression would yield an error. We would need to set up a loop to add the constant to each element explicitly.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#basic-input-and-output-with-files",
    "href": "chapters/Ch04/Ch04_Lists.html#basic-input-and-output-with-files",
    "title": "Lists",
    "section": "Basic Input and Output with Files",
    "text": "Basic Input and Output with Files\nA basic operation that any data-oriented computational scientist must perform is reading columns of numerical data from a file into a program for processing and then writing out columns of numerical data to a file for use at a later time. In this section, we will learn about one method of performing these operations that uses a function in the NumPy module, one that will take care of many of the tedious processes that arise in performing reading and writing numerical data.\nLet’s work with a specific example. The file GLB.Ts+dSST.txt is a plain text file that contains the global mean temperature anomaly data compiled by NASA’s Goddard Institute for Space Studies Surface Temperature Analysis project, shown in Table 1. Figure 10 shows a screenshot of this file viewed with a plain text editor. We see that the file has eight lines of comments that describe the dataset, one line that specifies column headings, and then 20 columns of numbers. Spaces separate the numbers in each row, so we call this space-delimited data.\n\n\n\n\n\n\nFigure 10: Screenshot of the text file containing NASA temperature.\n\n\n\nThe NumPy package provides a function for importing numerical data from a text or CSV file as long as the data is in the form of columns of numbers. Since this is a common situation in scientific and engineering applications, we will use this technique here. The NumPy function we will use is loadtxt. While loadtxt can skip rows of non-numerical data at the beginning of the file, only numerical data must be present in the imported columns. The file shown in Figure 10 has missing numbers, indicated by ***, and the presence of these characters will cause an error. To use loadtxt, we must do some initial cleanup of the data file. One way to accomplish this cleanup is to open the file in a plain text editor and delete the rows that have missing numbers. The revised file is called GLB.Ts+dSST_clean.txt. Keeping the original file unchanged is a good practice in case problems arise in the data processing workflow.\nThe code that will read in the data and separate the year column and the annual mean temperature anomaly column is shown below.\n\n\n\nimport numpy as np\n\n# Read in data and extract columns\ncols = np.loadtxt('GLB.Ts+dSST_clean.txt', skiprows=9)\nyear = cols[:, 0]\nannual_temp_anomaly = cols[:, 13]\n\n# Calculate the actual annual temperature anomaly\nannual_temp_anomaly = annual_temp_anomaly/100.\n\n\nFigure 11: Code for reading in columns of numerical data.\n\n\n\nIf you are using Google Colab notebooks as your development environment, you will need to upload the data file to your Google Drive. You will then need to mount the Google Drive and change the working directory to wherever you placed your file, typically in the same folder as the Colab notebook file. This can be accomplished by adding the following code at the beginning of the Colab notebook.\nfrom google.colab import drive\ndrive.mount('/content/drive')\n%cd /content/drive/MyDrive/yourWorkingDirectory\nYou should replace ‘yourWorkingDirectory’ with the path to the folder where your data file is located on your Google Drive.\nThe function savetxt from the NumPy module can be used to write columns of numerical data to a text file. The first argument gives the file name to which data is written. The second argument provides the 2d numpy array containing the data columns. A delimiter can be specified with the delimiter keyword. Figure 4.13 shows the output file. By default, the format of the numbers will be scientific notation with the full precision for floats. The following code snippet, Figure 12, shows how to construct a 2d NumPy array from columns of data and then write out the data to a text file, a portion of which is shown in Figure 13.\n\n\n\n# Create 2d array from year and temperature 1d arrays\noutArray = np.column_stack((year, annual_temp_anomaly))\n\n# Save to text file\nnp.savetxt('annual_temp_anomaly.txt', outArray, delimiter='\\t')\n\n\nFigure 12: Code for saving columns of numerical data to a text file.\n\n\n\n\n\n\n\n\n\nFigure 13: Part of the text output using the savetxt function.\n\n\n\nWe can specify the format for the numbers written out using the fmt parameter. This parameter is a string with the following form:\n%[flag]width[.precision]specifier\nwhere each part is described below:\n\nflags (optional):\n- : left justify\n+ : Forces to precede result with + or -.\n0 : Left pad the number with zeros instead of space (see width).\nwidth: The minimum number of characters to be printed. The value is not truncated if it has more characters.\nprecision (optional):\nFor integer specifiers (e.g., d, i,o,x), the minimum number of\ndigits.\n\nFor e, E, and f specifiers, the number of digits to print after\nthe decimal point.\n\nFor g and G, the maximum number of significant digits.\n\nFor s, the maximum number of characters.\nspecifiers:\nc: character\n\nd or i: a signed decimal integer\n\ne or E: scientific notation with e or E.\n\nf: decimal floating point\n\ng, G: use the shorter of e, E or f\n\no: signed octal\n\ns: a string of characters\n\nu: an unsigned decimal integer\n\nx, X: unsigned hexadecimal integer\n\nThe fmt parameter can be a single format specifier, which will be applied to all the columns of numbers, or it can be a list of format specifiers, one for each column. Since the first column of the output is supposed to be a year, it would be more natural to format that number as an integer. This can be accomplished with the following statement.\n# Save to text file\nheader_string = 'year\\t temp anomaly'\nnp.savetxt('annual_temp_anomaly.txt', outArray, fmt=['%6i','%10.2e'], \n           delimiter='\\t', header=header_string)\nA header that gives column labels is provided with the header keyword argument. A portion of the output file is shown in Figure 14.\n\n\n\n\n\n\nFigure 14: A portion of savetxt output with formatted numbers.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#introduction-to-scientific-visualization-with-matplotlib",
    "href": "chapters/Ch04/Ch04_Lists.html#introduction-to-scientific-visualization-with-matplotlib",
    "title": "Lists",
    "section": "Introduction to Scientific Visualization with Matplotlib",
    "text": "Introduction to Scientific Visualization with Matplotlib\nWe are ready to create our first scientific visualization: a two-dimensional scatter graph showing the relationship between the mean global temperature anomaly and year. There are several standard plotting packages available in Python, but we will focus on Matplotlib since it is widely used and forms the basis for other visualization packages (The Matplotlib Development team, 2021) . We will discuss scientific visualizations in greater detail in Chapter 5. Here, we want to touch on the basics of using the Matplotlib package to create a 2d scatter graph.\nLet us assume that the mean global surface temperature anomaly values and corresponding year are in the data file annual_temp_anomaly.txt. The following code produces a simple scatter graph of this data.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Read in data\ncols = np.loadtxt('annual_temp_anomaly.txt',skiprows=1)\nyear_data = cols[:,0]\ntemp_anomaly_data = cols[:,1]\n\n# Plot data\nplt.plot(year_data, temp_anomaly_data, linestyle='', marker='d', markersize=5.0)\nplt.xlabel('year')\nplt.ylabel('Temperature Anomaly')\nplt.savefig('tempAnomalyVsYear.png', dpi=300)\nplt.show()\nThe pyplot sub-package of the Matplotlib package is imported and renamed plt. This is traditional in data science applications. The entire Matplotlib package is not needed to create most of the plots we use. The plot is created with the Matplotlib plot function. The first argument is the 1d array containing the x-axis values. The second argument is the 1d array with the y-axis values. The other keyword arguments are set, so only data points are graphed with a diamond data marker. The markersize is always adjusted to achieve a good visualization. Axis labels are added with the xlabel and ylabel functions.\nFinally, the plot is saved as a graphics file with the savefig function. The graphics file format is determined from the extension on the chosen file name, given as the first argument. The dpi keyword sets the resolution. The show function is not needed if the code is executed in a Jupyter notebook but will be required if it is executed in other programming environments. The plot is shown in Figure 15.\n\n\n\n\n\n\nFigure 15: Temperature anomaly as a function of year produced by Matplotlib.\n\n\n\nWe will discuss additional methods of customizing plots in later chapters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#computational-problem-solution-identifying-patterns-in-global-surface-temperature-data",
    "href": "chapters/Ch04/Ch04_Lists.html#computational-problem-solution-identifying-patterns-in-global-surface-temperature-data",
    "title": "Lists",
    "section": "Computational Problem Solution: Identifying Patterns in Global Surface Temperature Data",
    "text": "Computational Problem Solution: Identifying Patterns in Global Surface Temperature Data\nWe will now return to the problem introduced at the beginning of the chapter: how to use data visualization to help identify temperature anomaly trends over time.\n\nAnalysis\nWe start with a precise description of the problem and some features of the solution that will allow us to recognize a successful solution. The problem is to start with the data file given by NASA, GLB.Ts+dSST.txt (GISTEMP Team, 2022b), and produce a graph, similar to Figure 4.1, that performs some kind of smoothing of the widely fluctuating temperature anomaly values. We can recognize a solution when the graph has a smoothing curve displayed that shows fewer yearly fluctuations compared to the annual raw data.\nSome quite sophisticated statistical methods exist for smoothing random fluctuating time series data, including the LOWESS smoothing shown in Figure 1. Using such techniques requires considerably more mathematical sophistication than we want to use here. Therefore, we will use a simple moving average method that is conceptually simple and relatively easy to implement computationally.\nConsider a subset of the annual mean temperature anomaly data from Figure 14, shown in Table 4.\n\n\n\nTable 4: A subset of temperature anomaly data.\n\n\n\n\n\nyear\ntemperature anomaly [C]\n\n\n\n\n1883\n-0.18\n\n\n1884\n-0.28\n\n\n1885\n-0.33\n\n\n1886\n-0.31\n\n\n1887\n-0.36\n\n\n\n\n\n\nThe 5-year moving average for the 1885 temperature anomaly is calculated from\n\\[T_m\\left(1885\\right) = \\frac{\\left(- 0.18- 0.28- 0.33- 0.31- 0.36\\right)}{5.0}\\left[\\text{C}\\right] = - 0.29\\left[\\text{C}\\right] \\tag{1}\\]\nWe would replace the 1885 temperature anomaly in the data set with this new value. The moving average for each year is calculated similarly. We move the 5-year window, two years before the chosen year, two years after the selected year, plus the chosen year, to each year in turn. If \\(T\\left(y\\right)\\) represents the mean temperature anomaly for year y, then the general formula for the 5-year moving average is\n\\[T_m\\left(y\\right) = \\frac{T\\left(y- 2\\right) + T\\left(y- 1\\right) + T\\left(y\\right) + T\\left(y + 1\\right) + T\\left(y + 2\\right)}{5} \\tag{2}\\]\nWe could try different window sizes, 7-year, 9-year, and so on, to find one that clarifies a trend, but we will stick with the 5-year window for this solution.\n\n\nDesign\nThe workflow for our problem solution is\n\nClean up the raw NASA data file GLB.Ts+dSST.txt so that it does not contain non-numerical data, except for the header comments.\nNote the first year for which a 5-year moving average can be calculated (defines first_year).\nNote the last year for which a 5-year moving average can be calculated (defines last_year).\nWrite code to import the year and annual mean columns from the clean data file.\nConvert the annual mean column numbers to Celsius by dividing them by 100.\nWrite code that can calculate the 5-year moving average temperature anomaly for a general specified year, named current_year.\n\nStep 1 is performed with a basic text editor application, and we assume that the cleaned-up data file is GLB.Ts+dSST_clean.txt.\nFor the NASA data set we are using here, the first year for which a 5-year moving average can be calculated is 1883, and the last year is 2019.\nSteps 4 and 5 were discussed in section 4.5. These steps define the year_data and annual_temp_anomaly arrays.\nStep 6 requires some thought. Assume that year_index is the index number giving the year currently being considered. To expedite using the Matplotlib plot function, we will also define two new 1d NumPy arrays: moving_year_data will contain all the years for which we calculate a moving average, and moving_annual_temp_anomaly will contain the corresponding calculated moving averages. A pseudocode snippet of this process is shown below.\n\nExtract the subset of temperature anomalies from annual_temp_anomaly \n  (this defines anomaly_subset)\nCalculate the mean of the numbers in anomaly_subset (defines \n   temp_anomaly_mean)\nAdd the temp_anomaly_mean to moving_annual_temp_anomaly\n\nAll of the variables required for the problem solution are listed in Table 5.\n\n\n\nTable 5: List of data structures required for the problem solution.\n\n\n\n\n\n\n\n\n\n\nData Structure\nType\nDescription\n\n\n\n\nfirst_year\nfloat variable\nfirst year for the 5-year moving average calculation\n\n\nlast_year\nfloat variable\nlast year for the 5-year moving average calculation\n\n\nyear_data\n1-d numpy array\ncontains the column of year values in the NASA data set\n\n\nannual_temp_anomaly\n1-d numpy array\ncontains the column of annual temperature anomaly values in the NASA data set\n\n\nyear_index\ninteger variable\nspecifies the year currently being calculated\n\n\nanomaly_subset\n1-d numpy array\ncontains the five temperature anomalies that will be averaged\n\n\nmoving_year_data\n1-d numpy array\ncontains the year values for which a moving average is calculated\n\n\nmoving_annual_temp_anomaly\n1-d numpy array\ncontains the moving average value for each year in moving_year_data\n\n\n\n\n\n\n\n\nImplementation\nWe can collect together pieces of code from sections 4.5 and 4.6 to create code for our problem solution. Since NumPy arrays do not allow for the append operation, as can be done with a Python list, we must create new NumPy arrays with the correct length before using them. An empty array is created using the NumPy empty function, as shown below in lines 29 and 30.\nThe subset of the temperature anomaly values to be averaged is obtained from an array slicing operation in line 36. The average of the subset values is obtained using the NumPy mean function in line 37.\n\"\"\"\nTitle: 5-year Moving Average Plot\nAuthor: C.D. Wentworth\nVersion: 6.29.2022.1\nSummary: This program will read in annual temperature anomaly data \n         provided by NASA, calculate a 5-year\n         moving average, then plot both the raw data and moving average.\nRevision History:\n    6.29.2022.1: base\n\n\"\"\"\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncols = np.loadtxt('GLB.Ts+dSST_clean.txt', skiprows=9)\nyear_data = cols[:, 0]\nannual_temp_anomaly = cols[:, 13]\n\n# Calculate the actual annual temperature anomaly\nannual_temp_anomaly = annual_temp_anomaly/100.\n\n# Define the year range\nfirst_year = 1883.\nlast_year = 2019.\nfirst_year_index = np.where(year_data == first_year)[0][0]\nlast_year_index = np.where(year_data == last_year)[0][0]\n\n# Create empty numpy arrays for plot\nmoving_year_data = np.empty(len(year_data)-4)\nmoving_annual_temp_anomaly = np.empty(len(moving_year_data))\n\n# Calculate the moving average\nmoving_year_index = 0\nfor year_index in range(first_year_index, last_year_index + 1):\n    # obtain temperature anomaly subset\n    anomaly_subset = annual_temp_anomaly[year_index - 2:year_index + 2]\n    temp_anomaly_mean = np.mean(anomaly_subset)\n    moving_year_data[moving_year_index] = year_data[year_index]\n    moving_annual_temp_anomaly[moving_year_index] = temp_anomaly_mean\n    moving_year_index = moving_year_index + 1\nThe code block that creates the plot is shown below. The linestyle keyword argument is used to choose whether a line is solid, dotted, or dashed. The empty string, , indicates no line is drawn, which is often used when plotting data points. The linestyle value - indicates a solid line. The label keyword argument specifies a string that is used when a legend is shown. The legend is produced with default placement by\nplt.legend()\nWe will discuss keyword arguments used in the plot function in greater detail in the next chapter. Generally, a review of examples from the Matplotlib documentation or tutorials can help figure out good choices for the keyword argument values (The Matplotlib Development Team, 2022) .\n# plot the raw data and moving average\nplt.plot(year_data, annual_temp_anomaly, linestyle='', marker='d',\n         markersize=5.0, label='Annual Mean')\nplt.plot(moving_year_data, moving_annual_temp_anomaly, linestyle='-',\n         linewidth=2, label='5 year Moving Average')\nplt.xlabel('year')\nplt.ylabel('Temperature Anomaly')\nplt.legend()\nplt.savefig('tempAnomalyVsYearMovingAvg.png', dpi=300)\nplt.show()\nThe complete listing is contained in the chapter program file 5_year_moving_average_plot.py.\n\n\nTesting\nWhen the 5-year Moving Average Plot program is executed, we get the graph shown in Figure 16. This plot does resemble the one produced by NASA scientists, shown in Figure 1. This provides evidence that the problem solution is correct. The five year moving average line shows more fluctuations than the LOWESS smoothing line in Figure 1. This is likely due to the five year moving window being smaller than that used in the LOWESS smoothing algorithm. It would be interesting to compare a seven year moving average with the five year moving average.\n\n\n\n\n\n\nFigure 16: Plot output from the 5-year Moving Average Plot program.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#exercises",
    "href": "chapters/Ch04/Ch04_Lists.html#exercises",
    "title": "Lists",
    "section": "Exercises",
    "text": "Exercises\n1. (Fill-in-the-blank): A sequence is a ________ ordered set of values, each of which can be accessed using an _____ number\n\nWhich of the following Python data structures are mutable? Choose all that apply.\n\n\nlists\nstrings\ntuples\nNumPy arrays\n\n3. What is the resulting list when the value at index three is removed?\n\n\n\nindex\nvalue\n\n\n\n\n0\n25\n\n\n1\n15\n\n\n2\n-5\n\n\n3\n50\n\n\n4\n75\n\n\n\n\n\n\n\n\n\n\na.\n\n\n\nindex\nvalue\n\n\n\n\n0\n25\n\n\n1\n15\n\n\n2\n-5\n\n\n3\n0\n\n\n4\n75\n\n\n\nb.\n\n\n\nindex\nvalue\n\n\n\n\n0\n25\n\n\n1\n15\n\n\n2\n-5\n\n\n\n\n\nc.\n\n\n\nindex\nvalue\n\n\n\n\n0\n25\n\n\n1\n15\n\n\n2\n-5\n\n\n4\n75\n\n\n\nd.\n\n\n\nindex\nvalue\n\n\n\n\n0\n25\n\n\n1\n15\n\n\n2\n-5\n\n\n3\n0\n\n\n4\n0\n\n\n\n\n\n\n4. What are the index values for a tuple with 4 elements?\n\n0-4\n0-3\n1-4\n\n5. How would you define a tuple with the one element 12?\n\n[12]\n[12,]\n\n\n\n(12,)\n\n6. What would be the list resulting from the [1:3] slice in\n[80, 70, 75, 50, 65]\n\n[80, 70, 75]\n[70, 75, 50]\n[70, 75]\n\n7. Select all true statements about Python sequence data types.\n\nAll items in a Python list must be the same data type (all integers, all strings, etc.).\nAn attempt to assign a new value to a tuple element will result in an error.\nPython lists, tuples, and strings all use zero-based indexing.\n\n\nWrite a Python expression that prints out the third element of list1 defined below.\n\nlist1 = [125, -75, 25, 50, 15]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#program-modification-problems",
    "href": "chapters/Ch04/Ch04_Lists.html#program-modification-problems",
    "title": "Lists",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. In this exercise, you are given a program, shown below, that generates a list of random numbers and then counts the number of odd numbers in the list. You need to modify the program so that it creates two lists of random numbers, adds up the odd numbers in one list, adds up the even numbers in the second list, and then adds the two sums together.\n\"\"\"\nProgram: Count Odds\nAuthor: C.D. Wentworth\nVersion: 2.5.2020.1\nSummary: This program creates a list of random numbers and\n         counts how many odd numbers are in the list.\n         \n\"\"\"\nimport random as rn\n\n# make a list of random numbers\nlst = []\nfor i in range(10):\n    lst.append(rn.randint(0, 1000))\n\n# count the number of odd numbers in the list\nodd = 0\nfor e in lst:\n   if e % 2 != 0:\n       odd = odd + 1\nprint('The number of odd numbers in the list is: ',odd)\n    \n2. The program below will create a tan(t) graph. Modify it to create a plot of the following function\n\\[f\\left(t\\right) = 5.0 \\ast \\sin \\left(t\\right)\\]\nfor \\(- 3.14 \\leq t \\leq 3.14\\).\nThe plot should have\n\na dashed red line with a thickness of 5.\nThe x-axis title should be ‘t.’\nThe y-axis title should be ‘f(t).’\nThe y-axis scale should be adjusted to \\(- 6 \\leq t \\leq 6\\)\nThe chart title should be ‘5*sin(t) versus t’. The font size should be 20. The font color should be green.\n\n\"\"\"\nProgram: Plot Function\nAuthor: \nVersion: 1.25.2020.1\nSummary: This script creates a basic plot of a function with\n         user chosen features including the line style and \n         line width.\n\n\"\"\"\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nx = np.linspace(-3,3,100)\ny = np.tan(x)\nplt.plot(x,y,color='g',linestyle='-',linewidth=4)\nplt.xlabel('x',fontsize=16)\nplt.ylabel('y',fontsize=16)\nplt.title('tan(x) vs x',fontsize=24, color='red')\nplt.grid(True)\nplt.axis(ymin=-10,ymax=10)\nplt.show()    \n3. Write a program that creates a plot of \\(\\cos \\left(t\\right)\\) and \\(\\sin \\left(t\\right)\\) for \\(0 \\leq t \\leq 2\\pi\\) with both plots on the same graph. You can start with the Chapter 4 Program Modification Problem 2 code. Your final graph should\n\nshow sin as a solid red curve\nshow cos as a solid blue curve\nhave a legend\nshow the title ‘Comparison of cos and sin’ in green.\nuse \\(- 1.5 \\leq y \\leq 1.5\\) for the y-axis scale",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#ch04-program-development-problems",
    "href": "chapters/Ch04/Ch04_Lists.html#ch04-program-development-problems",
    "title": "Lists",
    "section": "Program Development Problems",
    "text": "Program Development Problems\n1. Write a program that will create a moving average plot of the NASA global temperature anomaly data for a user specified moving average window. The user will specify a window size that should be an odd number of years. The program should calculate the required moving average for as many years in the data as possible and then create a plot of the annual data, shown with data symbols, and the moving average, shown as a solid line.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch04/Ch04_Lists.html#ch04-references",
    "href": "chapters/Ch04/Ch04_Lists.html#ch04-references",
    "title": "Lists",
    "section": "References",
    "text": "References\n\nGISTEMP Team. (2022a). Data.GISS: GISS Surface Temperature Analysis (v4): Analysis Graphs and Plots. https://data.giss.nasa.gov/gistemp/graphs/\nGISTEMP Team. (2022b). GISS Surface Temperature Analysis (GISTEMP), version 4. [Database]. NASA Goddard Institute for Space Studies. https://data.giss.nasa.gov/gistemp/\nNumPy. (2022). https://numpy.org/\nThe Matplotlib Development team. (2021). Matplotlib—Visualization with Python. https://matplotlib.org/\nThe Matplotlib Development Team. (2022). Tutorials—Matplotlib 3.5.2 documentation. https://matplotlib.org/stable/tutorials/index.html\n\n\n\n\n\nGISTEMP Team. (2022a). Data.GISS: GISS Surface Temperature Analysis (v4): Analysis Graphs and Plots. https://data.giss.nasa.gov/gistemp/graphs/\n\n\nGISTEMP Team. (2022b). GISS Surface Temperature Analysis (GISTEMP), version 4. [Database]. NASA Goddard Institute for Space Studies. https://data.giss.nasa.gov/gistemp/\n\n\nNumpy. (2022). NumPy. https://numpy.org/\n\n\nThe Matplotlib Development team. (2021). Matplotlib — Visualization with Python. https://matplotlib.org/\n\n\nThe Matplotlib Development Team. (2022). Tutorials — Matplotlib 3.5.2 documentation. https://matplotlib.org/stable/tutorials/index.html",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lists</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html",
    "title": "Principles of Scientific Visualization",
    "section": "",
    "text": "Motivating Problem: Comparing CO2 Emissions by Country\nCarbon dioxide is a significant greenhouse gas, and fossil fuel use is the major contributor to its increase in the earth’s atmosphere. Understanding the emissions from fossil fuel use by different countries is an integral part of public policy discussions. The US Department of Energy maintains a database of such data that can be used by environmental scientists, economists, and other professionals (Boden et al., 2013). A subset of the data is shown below in Table 1. The entire dataset is available in the file fossil-fuel-co2-emissions-by-nation.csv.\nA complete description of the data in each column is provided in Table 2.\nThe computational problem we want to solve in this chapter is to develop visualizations of the data in this table that can help in discussing the issue of greenhouse gas emissions from fossil fuel use.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#motivating-problem-comparing-co2-emissions-by-country",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#motivating-problem-comparing-co2-emissions-by-country",
    "title": "Principles of Scientific Visualization",
    "section": "",
    "text": "Table 1: CO2 emission from fossil fuel use.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYear\nCountry\nTotal\nSolid Fuel\nLiquid Fuel\nGas Fuel\nCement\nGas Flaring\nPer Capita\nBunker fuels (Not in Total)\n\n\n\n\n1800\nCANADA\n1\n1\n0\n0\n0\n0\n0\n0\n\n\n1800\nGERMANY\n217\n217\n0\n0\n0\n0\n0\n0\n\n\n1800\nPOLAND\n111\n111\n0\n0\n0\n0\n0\n0\n\n\n1800\nUNITED KINGDOM\n7269\n7269\n0\n0\n0\n0\n0\n0\n\n\n1800\nUNITED STATES OF AMERICA\n69\n69\n0\n0\n0\n0\n0\n0\n\n\n1801\nCANADA\n1\n1\n0\n0\n0\n0\n0\n0\n\n\n1801\nGERMANY\n146\n146\n0\n0\n0\n0\n0\n0\n\n\n1801\nPOLAND\n121\n121\n0\n0\n0\n0\n0\n0\n\n\n1801\nUNITED KINGDOM\n7290\n7290\n0\n0\n0\n0\n0\n0\n\n\n1801\nUNITED STATES OF AMERICA\n73\n73\n0\n0\n0\n0\n0\n0\n\n\n1802\nCANADA\n1\n1\n0\n0\n0\n0\n0\n0\n\n\n1802\nFRANCE (INCLUDING MONACO)\n611\n611\n0\n0\n0\n0\n0\n0\n\n\n1802\nGERMANY\n151\n151\n0\n0\n0\n0\n0\n0\n\n\n1802\nPOLAND\n123\n123\n0\n0\n0\n0\n0\n0\n\n\n1802\nUNITED KINGDOM\n7328\n7328\n0\n0\n0\n0\n0\n0\n\n\n1802\nUNITED STATES OF AMERICA\n79\n79\n0\n0\n0\n0\n0\n0\n\n\n\n\n\n\n\n\n\n\nTable 2: Column description for data in Table 5.1.\n\n\n\n\n\n\n\n\n\n\n\nField Name\nOrder\nType (Format)\nDescription\n\n\n\n\nYear\n1\nyear\nYear\n\n\nCountry\n2\nstring\nNation\n\n\nTotal\n3\nnumber\nTotal carbon emissions from fossil fuel consumption and cement production (million metric tons of C)\n\n\nSolid Fuel\n4\nnumber\nCarbon emissions from solid fuel consumption\n\n\nLiquid Fuel\n5\nnumber\nCarbon emissions from liquid fuel consumption\n\n\nGas Fuel\n6\nnumber\nCarbon emissions from gas fuel consumption\n\n\nCement\n7\nnumber\nCarbon emissions from cement production\n\n\nGas Flaring\n8\nnumber\nCarbon emissions from gas flaring\n\n\nPer Capita\n9\nnumber\nPer capita carbon emissions (metric tons of carbon; after 1949 only)\n\n\nBunker fuels (Not in Total)\n10\nnumber\nCarbon emissions from bunker fuels (not included in total)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#what-are-scientific-visualizations",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#what-are-scientific-visualizations",
    "title": "Principles of Scientific Visualization",
    "section": "What are Scientific Visualizations?",
    "text": "What are Scientific Visualizations?\nEveryone knows the quaint aphorism “A picture is worth 1000 words”. It communicates that a visual representation of information can often inform more quickly and accurately than a simple verbal description. When scientists and engineers wish to understand large amounts of data or interpret the results of a model, the same principle applies: visual representations are often more useful than the data viewed in its original form. In the age of Big Data and computer simulations, this observation takes on even more meaning and leads to the field of scientific visualization.\nAn excellent example of this bit of wisdom is seen in comparing Table 1 and Figure 1. The graph of temperature anomaly as a function of year identifies patterns much more straightforwardly than just looking at the data table itself. Similarly, we want to develop visualizations of the data in Table 1 that will help us identify useful patterns or trends that are difficult to see just by looking at the columns of numbers. Of course, identifying structure using visualization techniques requires some thought about how to create visualizations, and that is the subject of the scientific visualization field.\n\nDefinition of Scientific Visualization\nAs you might guess, allowing a bunch of academics to define a subject will lead to as many definitions as there are academics. But we can distill some common features that get us oriented to the topic. Here is our working definition of scientific visualization (Ausoni et al., 2014):\nScientific visualization is concerned with graphically representing scientific phenomena to gain understanding and insight into the system that was previously impossible.\n\nThis may be part of the research process: graphics are used for understanding, interpretation, and exploration and may guide the direction of the research itself, from tweaking parameters to raising new questions.\nIt may be used in production environments, such as medical procedures, as part of a larger mission.\nIt may be used for educational purposes, in the classroom, etc.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#classifying-scientific-visualizations",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#classifying-scientific-visualizations",
    "title": "Principles of Scientific Visualization",
    "section": "Classifying Scientific Visualizations",
    "text": "Classifying Scientific Visualizations\nThere are many approaches to classifying scientific visualizations, and our goal here is not to perform an exhaustive review. Indeed, there is a rich literature on classifying data visualizations. Some focus on the type of data being visualized (Shneiderman, 2003) ; others focus on the models and algorithms used with data rather than the data itself (Tory & Moller, 2004). Instead, we will focus on one basic model that should be useful for novice computational scientists to develop effective visualizations. We will classify visualizations according to three principal axes, as shown in Figure 1: the content type of visual model (data-based - conceptual), dimensionality of the representation (2D-3D), and the element of time in the visualization (static - dynamic).\n\n\n\n\n\n\nFigure 1: Types of visualization models.\n\n\n\nFigure 2 shows an example of a conceptual visualization. It illustrates the main elements of the earth’s energy budget. While there is some quantitative information in the visualization, the primary purpose and information content are conceptual. Figure 3 shows the measured insolation (incoming solar radiation) as a function of the month for Lincoln, Nebraska (Power Project Team, n.d.) . This is an example of a data-based visualization. It is easy to pick out the seasonal pattern when viewing the data in this form. Figure 3 also serves as an example of a 2D visualization. There are many types of 2D graphs, including XY, contour, and bar. Figure 3 is a bar graph. 2D graphs are the bread and butter for traditional scientific publications, so we will spend quite a bit of time learning how to produce these.\n\n\n\n\n\n\nFigure 2: Earth’s energy budget. (Atkinson, 2017)\n\n\n\n\n\n\n\n\n\nFigure 3: Insolation (incoming solar radiation) as a function of month measured at the earth’s surface in Lincoln, Nebraska.\n\n\n\nBoth Figure 2 and Figure 3 are considered static visualizations since they are both static images that do not change. Dynamic visualizations such as animations that change over time are also very useful for exploring scientific data, particularly when we are interested in looking at changes over time. The following link shows the monthly average solar radiation arriving at earth’s surface for one year: Net Radiation Animation (Shinker, 2016) . Figure 4 shows three frames from the animation. This visualization is a dynamic, data-based, 2D visualization. Dynamic visualizations require more sophisticated viewing technologies than standard publications.\n\n\n\n\n\n\nFigure 4: Average short wave solar radiation arriving at Earths surface.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#python-modules-for-visualization",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#python-modules-for-visualization",
    "title": "Principles of Scientific Visualization",
    "section": "Python Modules for Visualization",
    "text": "Python Modules for Visualization\nThere are several modules that make up a useful Python visualization environment. These include Numpy, Matplotlib, Pandas, and Seaborn. We introduced numpy and matplotlib previously. In this section we will cover some additional features of Matplotlib and then introduce the Pandas and Seaborn modules.\n\nCreating 2d Graphs Using Matplotlib\nIn Chapter 4 we saw how to create a basic scatter graph using the plot function in the Matplotlib.pyplot module. We will now learn to customize a 2D plot. We will start with plotting functions. The following code illustrates specifying line color and line style. Figure 5 shows the result of this code.\nimport matplotlib.pylab as plt\nimport numpy as np\n\nx = np.linspace(0,5,40)\ny1 = 0.10*np.exp(0.10*x)\ny2 = 0.10*np.exp(0.20*x)\ny3 = 0.10*np.exp(0.30*x)\nplt.plot(x,y1,color='k' , label='mu= 0.1' , linestyle='-' , linewidth=3)\nplt.plot(x,y2,color='b' ,label='mu= 0.2' ,linestyle='--', linewidth=3)\nplt.plot(x,y3,color='r' ,label=' mu= .3' , linestyle=-.' , linewidth=3)\nplt.xlabel('x' , fontsize=14)\nplt.ylabel('y' , fontsize=14)\nplt.legend()\n\n\n\n\n\n\nFigure 5: Example of changing colors and linestyles.\n\n\n\nThere are several things to point out about the code.\n\nThe Numpy linspace function is used to generate a set of equally spaced numbers that can be used for the function calculations. This function generates a set of equally spaced numbers and returns them as a 1D numpy array. The syntax is\n\nnp.linspace(start, stop, num)\nstart: starting number of the interval\nstop: ending number of the interval\nnum: the number samples to generate\n\nThe color of a line (or data symbol) is determined by the color keyword argument. Table 3 gives the codes for the base set of colors in Matplotlib. The CSS color list gives considerably more choice. See the Matplotlib documentation for the CSS color codes (The Matplotlib development team, 2022).\nThe thickness of the line is set by the linewidth keyword argument. The number can be any positive float.\nThe type of line drawn is determined by the linestyle keyword argument. The allowed values are listed in Table 4.\n\n\n\n\nTable 3: :Matplotlib linestyle codes.\n\n\n\n\n\n\n\ndescription\n\n\ncolor\n\n\ncode\n\n\n\n\n\n\nblue\n\n\n\n\n\nb\n\n\n\n\ngreen\n\n\n\n\n\ng\n\n\n\n\nred\n\n\n\n\n\nr\n\n\n\n\ncyan\n\n\n\n\n\nc\n\n\n\n\nmagenta\n\n\n\n\n\nm\n\n\n\n\nyellow\n\n\n\n\n\ny\n\n\n\n\nblack\n\n\n\n\n\nk\n\n\n\n\nwhite\n\n\n\n\n\nw\n\n\n\n\n\n\n\n\n\n\nTable 4: Matplotlib linestyle codes.\n\n\n\n\n\n\ncode\nshort code\n\n\n\n\nSolid\n‘solid’\n‘-’\n\n\nDashed\n‘dashed’\n‘–’\n\n\nDotted\n‘dotted’\n‘:’\n\n\nDashdot\n‘dashdot’\n‘-.’\n\n\nNone\n‘none’\n”\n\n\n\n\n\n\nIf you do not like the default location of the legend, then you can customize it by using the loc keyword argument. The allowed strings or corresponding numerical codes are shown in Table 5.5.\nplt.legend(loc='upper center')    \n\n\n\nTable 5: Matplotlib legend loc values.\n\n\n\n\n\nstring\nnumber code\n\n\n\n\n‘best’\n0\n\n\n‘upper right’\n1\n\n\n‘upper left’\n2\n\n\n‘lower left’\n3\n\n\n‘lower right’\n4\n\n\n‘right’\n5\n\n\n‘center left’\n6\n\n\n‘center right’\n7\n\n\n‘lower center’\n8\n\n\n‘upper center’\n9\n\n\n‘center’\n10\n\n\n\n\n\n\nWhen numbers to be plotted cover a large order of magnitude range, or when we want to easily identify power law or exponential law behavior, using a logarithmic scale can be helpful. To make the y-axis use a logarithmic scale we can use the yscale function.\nplt.yscale('log') \nAdding this to the code that produced Figure 5 gives us Figure 6.\n\n\n\n\n\n\nFigure 6: Example of using the yscale function.\n\n\n\n\n\nIntroduction to the Pandas Module\nThe Pandas module is a basic component of the Python computational science environment and is particularly helpful for problems involving data analytics (The pandas development team, 2022). It provides a useful data structure for containing data, the dataframe, and many functions for working with a dataframe. To illustrate some of the features of Pandas we will use a classic data set used for educational purposes: the Fisher Iris Flower Data Set (Fisher, 1936). This data set can be obtained in a convenient electronic form as a csv file from Kaggle (Iris Species, n.d.). This data is in the file Iris.csv.\nA dataframe is a two-dimensional data structure, visualized as a 2-D grid, where each column can contain a different datatype. The data does not need to be numerical, as in the case of NumPy arrays. Each column in the dataframe has a label that will appear above the column in the first row of the grid. Each row of the grid, except for the first row containing the column labels, is indexed by a row number starting with 0. Figure 7 is a Colab Notebook excerpt that illustrates how to read in data from a csv file to create a Pandas dataframe. The Pandas function read_csv can be used to read in tab-delimited data, too, by using the header keyword argument (Pandas.read_csv — Pandas 1.4.3 Documentation, n.d.).\n\n\n\n\n\n\nFigure 7: Reading data into a dataframe and obtaining basic information about it.\n\n\n\nAn overview of the dataframe contents can be obtained by using the Pandas info function, as shown in Figure 7. We can see a listing of the column labels and how many non-null entries each column has. This last piece of information can be helpful in deciding what kind of data clean-up must be performed. The first few rows from the dataframe can be viewed by using the head function.\nThe data in an individual column from the dataframe can be accessed by using a square bracket notation, where the index in the bracket is the desired column label:\nds = df['Species']\nIn this example, the variable ds will be a pandas data series, which is a special pandas data structure that can be manipulated with appropriate pandas functions. Instead of working with pandas data series we will usually convert columns to Numpy arrays when the data type is numerical. This can be done with the to_numpy() method applied to a pandas data series. Here is an example:\nSepalLength_data =\ndf['SepalLengthCm']}.to_numpy()\nThe variable SepalLength_data will be a 1D numpy array that can be used by matplotlib plotting functions, for example. Pandas has many plotting functions that can be used with dataframes, but we will usually convert dataframe columns to numpy arrays and use matplotlib for our plotting.\n\n\nIntroduction to the Seaborn Module\nThe Seaborn module is built on top of Matplotlib but offers some advantages in certain situations. Some of the advantages are\n\nIntegration with Pandas so that dataframes can be used directly without needing to convert columns to Numpy arrays.\nSome useful graph types are prebuilt so that they can be implemented with a single function. One example is the pairwise or all-against-all scatterplot that we will use in 5.4.3.\nThere are some predefined styles that create aesthetically pleasing graphs consistent with good graphic design principles.\n\nTo illustrate some basic features of the Seaborn module we will use a selection of data from the NASA Exoplanet Archive (NASA Exoplanet Archive, n.d.). The data we will use is in the file PSCompPars_subset.csv. Before using the Seaborn module you must import it into your code file:\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nSeaborn contains functions to create a wide variety of plots. One method of generating a scatterplot is to use the lmplot() function. The basic syntax is\nfig = sns.lmplot(x=x_string, y=y_string, data=dataframe_name,\n                 fit_reg=False)\nx_string: the x-axis column heading from the dataframe\ny_string: the y-axis column heading from the dataframe\ndataframe_name: the Pandas dataframe containing the data\nIf the fit_reg keyword argument is not set to False then a linear regression line is automatically added to the graph. We will come back to performing a linear regression fit to data in Chapter 10.\nHere is an example of creating a scatterplot from the exoplanet data file.\nplanets =\npd.read_csv('PSCompPars_subset.csv', header=16)\nplanets_fig = sns.lmplot(x='pl_orbsmax', y='pl_orbper', data=planets, fit_reg=False)\n                            plt.xlim(0,1.5)\nplt.xlabel('Orbital Semi-major Axis [au]')\nplt.ylabel('Orbital Period [days]')\nplanets_fig.savefig('pl_orbsmax-pl_orbper.png' , dpi=300)\nNote that we applied three matplotlib.pyplot functions to the Seaborn plot, xlim, xlabel, and ylabel. This illustrates a nice feature of Seaborn. We can use matplotlib to provide some customization of the plot. This can be done because Seaborn is built on top of Matplotlib. (#fig:Figure5.8)shows the result of this code.\n\n\n\n\n\n\n\n\n\n\nFigure 8: Example of the Seaborn white theme.\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Example of the Seaborn darkgrid theme.\n\n\n\n\n\n\n\nOverall style of a graph is determined by using one of the predefined themes. This is done with\nsns.set_style(theme)\nwhere theme is one of the following strings:\ndarkgrid, whitegrid, dark, white, ticks\nUsing the darkgrid theme to create the scatterplot shown in Figure 8 yields Figure 9.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#sec-creating_a_good_visualization",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#sec-creating_a_good_visualization",
    "title": "Principles of Scientific Visualization",
    "section": "Creating a Good Visualization",
    "text": "Creating a Good Visualization\nSolving complex scientific and engineering problems can be facilitated by using a structured approach or strategy and the same is true for developing a good scientific visualization. We will use a strategy or workflow suggested by Ben Fry (Fry, 2008).\n\nFirst Steps\nThe first step is to start with a question that you want to answer with the visualization. Starting with data and asking what it can tell us can lead to being overwhelmed by possibilities, whereas beginning with a question before even looking for or looking at data allows us to focus the visualization that we develop in a constructive way. A second part of this initial step is to define the audience for the visualization. Some helpful questions to define the audience include\n\nAre they science professionals used to looking at graphs?\nWhat information would they expect in a visualization?\nHow much time will they devote to looking at the visualization?\n\n\n\nVisualization Development Workflow\nOnce we have defined a question and our audience, Fry suggests the following workflow (Fry, 2008):\n\nAcquire - Obtain the data, whether from a file on a disk or a source over a network.\nParse or Understand the Data - Provide structure for the data’s meaning, and order it into categories.\nFilter – Clean the data and remove all but the data of interest.\nMine – Use methods from statistics, data mining, or more fundamental scientific principles to discern patterns or place the data in a mathematical context.\nRepresent - Choose a basic visual model, such as a bar graph, scatter graph, contour plot, or other visual construct.\nRefine - Improve the basic representation to make it clearer and more visually engaging.\nInteract - Add methods for manipulating the data or controlling what features are visible.\n\nThe last step, adding interaction, will not be discussed in this book.\n\n\nIris Flower Example\nAs an example, we will explore some properties of the iris flower contained in the classic educational data set originally created by R.A. Fisher (Fisher, 1936). The question guiding our visualization development is\n\nCan sepal or petal measurements be used to distinguish species of the iris flower?\n\nThe sepal is the part of the flower that protects the petals in the flower bud. Figure 10 shows an example of an iris flower.\n\n\n\n\n\n\nFigure 10: An iris flower showing how petal and sepal measurements are defined (Rathod, 2020).\n\n\n\nWe will step through the workflow defined above to develop visualizations that can help answer the question.\nAcquire\nWe can easily acquire a nice dataset related to the iris flower already in a convenient electronic form as a csv file from Kaggle (Iris Species, n.d.). This data is in the file Iris.csv.\nParse\nWe must parse or inspect the dataset to understand the properties or measurements that are included and whether any cleanup must be done. The pandas module contains some useful functions for inspecting a data frame. Therefore, we should first read the data in the Iris.csv file as a pandas data frame, as discussed in section 5.3. Next, we inspect the dataframe using the pandas info function. The output is shown in Figure 7 . The output shows that all the columns are numerical data, except for the Species column. We can also see that there are 150 rows, or records, of data and that there are no null values. This will help us in the next step of filtering the data.\n\n\n\nTable 6: Description of the iris flower data set.\n\n\n\n\n\n\n\n\n\nProperty\nValue\n\n\n\n\nNumber of Observations\n150\n\n\nNumber of Attributes for each observation\n5\n\n\nAttributes observed\nsepal length sepal width petal length petal width species\n\n\nNumber of null values\n0\n\n\n\n\n\n\nFilter\nFiltering data involves removing data that will not be needed. Part of this process is to clean up the data by removing null values or removing records (rows in a pandas dataframe) that contain null values. We can determine whether there are null values by looking at the results from the pandas info function or by using the isnull function. The output from the info function applied to the iris flower dataframe already tells us that we do not have null values in the data set. The output from the isnull function, shown in Figure 11 , can also tell us this result. It specifies whether each value in the dataframe is null (True) or not null (False). We would have to inspect all rows to verify the result. Note that the output of the isnull function is another pandas dataframe.\n\n\n\n\n\n\nFigure 11: Output from the isnull function applied to the iris flower dataset.\n\n\n\nOne way to verify that there are no null values in a column of the dataframe is to sum up the values of the corresponding column in the isnull dataframe. For example, the following code would check on the existence of null values in the SepalLengthCm column.\nisnull_result = pd.isnull(df)\nsepal_length_number_of_nulls = isnull_result['SepalLengthCm'].sum()\nThe value of sepal_length_number_of_nulls would come out to be 0. This works because the Boolean value False is interpreted as a 0 in the sum function. We can perform this check on all columns with the following\n\nWe are fortunate, in this example, to be working with a clean data set.\nMine\nTo mine our data set requires performing some exploratory data analysis so that we can begin to discern any patterns in the data. Basic descriptive statistics on each column, representing a particular measured attribute, can be obtained with the pandas describe function. Figure 12 shows the result for the iris flower dataframe.\n\n\n\n\n\n\nFigure 12: Results from applying the describe function to the iris dataframe.\n\n\n\nLooking at a histogram for each numerical observation can be an informative part of exploratory data analysis. The Seaborn module has a histogram function that will create professional-looking histograms. To generate a histogram of the petal length measurements, use the following\nsns.histplot(df, x='PetalLengthCm' , bins=18)\nFigure 13 shows the resulting histograms for both petal measurement. Note that there is an interesting double peak structure which may be related to the species.\n\n\n\n\n\n\nFigure 13: Histograms for the petal measurements.\n\n\n\nWhen we have multivariate data to explore a pairwise or all-against-all scatterplot can be useful to identify possible correlations and clustering in the data. A quick way to produce such a plot when the data is in a pandas dataframe is to use the seaborn module pairplot function.\nimport seaborn as sns\ng = sns.pairplot(df,hue=\"Species\")\ng.savefig('iris_pairplot.png' , dpi=300)\nFigure 14 shows the resulting pairwise plot. The diagonal plots in the matrix are the frequency distributions for the variable indicated by the column or row label.\n\n\n\n\n\n\nFigure 14: Pairwise plot for the iris flower data set.\n\n\n\nLooking at the pairwise plot suggests that the following plots might be useful in identifying species:\n\npetal length versus sepal length\npetal length versus sepal width\npetal length versus petal width\n\nTo extract the data required for producing these three plots using matplotlib we will create new pandas dataframes containing one species each and then extract the numerical columns and convert them to numpy arrays. Figure 1.15 shows the code that will accomplish this.\n# Create a dataframe for each species\nsetosa = df.loc[df['Species']=='Iris-setosa']\nversicolor = df.loc[df['Species']=='Iris-versicolor']\nvirginica = df.loc[df['Species']=='Iris-virginica']\n\n# Create numpy arrays containing the numerical measurements\nsetosa_np = setosa.loc[:,['SepalLengthCm','SepalWidthCm','PetalLengthCm',\n          'PetalWidthCm']].to_numpy()\nversicolor_np = versicolor.loc[:,['SepalLengthCm','SepalWidthCm','PetalLengthCm',\n          'PetalWidthCm']].to_numpy()\nvirginica_np = virginica.loc[:,['SepalLengthCm','SepalWidthCm','PetalLengthCm',\n          'PetalWidthCm']].to_numpy()\nRepresent\nBased on the exploratory data analysis performed in the mining part of our workflow we want to construct three scatter graphs that show petal lengths versus sepal lengths, sepal widths, and petal widths. We will use matplotlib so that we have greatest control over the final appearance of the plots. The code in Figure 15 can be used for the petal length versus sepal length graph.\n\n\n\n# Create Petal Length versus Sepal Length plot\nplt.plot(setosa_np[:,2],setosa_np[:,0], linestyle='', marker='d',\n          label='setosa')\nplt.plot(versicolor_np[:,2],versicolor_np[:,0], linestyle='', marker='o', \n          label='versicolor')\nplt.plot(virginica_np[:,2],virginica_np[:,0], linestyle='', marker='^', \n          label='virginica')\nplt.legend()\nplt.xlabel('Sepal Length [cm]')\nplt.ylabel('Petal Length [cm]')\nplt.title('Petal Length versus Sepal length')\nplt.savefig('PetalLengthVsSepalLength.png', dpi=300)\n\n\nFigure 15: :Code for creating the petal length versus sepal length graph.\n\n\n\nThis code can be modified to produce the other two graphs by changing the column used for the y axis in the plot function. Figure 16 shows the three graphs created in this step of the workflow.\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n(c)\n\n\n\n\n\n\n\n\nFigure 16: :Iris flower measurement comparisons by species.\n\n\n\nRefine\nWe should refine our visualization to clarify the representation or by changing attributes that contribute to readability. One thing that might be changed in Figure 16 to aid comparing the graphs is to make the y-axis scale the same. We can set the y-axis scale with\nplt.ylim((0,8))\nThe result of putting this statement in the code is Figure 17.\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n(c)\n\n\n\n\n\n\n\n\nFigure 17: :Iris flower measurement comparisons by species.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#computational-problem-solution-comparing-co2-emissions-by-country",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#computational-problem-solution-comparing-co2-emissions-by-country",
    "title": "Principles of Scientific Visualization",
    "section": "Computational Problem Solution: Comparing CO2 Emissions by Country",
    "text": "Computational Problem Solution: Comparing CO2 Emissions by Country\nAs a final example of developing scientific visualizations, we return to the problem posed at the beginning of the chapter: looking at CO2 emissions from fossil fuel use. We will focus on two questions.\n\nHow do nations of the world compare in their CO2 emissions from fossil fuel use for a recent year?\nHow has the CO2 emission from fossil fuel use changed over time for the highest emitters?\n\nOur target audience will be policymakers in government.\nAcquire - Obtain the data\nWe will use a subset of data from the U.S. Department of Energy (Boden et al., 2013). The subset is provided in the csv file fossil-fuel-co2-emissions-by-nation.csv. A description of each column in the file, including units used is in Table 2.\nParse or Understand the Data - Provide structure for the data’s meaning, and order it into categories.\nWe will import the data as a Pandas dataframe and then look at information about the data set using the pandas info and describe functions. Screenshots of the Colab notebook that performs these operations are shown in Figure 18 and Figure 19.\n\n\n\n\n\n\nFigure 18: Colab notebook section illustrating some parsing of the data.\n\n\n\n\n\n\n\n\n\nFigure 19: Result of the pandas describe function.\n\n\n\nOne important observation from the describe results is that the final year for which we have data is 2014.\nNext, we check for any null values in the dataset that would have to be removed using the pandas isnull function. The results are shown in Figure 20.\n\n\n\n\n\n\nFigure 20: Checking for null values in the data set.\n\n\n\nFilter – Clean the data and remove all but the data of interest.\nAgain, we are fortunate in that the data set is relatively clean. There are no null entries that must be deleted to work with the plotting functions. It is likely that we will need to extract a subset of the data to focus on answering the questions that we posed. The data for 2014 can be extracted into its own dataframe with\n# Extract rows for 2014\ndata_2014 = df.loc[(df['Year'] == 2014) & (df['Total']&gt;5.e4)]\ndata_2014_sort = data_2014.sort_values('Total', ascending=False)\nMine – Use methods from statistics, data mining, or more fundamental scientific principles to discern patterns or place the data in a mathematical context.\nCreating histograms for each measurement ends up not being very informative, except to show that most countries have very low emissions for most years. The high emitter countries dominate.\nA basic pairwise or all-against-all scatterplot can be produced with the following code\ng = sns.pairplot(df, corner=True)\ng.savefig('CO2Emissions_pairplot.png', dpi=300)\nThe corner keyword argument is used to produce a plot containing the bottom left triangle of plots, since the top right triangle contains the same information with axes reversed. Figure 21 shows the result.\n\n\n\n\n\n\nFigure 21: Pair plot for the CO2 emissions data set.\n\n\n\nThere are some interesting correlations suggested in Figure 5.20, but they are probably not relevant for answering our questions.\nRepresent - Choose a basic visual model, such as a bar graph, scatter graph, contour plot, or other visual construct.\nA bar chart will be a good way of comparing country data for 2014, the most recent year for which we have data. We will use the matplotlib horizontal bar plot function, barh. We must extract the relevant columns from the dataframe and convert them to numpy arrays. The following code will generate an appropriate bar plot.\n# Convert columns to numpy arrays\nCountry_data = data_2014_sort['Country'].to_numpy()\nTotal_data = data_2014_sort['Total'].to_numpy()\nplt.barh(Country_data, Total_data)\nplt.yticks(fontsize=6)\nplt.tight_layout()\nplt.savefig('CO2Emissions2014.png', dpi=300)\nThe result is Figure 22.\n\n\n\n\n\n\nFigure 22: Comparison by country of CO2 emission data for 2014.\n\n\n\nTo address the question of how emissions have changed over time for the high emitter countries we will use a scatterplot that shows total emission in a year as a function of year. We will focus on the top five emitters: China, United States, India, Russian Federation, and Japan, shown in Figure 23.\n\n\n\n\n\n\nFigure 23: CO2 emissions from fossil fuels versus year.\n\n\n\nRefine\nThe final version of the horizontal bar plot should have an x-axis label and a title. This is accomplished with the code in Figure 24. Note the additions in lines 31-33. The result is shown in Figure 25.\n\n\n\n\"\"\"\nTitle: Fossil Fuel CO2 Emissions - 2014\nAuthor: C.D. Wentworth\nVersion: 7.31.2022.2\nSummary: This program will read in U.S. Dept. of Energy data for\n         CO2 emissions by fossil fuel and produce a bar graph for\n         the year 2014.\n\nRevision History:\n    7.31.2022.1: base\n    7.31.2022.2: adjusts font size for the y-axis\n\n\"\"\"\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n# Import data as pandas dataframe\ndf = pd.read_csv('fossil-fuel-co2-emissions-by-nation.csv')\n\n# Extract rows for 2014\ndata_2014 = df.loc[(df['Year'] == 2014) & (df['Total']&gt;5.e4)]\ndata_2014_sort = data_2014.sort_values('Total', ascending=False)\n\n# Convert columns to numpy arrays\nCountry_data = data_2014_sort['Country'].to_numpy()\nTotal_data = data_2014_sort['Total'].to_numpy()\n\n# Create bar plot using matplotlib\nplt.barh(Country_data, Total_data)\nplt.xlabel('Emissions [MMTons of C]')\nplt.title('Total CO^2 Emissions for 2014', fontsize=14)\nplt.yticks(fontsize=6)\nplt.tight_layout()\nplt.savefig('CO2Emissions2014V2.png', dpi=300)\nplt.show()\n\n\nFigure 24: :Final code for country comparison for 2014.\n\n\n\n\n\n\n\n\n\nFigure 25: Total CO2 emissions by country, final form.\n\n\n\nFigure 23 shows no measurable emissions for any of the displayed countries before 1850 on the chosen y-axis scale, therefore it would be better to define the x-axis limits to start with 1850. To show data for Russia over the same time period we would need to create a data series that combines the USSR with Russia. To avoid this complication, we will just delete Russia from the displayed countries. Since color will not always show for printouts of the graph, we will use grayscale colors, line width and line style changes to help distinguish the different countries. Figure 26 shows the code for the final form of the plot. Figure 27 shows the final plot.\n\n\n\n\"\"\"\nTitle: Fossil Fuel CO2 Emissions Versus Year\nAuthor: C.D. Wentworth\nVersion: 7.31.2022.2\nSummary: This program will read in  U.S. Dept. of Energy data for\n         CO2 emissions by fossil fuel and produce a scatter graph for\n         of emissions versus year.\nRevision History:\n    7.31.2022.1: base\n    7.31.2022.2: change x-axis scale and linestyles\n\n\"\"\"\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n# Import data as pandas dataframe\ndf = pd.read_csv('fossil-fuel-co2-emissions-by-nation.csv')\n\n# Extract rows of particular countries\nChina_data = df.loc[df['Country'] == 'CHINA (MAINLAND)']\nUS_data = df.loc[df['Country'] == 'UNITED STATES OF AMERICA']\nIndia_data = df.loc[df['Country'] == 'INDIA']\nJapan_data = df.loc[df['Country'] == 'JAPAN']\n\n# Convert columnes to numpy arrays\nChina_data_year = China_data['Year'].to_numpy()\nChina_data_total = China_data['Total'].to_numpy()\nUS_data_year = US_data['Year'].to_numpy()\nUS_data_total = US_data['Total'].to_numpy()\nIndia_data_year = India_data['Year'].to_numpy()\nIndia_data_total = India_data['Total'].to_numpy()\nJapan_data_year = Japan_data['Year'].to_numpy()\nJapan_data_total = Japan_data['Total'].to_numpy()\n\n\n# Create scatter plot - matplotlib\nplt.plot(China_data_year, China_data_total, linewidth=5, color='silver',\n         linestyle='--', label='China')\nplt.plot(US_data_year, US_data_total, linewidth=3, color='black',\n         linestyle=':', label='US')\nplt.plot(India_data_year, India_data_total, linewidth=2, color='black',\n         label='India')\nplt.plot(Japan_data_year, Japan_data_total, linewidth=4, color='gray',\n         label='Japan')\nplt.xlim(xmin=1850)\nplt.xlabel('Year')\nplt.ylabel('Emmisions [MMTons of C]')\nplt.title('Total CO2 Emissions - Year', fontsize=14)\nplt.legend()\nplt.savefig('CO2EmissionsVersusYearFinal.png', dpi=300)\nplt.show()\n\n\nFigure 26: :Code for emissions versus year, final form.\n\n\n\n\n\n\n\n\n\nFigure 27: CO2 emission versus year, final form.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#exercises",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#exercises",
    "title": "Principles of Scientific Visualization",
    "section": "Exercises",
    "text": "Exercises\n1. True or False: Scientific visualization is the same thing as computer graphics.\n2. Scientific visualization is the process of selecting and combining _________ of data to help in discovering laws or in communicating results appropriately for a given audience.\n3. Scientific visualizations can be classified using the following dimensions (or axes): (choose all that apply)\n\ncontent\ndimensionality (2D/3D)\ntime\ncolor\n\n4. Classify the following visualization using the system in Figure 1.\n\n5. Classify the following visualization using the system in Figure 1.\n\n6. Classify the following visualization using the system in Figure 1. This visualization shows the hydrogen electron wave function for the n=4, l=3, m=0 state.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#ch05-program-modification-problems",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#ch05-program-modification-problems",
    "title": "Principles of Scientific Visualization",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. The code shown below creates a histogram of the petal length measurements in the Iris Flower Data Set similar to Figure 13, except that bars have been colored according to species. You need to modify this code so that\n\nIt will create a histogram for the sepal length in the data set.\nThe x-axis label says “Sepal Length [cm]”\n\n\"\"\"\nTitle: Iris Histogram\nAuthor: C.D. Wentworth\nVersion: 7.31.2022.1\nSummary: This program will read in the Iris data set and\n         produce a histogram of one of the measurements.\nRevision History:\n    7.31.2022.1: base\n\n\"\"\"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns \n\n# Import data as pandas dataframe\ndf = pd.read_csv('Iris.csv')\n\n# Create a histogram - Seaborn version\nsns.histplot(df, x='PetalLengthCm', bins=18, hue='Species')\nplt.savefig('petalLengthHist.png', dpi=300)\nplt.show()\n2. The code below plots three exponential functions on the same graph. You need to modify the code so that it does the following:\n\nplots the following three functions on the same graph:\n\n\\(f_1\\left(x\\right) = x \\quad,\\quad f_2\\left(x\\right) = x^2 \\quad, \\quad f_3\\left(x\\right) = x^3\\)\n\nplot the functions over the range \\(0.1 \\leq x \\leq 10\\)\nChange the legend to indicate the power involved in each function:\n\np = 1 , p = 2 , p = 3\n\nMake both the x-axis scale and the y-axis scale logarithmic.\n\n\"\"\"\nTitle: Plotting Multiple Functions\nAuthor: C.D. Wentworth\nVersion: 8.4.2022.1\nSummary: This program will plot several functions on one graph\n         using matplotlib.\nRevision History:\n        8.4.2022.1: base\n\n\"\"\"\nimport matplotlib.pylab as plt\nimport numpy as np\nx = np.linspace(0,5,40)\ny1 = 0.10*np.exp(0.10*x)\ny2 = 0.10*np.exp(0.20*x)\ny3 = 0.10*np.exp(0.30*x)\nplt.plot(x,y1,color='k',label='mu = 0.1',linestyle='solid', linewidth=3)\nplt.plot(x,y2,color='b',label='mu = 0.2',linestyle='dashdot', linewidth=3)\nplt.plot(x,y3,color='r',label='mu = 0.3',linestyle='dotted', linewidth=3)\nplt.xlabel('x', fontsize=14)\nplt.ylabel('y', fontsize=14)\nplt.legend(loc='upper left')\nplt.tight_layout()\nplt.savefig('Ch5ProgModProb2.png', dpi=300)\nplt.show()\n3. The code shown below creates a scatterplot using the planets data. It uses the Seaborn module, as discussed in section 5.3.3. You need to modify the code to do the following\n\nUse data for bacterial growth in the file BacterialGrowthData.txt. This data gives the measured bacterial cell density in the growth bottle filled with either CHSA or TSB media (liquid food) as a function of time. To read this data into a Pandas dataframe you will need to tell read_csv that the file is tab-delimited instead of comma-delimited. This is done with sep keyward argument:\n\nsep=‘\\t’\nYou will also need to inspect the data file to determine which row is the header that contains the column headings. Remember that Python uses zero-based indexing.\n\nCreate a scatterplot of the CHSA column versus time.\nUse the whitegrid Seaborn style.\nSet the x-axis label to ‘t [min]’\nSet the y-axis label to ’ N [rel]’. The N stands for the density of bacteria in the sample. The units [rel] indicate relative units.\nAdd a title: ‘Bacterial Growth versus Time: CHSA Media’ ; set the font size to 14.\nSave the graph as a png graphics file.\n\n\"\"\"\nTitle: Scatter Plot - Seaborn Version\nAuthor: C.D. Wentworth\nVersion: 8.4.2022.1\nSummary: This program will plot several functions on one graph\n         using matplotlib.\nRevision History:\n        8.4.2022.1: base\n\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nsns.set_style('darkgrid')\n\n# Read in exoplanet data as a pandas dataframe\nplanets = pd.read_csv('PSCompPars_subset.csv', sep=',', header=16)\n\n# Create a scatterplot\nsns.lmplot(x='pl_orbsmax', y='pl_orbper', data=planets,  fit_reg=False)\nplt.xlim(0,1.2)\nplt.xlabel('Orbital Semi-major Axis [au]')\nplt.ylabel('Orbital Period [days]')\nplt.savefig('pl_orbsmax-pl_orbper.png', dpi=300)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#program-development-problems",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#program-development-problems",
    "title": "Principles of Scientific Visualization",
    "section": "Program Development Problems",
    "text": "Program Development Problems\n1. Develop visualizations that will help explore how per capita fossil fuel CO2 emissions have developed over time and how they compare by country in recent years. You can use the data in the csv file\nfossil-fuel-co2-emissions-by-nation.csv\nGo through the visualization development workflow discussed in Creating a Good Visualization. In addition to the code file or Jupyter notebook that you create, you need to write a brief summary of how you executed each workflow step (excluding the addition of interaction).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#references",
    "href": "chapters/Ch05/Ch05_PrinciplesOfScientificVisualization.html#references",
    "title": "Principles of Scientific Visualization",
    "section": "References",
    "text": "References\n\nAtkinson, J. (2017, April 10). What is Earth’s Energy Budget? Five Questions with a Guy Who Knows [Text]. NASA. http://www.nasa.gov/feature/langley/what-is-earth-s-energy-budget-five-questions-with-a-guy-who-knows\nAusoni, C. O., Frey, P., & Tierny, J. (2014). Scientific Visualization at the interfaces. https://www.ljll.math.upmc.fr/frey/visu.html\nBoden, T. A., Andres, R. J., & Marland, G. (2013). Global, Regional, and National Fossil-Fuel CO2 Emissions (1751—2010) (V. 2013). Environmental System Science Data Infrastructure for a Virtual Ecosystem (ESS-DIVE) (United States); Carbon Dioxide Information Analysis Center (CDIAC), Oak Ridge National Laboratory (ORNL), Oak Ridge, TN (United States). https://doi.org/10.3334/CDIAC/00001_V2013\nFisher, R. A. (1936). The Use of Multiple Measurements in Taxonomic Problems. Annals of Eugenics, 7(2), 179–188. https://doi.org/10.1111/j.1469-1809.1936.tb02137.x\nFry, Ben. (2008). Visualizing data. O’Reilly Media, Inc.; WorldCat.org. https://www.loc.gov/catdir/toc/fy0804/2008297507.html\nIris Species. (n.d.). Retrieved July 31, 2022, from https://www.kaggle.com/datasets/uciml/iris\nList of named colors—Matplotlib 3.5.2 documentation. (2022). https://matplotlib.org/stable/gallery/color/named_colors.html\nNASA Exoplanet Archive. (n.d.). Retrieved August 2, 2022, from https://exoplanetarchive.ipac.caltech.edu/index.html\npandas.read_csv—Pandas 1.4.3 documentation. (n.d.). Retrieved August 1, 2022, from https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html\nPower Project Team. (n.d.). NASA POWER Prediction Of Worldwide Energy Resources. Retrieved July 30, 2022, from https://power.larc.nasa.gov/\nRathod, V. (2020). Iris Flower CaseStudy. RPubs. https://rpubs.com/vidhividhi/irisdataeda\nShinker, J. J. (2016). Global Climate Animations. Gobal Climate Animations. http://climvis.org/content/global.htm\nShneiderman, B. (2003). The Eyes Have It: A Task by Data Type Taxonomy for Information Visualizations. In B. B. Bederson & B. Shneiderman (Eds.), The Craft of Information Visualization (pp. 364–371). Morgan Kaufmann. https://doi.org/10.1016/B978-155860915-0/50046-9\nThe pandas development team. (2022). pandas—Python Data Analysis Library. https://pandas.pydata.org/\nTory, M., & Moller, T. (2004). Rethinking Visualization: A High-Level Taxonomy. IEEE Symposium on Information Visualization, 151–158. https://doi.org/10.1109/INFVIS.2004.59\n\n\n\n\n\nAtkinson, J. (2017, April 10). What is Earth’s Energy Budget? Five Questions with a Guy Who Knows [Text]. NASA. http://www.nasa.gov/feature/langley/what-is-earth-s-energy-budget-five-questions-with-a-guy-who-knows\n\n\nAusoni, C. O., Frey, P., & Tierny, J. (2014). Scientific Visualization at the interfaces. https://www.ljll.math.upmc.fr/frey/visu.html\n\n\nBoden, T. A., Andres, R. J., & Marland, G. (2013). Global, Regional, and National Fossil-Fuel CO2 Emissions (1751 - 2010) (V. 2013). Environmental System Science Data Infrastructure for a Virtual Ecosystem (ESS-DIVE) (United States); Carbon Dioxide Information Analysis Center (CDIAC), Oak Ridge National Laboratory (ORNL), Oak Ridge, TN (United States). https://doi.org/10.3334/CDIAC/00001_V2013\n\n\nFisher, R. A. (1936). The Use of Multiple Measurements in Taxonomic Problems. Annals of Eugenics, 7(2), 179–188. https://doi.org/10.1111/j.1469-1809.1936.tb02137.x\n\n\nFry, Ben. (2008). Visualizing data. O’Reilly Media, Inc. https://www.loc.gov/catdir/toc/fy0804/2008297507.html\n\n\nIris Species. (n.d.). Retrieved July 31, 2022, from https://www.kaggle.com/datasets/uciml/iris\n\n\nNASA Exoplanet Archive. (n.d.). Retrieved August 3, 2022, from https://exoplanetarchive.ipac.caltech.edu/index.html\n\n\nPandas.read_csv — pandas 1.4.3 documentation. (n.d.). Retrieved August 1, 2022, from https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html\n\n\nPower Project Team. (n.d.). NASA POWER | Prediction Of Worldwide Energy Resources. Retrieved July 30, 2022, from https://power.larc.nasa.gov/\n\n\nRathod, V. (2020). Iris Flower CaseStudy. RPubs. https://rpubs.com/vidhividhi/irisdataeda\n\n\nShinker, J. J. (2016). Global Climate Animations. Gobal Climate Animations. https://climvis.org/animations.html\n\n\nShneiderman, B. (2003). The Eyes Have It: A Task by Data Type Taxonomy for Information Visualizations. In B. B. Bederson & B. Shneiderman (Eds.), The Craft of Information Visualization (pp. 364–371). Morgan Kaufmann. https://doi.org/10.1016/B978-155860915-0/50046-9\n\n\nThe Matplotlib development team. (2022). List of named colors — Matplotlib 3.5.2 documentation. https://matplotlib.org/stable/gallery/color/named_colors.html\n\n\nThe pandas development team. (2022). Pandas - Python Data Analysis Library. https://pandas.pydata.org/\n\n\nTory, M., & Moller, T. (2004). Rethinking Visualization: A High-Level Taxonomy. IEEE Symposium on Information Visualization, 151–158. https://doi.org/10.1109/INFVIS.2004.59",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Principles of Scientific Visualization</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html",
    "href": "chapters/Ch06/Ch06_Functions.html",
    "title": "Functions",
    "section": "",
    "text": "Motivating Problem: Temperature Conversion –Revised\nComputer applications used in science and engineering can involve thousands or millions of lines of code. Faced with the complexity of such programs, programmers can use the computational science pillars of abstraction and decomposition to create a high-level conceptualization of the program and then break the coding into more manageable pieces. One method of applying the ideas of abstraction and decomposition is to use named blocks of code or program routines. In Python, program routines are called functions.\nFunctions will aid in managing code complexity and achieving code modularity: creating code that can be used to solve multiple computational problems. In this chapter, we will learn how to create user-defined functions and become familiar with underlying computer science concepts that will help us use functions correctly in a program.\nIn Chapter 3, we developed a program to perform user-requested temperature conversions, such as going from Fahrenheit to Celsius. While the code structure is evident due to added comments, we can improve the clarity by defining functions to perform parts of the program, such as requesting a temperature from the user and performing the temperature conversion. Having functions for these tasks will allow us to reuse some of the code in other programs. Therefore, the problem we want to solve is to rewrite the code from Chapter 3 so that the following tasks are performed in their own separate functions:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html#motivating-problem-temperature-conversion-revised",
    "href": "chapters/Ch06/Ch06_Functions.html#motivating-problem-temperature-conversion-revised",
    "title": "Functions",
    "section": "",
    "text": "request a temperature to convert from the user\nrequest the final temperature scale to be used\nperform the actual temperature conversion calculation",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html#program-routines",
    "href": "chapters/Ch06/Ch06_Functions.html#program-routines",
    "title": "Functions",
    "section": "Program Routines",
    "text": "Program Routines\nA computer program can contain a block of code that gets repeated. We have seen that iterative control structures do this. If the block contains many lines of code, then the program’s design can be clarified by bundling the block into a separate part that a single line of code can substitute. A block of code that a name can reference is called a program routine. A routine can be called up and executed as often as required by just using the name. Figure 1 shows the concept of reusing a named block of code. Figure 2 shows how a code block in a program can be replaced by a single code line using a program routine. Program routines are called functions in Python.\n\n\n\n\n\n\nFigure 1: Illustrating the use of a Program Routine.\n\n\n\n\n\n\n\n\n\nFigure 2: Replacing a code block with a routine to clarify program structure.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html#python-functions-as-a-program-routine",
    "href": "chapters/Ch06/Ch06_Functions.html#python-functions-as-a-program-routine",
    "title": "Functions",
    "section": "Python Functions as a Program Routine",
    "text": "Python Functions as a Program Routine\nThe basic structure of a Python function definition is\ndef function_name(p1, p2, p3):\n    statement 1\n    statement 2\n    .\n    .\n    .\nThe function definition begins with the header statement def, and the function name can be any legal Python variable name. The variable names in the parentheses are called parameters, which represent values that will be passed to the function when it is called. All statements inside the function definition comprise a suite (or block) of code and must all be indented by the same amount.\nThe parameter names, p1, p2, and p3, above are simply placeholders. They will be assigned actual values when the function is called from the main program. Consider the following example.\nvar1 = 10\nvar2 = 20\nvar3 = 30\nfunction_name(var1, var2, var3)\nWhen the function is called, the parameters p1, p2, and p3 get replaced by the values in the variables var1, var2, and var3. Values that get passed to a function when it is called are arguments. The placeholder names appear in the function definition, and those placeholders get replaced by corresponding argument values when the function is called.\nPython functions must be defined before they are called in a statement. Function definitions typically appear at the top of a program.\n\nValue-returning Functions\nIn mathematics, the function notation, \\(f\\left(x\\right)\\) indicates a value that depends on the value of x for its definition. If you see \\(f\\left(x\\right)\\) in a mathematical statement, you can imagine it being replaced by the appropriate value. Similarly, value-returning functions get replaced by a value generated by the function in a statement containing the function. The returned value is indicated in the function definition through the use of the keyword return. The following code shows an example of a value-returning function.\ndef factorial(n):\n    f = 1\n    for i in range(1,n+1):\n        f = f*i\n    return f\n\n# Main Program\nprint(factorial(4))\nThe output of the print function is 24 in this example.\n\n\nNon-value-returning Functions\nAs the name suggests, a non-value-returning function does not return a value when it is called in a statement; instead, it is called because of side effects that occur when the function is executed. For example, a non-value returning function might cause specific messages to be printed out. Figure 3 shows an example. Note that the function greeting(name) has no return statement, but it still has an effect.\n\n\n\n\n\n\nFigure 3: Non-value returning function.\n\n\n\nStrictly speaking, the non-value-returning function will return a value: None, but we will treat such functions as truly non-value-returning.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html#function-parameters-and-arguments",
    "href": "chapters/Ch06/Ch06_Functions.html#function-parameters-and-arguments",
    "title": "Functions",
    "section": "Function Parameters and Arguments",
    "text": "Function Parameters and Arguments\n\nParameter Passing\nThe variable names used in the parameter list of a function definition are placeholders. They get replaced by actual argument values when the function is called in a statement. Consider the following simple function.\ndef f(n1, n2):\n    t = 3.1415*(n1 + 2.0*n2)\n    return t\nThe main program contains the following statements\nv1 = 3.0\nv2 = 4.0\nprint(f(v1, v2))\nWhen the function f is called in the print statement, the parameters n1 and n2 in the function definition get replaced by the arguments v1 and v2. The call to f in the print statement results in the display of the number 34.56. The parameters are replaced by the arguments based on the order. If later in the main program, the following code is executed\nprint(f(v2,v1)\nthe number 31.42 will be displayed.\n\n\nKeyword Arguments\nIn the above example, values were assigned to function parameters using the position of the arguments in a function call. The technical term for such arguments is positional arguments. Values can also be assigned to parameters using parameter names. This approach is called keyword arguments. For the function \\(f\\) defined above, the following call to the function would result in 34.56 being displayed.\nv1 = 3.0\nv2 = 4.0\nprint(f(n2=v2, n1=v1))\nIf you use both positional and keyword arguments to assign values to parameters in a function call, the positional arguments must all be assigned first.\n\n\nDefault Arguments\nDefault values can be assigned to a function parameter when the function is defined. The following code gives an example.\ndef f(n1=3, n2=4):\n    t = 3.1415*(n1 + 2.0*n2)\n    return t\nprint(f())\nThe code will display 34.56 even though no arguments were provided to the function.\n\n\nVariable Scope\nThe scope of a variable is the block of code in which the variable is defined, can be used, and can be modified. In a Python program that contains function definitions, variables can have either local or global scope. A local variable, or a variable with local scope, is defined and used within a function. A global variable, or a variable with global scope, is defined outside of a function. To explore the difference, consider the following short program.\ndef f1(n):\n    t1 = 2*n\n    t2 = t1 + 3\n    return t2\ndef f2(n):\n    t3 = 2*n + global_v\n    return t3\nglobal_v = 5\nprint(f1(global_v))\nprint(f2(global_v))\nThe first print statement displays the number 13, and the second print statement displays 15. Note that the variable global_v was not passed to function f2, but since it was defined outside of a function, it will have the value five everywhere in the program. global_v is a global variable or has global scope.\nNow, after executing the above code, suppose we execute\nprint(t1)\nThe result will be an execution error because the variable t1 was defined in function f1, not outside it, so it is available only within f1. t1 is a local variable or has local scope.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html#sec-comp_prob_solving_temp_conv_function_version",
    "href": "chapters/Ch06/Ch06_Functions.html#sec-comp_prob_solving_temp_conv_function_version",
    "title": "Functions",
    "section": "Computational Problem Solving: Temperature Conversion – Function Version",
    "text": "Computational Problem Solving: Temperature Conversion – Function Version\nThe problem described at the beginning of the chapter was to revise the temperature conversion program from Chapter 3 so that the following pieces were performed in functions rather than in the main program.\n\nrequest a temperature to convert from the user\nrequest the final temperature scale to be used\nperform the actual temperature conversion calculation\n\n\nAnalysis\nThe critical analysis for this problem was performed in Chapter 3, where we collected all required conversion equations, Equations 3.1a-3.1f. We can use the test data in Table 3.5 to determine if our revised program is working correctly.\n\n\nDesign\nWe provide a revised pseudocode version of the temperature conversion program in Figure 4.\n\n\n\nPROGRAM temperature_conversion\n    Print a program greeting\n    submitted_temperature, submitted_scale = request_temperature()\n    converted_scale = request_converted_scale(submitted_scale)\n    converted_temperature = \n              calculate_converted_temp(submitted_temperature, \n              submitted_scale, converted_scale) \n    Print out converted_temperature\nENDPROGRAM\n\n\nFigure 4: :Pseudocode for the revised temperature conversion program.\n\n\n\nData structures used in the revised program are listed in Table 1.\n\n\n\nTable 1: Data structures (variables) required by the revised program.\n\n\n\n\n\nData Structure\nType\nDescription\n\n\n\n\nsubmitted_temperature\nfloat variable\ntemperature submitted by the user\n\n\nsubmitted_scale\nstring variable\nscale for submitted_temperature\n\n\nconverted_temperature\nfloat variable\nthe converted temperature\n\n\nconverted_scale\nstring variable\nscale for converted_temperature\n\n\n\n\n\n\nThe revised pseudocode for the program contains three functions. We must create pseudocode versions for each of those functions. These are contained in Figure 5, Figure 6, and Figure 7.\n\n\n\nFUNCTION request_temperature\n    INPUT: None\n    submission_is_incorrect = True\n    scale_request = \"'C' for Celsius, 'F' for Fahrenheit, \n                    'K' for Kelvin \"\n    WHILE submission_is_incorrect DO\n        Print request for temperature\n        Get temperature and convert to float (defines \n                                       submitted_temperature)\n        print request for scale\n        get scale (defines submitted_scale)\n        IF ((submitted_scale == 'C') and \n            (submitted_temperature &gt;= -273.15))\n            submission_is_incorrect = False\n        ELSE IF ((submitted_scale == 'F') and \n                (submitted_temperature &gt;= -459.67))\n            submission_is_incorrect = False\n        ELSE IF ((submitted_scale == 'K') and \n                (submitted_temperature &gt;= 0)):\n            submission_is_incorrect = False\n        ELSE\n            print('Incorrect submitted temperature. Try again.')\n        ENDIF\n    ENDWHILE\n    OUTPUT submitted_temperature, submitted_scale\nENDFUNCTION\n\n\nFigure 5: :Pseudocode version of request_temperature function.\n\n\n\n\n\n\nFUNCTION request_converted_scale\n    INPUT: submitted_scale\n    submission_is_incorrect = True\n    WHILE submission_is_incorrect DO\n        Print the request for the temperature scale\n        Get scale from user (defines converted_scale)\n        IF ((submitted_scale == 'C') and\n              (converted_scale == 'F' or converted_scale == 'K'))\n            submission_is_incorrect = False\n        ELIF ((submitted_scale == 'F') and\n              (converted_scale == 'C' or converted_scale == 'K'))\n            submission_is_incorrect = False\n        ELIF ((submitted_scale == 'K') and\n              (converted_scale == 'C' or converted_scale == 'F'))\n            submission_is_incorrect = False\n        ELSE\n            print('There is a problem with your submission.')\n        ENDIF\n    ENDWHILE\n    OUTPUT converted_scale\nENDFUNCTION\n\n\nFigure 6: :Pseudocode version of request_converted_scale function.\n\n\n\n\n\n\nFUNCTION calculate_converted_temp\n    INPUT: submitted_temperature, submitted_scale, converted_scale\n    IF submitted_scale == 'C':\n        IF converted_scale == 'F'\n            # convert Celsius to Fahrenheit\n            converted_temperature = submitted_temperature*9.0/5.0 + \n                                    32.0\n        ELSE\n            # convert Celsius to Kelvin\n            converted_temperature = submitted_temperature + 273.15\n        ENDIF\n    ELIF submitted_scale == 'F':\n        IF converted_scale == 'C'\n            # convert Fahrenheit to Celsius\n            converted_temperature = (submitted_temperature – \n                                     32.0)*5./9.\n        ELSE\n            # convert Fahrenheit to Kelvin\n            converted_temperature = (submitted_temperature – \n                                     32.0)*5.0/9.0 + 273.15\n        ENDIF\n    ELSE\n        IF converted_scale == 'C'\n            # convert Kelvin to Celsius\n            converted_temperature = submitted_temperature - 273.15\n        ELSE\n            # convert Kelvin to Fahrenheit\n            converted_temperature = (submitted_temperature – \n                                     273.15)*9.0/5.0 + 32.0  \n        ENDIF\n    ENDIF\n    OUTPUT converted_temperature\nENDFUNCTION\n\n\nFigure 7: :Pseudocode version of calculate_converted_temp function.\n\n\n\n\n\nImplementation\nThe Python implementation of the three functions described above is straightforward and can be seen in Figure 8, Figure 9, and Figure 10. With those function definitions, the main program becomes short and very clear in its structure, as shown in Figure 11.\n\n\n\ndef request_temperature():\n    scale_request = \"'C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin \"\n    submission_is_incorrect = True\n    while submission_is_incorrect:\n        submitted_temperature = float(input('Submit a temperature'))\n        print('Specify the scale of your submitted temperature: ')\n        submitted_scale = input(scale_request)\n        if ((submitted_scale == 'C') and (submitted_temperature &gt;= -273.15)):\n            submission_is_incorrect = False\n        elif ((submitted_scale == 'F') and (submitted_temperature &gt;= -459.67)):\n            submission_is_incorrect = False\n        elif ((submitted_scale == 'K') and (submitted_temperature &gt;= 0)):\n            submission_is_incorrect = False\n        else:\n            print('Incorrect submitted temperature. Try again.')\n    return submitted_temperature, submitted_scale\n\n\nFigure 8: :Python implementation of request_temperature function.\n\n\n\n\n\n\ndef request_scale(submitted_scale):\n    print('What scale should be used for the converted temperature?')\n    scale_request = \"'C' for Celsius, 'F' for Fahrenheit, 'K' for Kelvin \"\n    converted_scale = input(scale_request)\n    submission_is_incorrect = True\n    while submission_is_incorrect:\n        if ((submitted_scale == 'C') and\n           (converted_scale == 'F' or converted_scale == 'K')):\n            submission_is_incorrect = False\n        elif ((submitted_scale == 'F') and\n              (converted_scale == 'C' or converted_scale == 'K')):\n            submission_is_incorrect = False\n        elif ((submitted_scale == 'K') and\n              (converted_scale == 'C' or converted_scale == 'F')):\n            submission_is_incorrect = False\n        else:\n            print('There is a problem with your submission.')\n            converted_scale = input(scale_request)\n    return converted_scale\n\n\nFigure 9: :Python implementation of request_converted_scale function.\n\n\n\n\n\n\ndef calculate_converted_temp(submitted_temperature, submitted_scale, \n                             converted_scale):\n    if submitted_scale == 'C':\n        if converted_scale == 'F':\n            # convert Celsius to Fahrenheit\n            converted_temperature = submitted_temperature*9.0/5.0 + 32.0\n        else:\n            # convert Celsius to Kelvin\n            converted_temperature = submitted_temperature + 273.15\n    elif submitted_scale == 'F':\n        if converted_scale == 'C':\n            # convert Fahrenheit to Celsius\n            converted_temperature = (submitted_temperature - 32.0)*5./9.\n        else:\n            # convert Fahrenheit to Kelvin\n            converted_temperature = (submitted_temperature - 32.0)*5.0/9.0 + 273.15\n    else:\n        if converted_scale == 'C':\n            # convert Kelvin to Celsius\n            converted_temperature = submitted_temperature - 273.15\n        else:\n            # convert Kelvin to Fahrenheit\n            converted_temperature = (submitted_temperature - 273.15)*9.0/5.0 + 32.0    \n    return converted_temperature\n\n\nFigure 10: :Python implementation of calculate_converted_temp function.\n\n\n\n\n\n\n# Main Program\n\n# Display program greeting\nprint('Welcome to the Temperature Scale Conversion Program!')\nprint('This program will request that the user submit a temperture.')\nprint('Next, it requests the converted scale.')\nprint('Finally, it prints out the converted temperature.')\nsubmitted_temperature, submitted_scale = request_temperature()\nconverted_scale = request_scale(submitted_scale)\nconverted_temperature = calculate_converted_temp(submitted_temperature,\n                                                 submitted_scale,  \n                                                 converted_scale) \n# print out the result\ns1 = format(submitted_temperature, '.2f')\ns2 = format(converted_temperature, '.2f')\nprint(s1, submitted_scale, ' is ', s2, converted_scale)\n\n\nFigure 11: :Python implementation of the main program.\n\n\n\n\n\nTesting\nTest data listed in Table 5 from chapter 3 will be used to test the revised program. The complete code for the revised program is contained in the file Ch6TempConvProg.py. The test results for the program are listed in Table 2. The results provide evidence that the program works according to the requirements.\n\n\n\nTable 2: Test results for the Chapter 6 Temperature Conversion Program.\n\n\n\n\n\nSubmitted Temperature\n\nConverted Temperature\n\n\n\n\n\n\nT\nScale\nT\nScale\nProgram Output\n\n\n-300\nC\nError\n\nerror detected\n\n\n-150\nC\n-238\nF\n-238\n\n\n-150\nC\n123.15\nK\n123.15\n\n\n0\nC\n32\nF\n32\n\n\n0\nC\n273.15\nK\n273.15\n\n\n-500\nF\nError\n\nerror detected\n\n\n-400\nF\n-240\nC\n-240\n\n\n-400\nF\n33.15\nK\n33.15\n\n\n0\nF\n-17.78\nC\n-17.78\n\n\n0\nF\n255.37\nK\n255.37\n\n\n-100\nK\nError\n\nerror detected\n\n\n0\nK\n-273.15\nC\n-273.15\n\n\n0\nK\n-459.67\nF\n-459.67\n\n\n150\nK\n-123.15\nC\n-123.15\n\n\n150\nK\n-189.67\nF\n-189.67",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html#exercises",
    "href": "chapters/Ch06/Ch06_Functions.html#exercises",
    "title": "Functions",
    "section": "Exercises",
    "text": "Exercises\n1. T/F: A user-defined function can be called as many times as is necessary in a program.\n2. When a function is defined, the variable names appearing in the parentheses are called _________.\n3. When a function is called in the main part of a program, the values passed to it are called _______.\n4. What kind of function must contain a return statement?\n\nany function\nvalue-returning function\nnon-value-returning function\n\n5. A non-value-returning function can perform useful work through ______________.\n6. T/F: A value-returning function can only return one value at a time.\n7. When a function call contains no keyword arguments, then the correspondence between arguments and function parameters is determined by the __________ of the arguments.\n8. A program routine is\n\nthe identifier in a function header\na named group of instructions in a program\na built-in function of a programming language\nthe arguments passed from a function call\n\n9. A formal parameter in a function is\n\na placeholder name used in the function header, inside parentheses\na value passed to the function in a function call\nthe keyword def in a function definition\na variable name that appears in the calling program for a function\n\n10. Consider the following code\ndef a_function(p1, p2):\n    t = p1*p2\n    return t\n\n# Main Program\nnum1 = 10.0\nprint(a_function(num1, 20.0)\nWhat is the scope of variable t in a_function?",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html#program-modification-problems",
    "href": "chapters/Ch06/Ch06_Functions.html#program-modification-problems",
    "title": "Functions",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. One of the main techniques used in developing a computational solution to a problem is abstraction. The primary technique for implementing abstraction in code is to define functions that solve a small part of the problem. Defining functions is especially useful when a certain process must be repeated many times across more than one program. The function definition can be reused in multiple programs.\nThis exercise will give you some practice in defining your own Python function.\nYou need to define a Python function that accepts an integer N as an argument and then adds all the integers from 1 to N and returns the value. The main program should ask the user for an integer, and then it should print out the result of the function. The code shown below is a starting point for your solution. Make sure to\n\nChange the welcome message so that it is appropriate to the problem.\nDefine the function that calculates that does the calculation.\nPrints out the user-defined integer and the sum with an appropriate message. This should be done in the Main Program.\n\n\"\"\"\nProgram Name: Chapter 6 Prog Mod Prob 1\nAuthor: C.D. Wentworth\nversion: 8.10.2022.1\nSummary: This program will request that the user enter\n         a positive integer and prints it out.\n\"\"\"\n\n# Function definition \n\n# Main Program\n# Display program welcome\nprint('This program will request a number from the user.')\n\n# Get an integer\nuser_number = int(input('Enter a positive integer: '))\n\nwhile (user_number-int(user_number)) != 0 or (user_number &lt;= 0):\n    user_number = int(input(\"Please enter a positive integer: \"))\n\nprint('You entered N =', user_number)\n2. Modify the Chapter 6 Temperature Conversion Program discussed in the Computational Problem Solving: Temperature Conversion – Function Version section to include the Rankine scale in addition to Celsius, Fahrenheit, and Kelvin scales. Start with the code in the file\nCh6TempConversionProgram.py.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch06/Ch06_Functions.html#ch06-program-development-problems",
    "href": "chapters/Ch06/Ch06_Functions.html#ch06-program-development-problems",
    "title": "Functions",
    "section": "Program Development Problems",
    "text": "Program Development Problems\n1. Write a program to produce a table of equivalent temperatures using the Kelvin, Celsius, Fahrenheit, and Rankine scales. Produce the columns in the order just described. Start with 0 [K] and go up to 375 [K] with a 5-degree increment. The numbers should be formatted to have two decimal places. Label each of the columns appropriately. The table should be written out to a tab-delimited text file.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html",
    "title": "Dynamical Systems Modeling I",
    "section": "",
    "text": "Motivating Problem: Mathematical Model for Bacterial Growth\nA dynamical systems model will allow a researcher to make quantitative predictions about a system, particularly with respect to the time development of important system properties. Such models are based on fundamental principles, not just empirical data, so they contribute to our basic understanding of the system being investigated. With a dynamical systems model we can make more reliable predictions about the course of a disease in a population, the metabolism of a drug in the human body, how the concentration of CO2 in the atmosphere changes over time, the motion of a space vehicle on its way to Mars, and even the motion of planets in our solar system over thousands of years.\nThis chapter will introduce you to some basic concepts of calculus that will make dynamical systems models easier to understand and some computational methods of solving the models to obtain predictions without having to know a lot of sophisticated mathematics.\nPseudomonas aeruginosa is a common species of bacteria found in soil, water reservoirs polluted by animals and humans, the human gastrointestinal tract, and on human skin (Diggle & Whiteley, 2020). It is involved in opportunistic infections of people, often in hospital settings, which makes it an important microbe to study and understand. If a container of liquid growth medium is inoculated with a small sample of the microbe, then growth data such as that shown in Figure 1 will be obtained.\nOur understanding of any microbial organism, such as Pseudomonas aeruginosa, will be aided by having an accurate mathematical model for the growth. The concepts developed in this chapter will help us to develop such a model and to simulate the model through numerical calculations done by computer.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#motivating-problem-mathematical-model-for-bacterial-growth",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#motivating-problem-mathematical-model-for-bacterial-growth",
    "title": "Dynamical Systems Modeling I",
    "section": "",
    "text": "Figure 1: Growth data for PA01 in 0.25% glucose medium.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#calculus-concepts",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#calculus-concepts",
    "title": "Dynamical Systems Modeling I",
    "section": "Calculus Concepts",
    "text": "Calculus Concepts\nYour understanding of mathematical models will be aided by knowing just a couple of ideas from calculus, namely, the basic idea of a derivative of a function and the integral of a function. The goal here is not to become proficient at doing all the operations of taking derivatives or calculating integrals but to just have a basic conceptual understanding of what these mathematical things represent.\n\nDerivatives\nWe will start with the derivative of a function. Consider the simple physics experiment of dropping a ball from some height and recording its position as a function of time. Table 1 gives some actual data taken from a video of such a ball drop. @#fig-Figure7.2 shows a graph of the data.\n\n\n\nTable 1: Height as a function of time for a dropped ball.\n\n\n\n\n\nt [s]\ny [m]\n\n\n\n\n0.06673\n2.693\n\n\n0.1001\n2.682\n\n\n0.1335\n2.67\n\n\n0.1668\n2.611\n\n\n0.2002\n2.576\n\n\n0.2336\n2.505\n\n\n0.2669\n2.446\n\n\n0.3003\n2.341\n\n\n0.3337\n2.235\n\n\n0.367\n2.141\n\n\n0.4004\n1.999\n\n\n0.4338\n1.882\n\n\n0.4671\n1.729\n\n\n0.5005\n1.588\n\n\n0.5339\n1.411\n\n\n0.5672\n1.247\n\n\n0.6006\n1.047\n\n\n0.634\n0.8586\n\n\n0.6673\n0.6586\n\n\n0.7007\n0.4705\n\n\n0.7341\n0.2588\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Ball height as a function of time. Data is from Table 1.\n\n\n\nYou can probably tell from the graph that the ball is speeding up over time, as it drops. The data points are at equal time intervals and the change in y clearly gets bigger as time increases. We will describe the y-coordinate by the function \\(y\\left(t\\right)\\). We define the average rate of change of \\(y\\left(t\\right)\\) by\n\\[\\overline{v}_y = \\frac{y\\left(t_2\\right)- y\\left(t_1\\right)}{t_2- t_1} = \\frac{\\Delta y}{\\Delta t} \\tag{1}\\]\nWe choose to symbolize this number by \\(\\overline{v}_y\\) because in this case it turns out to be the average velocity of the ball, hence the v. We can easily estimate the average rate of change of \\(y\\left(t\\right)\\) by using the data in the table. For the average rate of change between 0.2002 and 0.2669 [s] we have\n\\[\\overline{v}_y = \\frac{y\\left(0.2669\\right)- y\\left(0.2002\\right)}{0.2669- 0.2002} = \\frac{(2.446- 2.576)\\left[m\\right]}{0.0667\\left[s\\right]} = - 1.95\\left[m/ s\\right] \\tag{2}\\]\nThe main conceptual idea of a derivative of a function such as \\(y\\left(t\\right)\\) is to calculate the average rate of change of \\(y\\left(t\\right)\\) as the time interval gets infinitesimally small. The mathematical process of doing this is taking a limit, although you do not need to worry about the details of actually doing this. We call this value the instantaneous rate of change of \\(y\\left(t\\right)\\) at a particular value of t. The symbol for the instantaneous rate of change of with \\(y\\left(t\\right)\\) respect to t at t = a is\n\\[\\left.\\frac{dy\\left(t\\right)}{dt}\\right|_{t = a} \\tag{3}\\]\nand this quantity is called the derivative of \\(y\\left(t\\right)\\) at t=a. Formally, we define\n\\[\\left.\\frac{dy\\left(t\\right)}{dt}\\right|_{t = a} = \\mathop{\\text{lim}}\\limits_{\\Delta t\\rightarrow 0}\\frac{y\\left(a + \\Delta t\\right)- y\\left(a\\right)}{\\Delta t} \\tag{4}\\]\nIf you take a calculus course, you will learn a variety of techniques for performing the limit procedure. For our purposes, we can interpret the derivative geometrically. The derivative of \\(y\\left(t\\right)\\) at t = a is the slope of the tangent line to \\(y\\left(t\\right)\\) drawn at t = a. For example, Figure 3 shows a model calculation for the ball height \\(y\\left(t\\right)\\) with an estimate of the derivative of \\(y\\left(t\\right)\\) at t = 0.20 [s]. A straight line is drawn tangent to the curve at t = 0.20 [s], and the slope of the straight line is estimated from the rise and run. We get\n\\[\\left.\\frac{dy\\left(t\\right)}{dt}\\right|_{t = 0.20} = \\text{slope of tangent line} = \\frac{- 1.69\\left[m\\right]}{0.80\\left[s\\right]} = - 2.1\\left[m/ s\\right] \\tag{5}\\]\n\n\n\n\n\n\nFigure 3: Illustration of finding the derivative of a function at t = 0.2 [s] by estimating the slope of the tangent line.\n\n\n\n\n\nIntegrals\nThe second calculus concept we need is the integral of a function. The geometrical meaning of the definite integral of a function v(t) between t1 and t2 is the area under the curve between t=t1 and t=t2\n\n\n\n\n\n\nFigure 4: The shaded area represents the integral of v(t) between t1 and t2 .\n\n\n\nIn Figure 4 , the shaded area represents the integral of v(t) between t1 and t2 .\nMathematicians use a special symbol to represent the integral of a function, as shown in the following equation.\n\\[\\int\\limits_{t_1}^{t_2}v\\left(t\\right)dt = \\text{area under v-t graph from }t_1\\text{ to }t_2 \\tag{6}\\]\nAs an example, consider Figure 5. Let’s calculate the integral of v(t) from t = 0 to t = 2 [s].\n\\[\\int\\limits_0^2v\\left(t\\right)dt = \\text{area under v-t graph }\\text{from }\\text{0[s] }\\text{to }\\text{2[s]}\\text{=}\\frac{1}{2}\\text{base} \\times \\text{height} = \\frac{1}{2} \\times 2 \\times 20 = 20\\left[m\\right] \\tag{7}\\]\n\n\n\n\n\n\nFigure 5: Velocity as a function of time for a particle with constant acceleration.\n\n\n\nThe integral of a function is essentially the opposite of the derivative. In fact, if you integrate the derivative of a function you end up with the function itself. We can express this as\n\\[\\int\\limits_{t_1}^{t_2}\\frac{dy}{dt}dt = y\\left(t_2\\right)- y\\left(t_1\\right) \\tag{8}\\]\n\n\nNumerical Calculation of Derivatives and Integrals\nBoth the derivative of a function and the integral of a function can be calculated numerically with standard Python library functions. The derivative function is in the scipy sublibrary named misc (The SciPy community, 2022b). A template for using the derivative function is shown below.\nimport scipy.misc as spm\ndef f(x):\n    return x**3\ndfx = spm.derivative(f,2,dx=1e-6,n=1)\nThe scipy library scipy.integrate has several functions for performing numerical integration. They differ by the algorithm used. The best first choice is the quad function (The SciPy community, 2022a). Here is the basic syntax for using the quad function.\nscipy.integrate.quad(f,a,b,args=())\nf : a Python function\na: float that is the lower limit of integral\nb: float that is the upper limit of integral\nargs: a tuple that contains any parameters required by f\nThe quad function returns a tuple: (value of integral, error estimate). A template for using the quad function to perform integration is shown below.\nimport scipy.integrate as si\ndef f(t):\n    return (30. - 1.8*t - 0.040*t**2)\nintFunc = si.quad(f,0,5)\nintegral_value = intFunc[0]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#definition-of-a-dynamical-system:sec",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#definition-of-a-dynamical-system:sec",
    "title": "Dynamical Systems Modeling I",
    "section": "Definition of A Dynamical System",
    "text": "Definition of A Dynamical System\nA dynamical system is one that changes with time. Mathematically, it is a set of variables that describe the system of interest, and these variables will all depend on time. The state of the system is described by the value of the variables at a particular time. The present state of the system will depend on the system state in the past. The mathematical model defining the dynamical system is typically described by the state variable definitions and equations describing the rate of change for these variables.\nExamples:\n\nPopulation of an organism\nelectrical behavior of a network of neurons\nPlanetary positions in a stellar system\nthe motion of molecules in a fluid\ndrug concentration in a body part\nmany, many more biological, physical, and social systems\n\nIn the simplest case, the state of the system will be described by the value of one variable, which will be a function of time. Let us represent the state by the variable \\(y\\left(t\\right)\\), which is shown explicitly to be a function of time. y might be concentration of bacteria in a container, for example. For this one-variable system, the model is specified by the time-rate-of-change of y, which is just the derivative of y with respect to t.\n\\[\\frac{dy}{dt} = f\\left(t,y,\\mathbf p\\right) \\tag{9}\\]\nThe function f is assumed to be known. We see that it can depend on the current time t, the current value of the state variable y, and on model parameters contained in the vector p. If the value of y is known at one time, often \\(t=0\\), then Equation will determine the behavior of y for all subsequent t. The general term for this kind of mathematical problem is the Initial Value Problem (IVP).\nOf course, many biological, physical, and social systems require more than one variable to define a state. Even a simple pendulum represented by a ball of mass m attached to a massless, rigid rod with a pivot point so that the ball moves in a plane requires two variables to describe the state of the system, the angle \\(\\theta\\) measured with respect to the vertical and the angular velocity \\(\\omega\\). Figure 6 shows the geometry.\n\n\n\n\n\n\nFigure 6: Pendulum geometry.\n\n\n\nThe more general dynamical system can be described by N state variables, \\(y_0,\\dddot ,y_{N- 1}\\), and N rate equations, one for each state variable.\n\\[\\begin{array}{l} \\frac{dy_0}{dt} = f_1\\left(t,y_0,\\cdots, y_{N- 1},\\mathbf p_0\\right) \\\\ \\vdots  \\\\ \\frac{dy_{N- 1}}{dt} = f_{N- 1}\\left(t,y_0,\\cdots, y_{N- 1},\\mathbf p_{N- 1}\\right) \\\\  \\end{array} \\tag{10}\\]\nAgain, we assume that the functions \\(f_0,\\ldotp \\ldotp \\ldotp ,f_{N- 1}\\) are known. If the state variables are known at a particular time, \\(t=0\\), for example, then the differential equations can be solved to give the state variables at subsequent times.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#numerical-solution-of-a-dynamical-systems-model:sec",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#numerical-solution-of-a-dynamical-systems-model:sec",
    "title": "Dynamical Systems Modeling I",
    "section": "Numerical Solution of a Dynamical Systems Model",
    "text": "Numerical Solution of a Dynamical Systems Model\nSolving a dynamical system model so that state variables can be predicted for some range of t values requires solving an ordinary differential equation, Equation 9, or a system of such equations, Equation 10. For some choices of the function f, or series of functions f0, …, fN-1, techniques from the theory of ordinary differential equations can be used to obtain explicit solutions for y or \\(y_0,\\ldots ,y_{N - 1}\\). For example, consider the rate equation that leads to exponential growth.\n\\[\\frac{dy}{dt} = ry\\left(t\\right)\n    \\label{eq:EquationExpGrowthModel} \\tag{11}\\]\nUsing elementary methods from calculus, this differential equation can be integrated to obtain\n\\[y\\left(t\\right) = y\\left(0\\right)e^{rt} \\tag{12}\\]\nwhere y(0) is the value of y at \\(t=0\\).\nWe will often encounter dynamical systems models for which an explicit solution for the state variables cannot be obtained, at least not by the scientist or engineer who needs to use the solution. For such models, a numerical solution can be obtained through a numerical integration of the differential equation. We will not discuss here the mathematics behind developing such techniques but will present one method for using these techniques. The mathematics behind the numerical methods we will use is discussed by Iserles (Iserles, 2009). A powerful method for doing the numerical solution is to use the solveivp function from the scipy.integrate library (The SciPy Community, 2022). Figure 7 gives the basic template for using solveivp for a one-state variable model, as shown in Equation 9.\n\n\n\n\n\n\"\"\"\nProgram Name: Exponential Growth Model: Numerical Solution\nAuthor: C.D. Wentworth\nversion: 3.17.2020.1\nSummary: Basic script for solving a dynamical system representing\n         exponential growth. A numerical integration technique is\n         used.\n\n\"\"\"\n \nimport scipy.integrate as si\nimport numpy as np\nimport matplotlib.pylab as plt\n\ndef f(t,y,r):\n#   y = a list that contains the system state\n#   t = the time for which the right-hand-side of the system equations\n#       is to be calculated.\n#   r = a parameter needed for the model\n#\n    import numpy as np\n\n#   Unpack the state of the system\n    y0 = y[0] # cell density \n\n#   Calculate the rates of change (the derivatives)\n    dy0dt = r*y0\n\n    return [dy0dt] \n    \n\n\n\n\nFigure 7: Template for using solveivp.\n\n\n\n\n\n# Main Program\n\n# Define the initial conditions\nyi = [0.021]\n\n# Define the time grid\nt = np.linspace(0,300,200)\n\n# Define the model parameters\nr = 0.014\np = (r,)\n\n# Solve the DE\nsol = si.solve_ivp(f,(0,300),yi,t_eval=t,args=p)\nys = sol.y[0]\n\n# Plot the theory\nplt.plot(t,ys,color='g')\nplt.xlabel('t [min]')\nplt.ylabel('OD')\nplt.savefig('ExponentialGrowth.png',dpi=300)\nplt.show()\n\n\nContinuation of Template for using solveivp.\n\n\nAs the code shows, you must define a Python function that calculates the right hand side of the rate equation defined in Equation 9 in terms of t and the current value of the state variable y, symbolized by the parameter \\(y\\) in \\(f(t,y,r)\\). You must also define the initial value \\(y(0)\\), called yi in the program, and a list of t values for which you need the value of the state variable \\(y\\left(t\\right)\\), which is done in line 37. The function solveivp returns a list of objects, contained in sol, that defines the solution. The solution corresponding to the times in the array t are contained in the array sol.y[0]. To use the solution values in a plot we extract the actual solution values from sol and name the array ys, in line 45. If the dynamical systems model had more than one state variable then we could extract the solution values for each state variable as shown below.\nys0 = sol.y[0]\nys1 = sol.y[1]\n.\n.\n.\nWe will see an example of doing this in the next chapter. If the model has more than one parameter, they must all be placed in the tuple p in line 41 but listed separately in the function definition. The next section will show an example of such a model.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#computational-problem-solving-mathematical-model-for-the-growth-of-pseudomonas-aeruginosa",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#computational-problem-solving-mathematical-model-for-the-growth-of-pseudomonas-aeruginosa",
    "title": "Dynamical Systems Modeling I",
    "section": "Computational Problem Solving: Mathematical Model for the Growth of Pseudomonas aeruginosa",
    "text": "Computational Problem Solving: Mathematical Model for the Growth of Pseudomonas aeruginosa\nTo illustrate the numerical solution of a dynamical systems model we will return to the problem presented at the beginning of the chapter: the growth of Pseudomonas aeruginosa in a container with a fixed amount of liquid growth medium. When our goal is to develop a mathematical model of a system, we will use a modification of our four-step computational problem-solving strategy. Our strategy is\n\nAnalyze the problem\nFormulate a model\nSolve the model\nVerify and interpret the model’s solution\nReport on the model\nMaintain the model\n\nAnalyze the Problem\nOur analysis begins with some library research on growth of microorganisms. We find that the typical stages of growth for bacteria in a container with fixed amount of growth medium are those shown in Figure 8. This is supposed to be a semi-log plot with the y-axis being the log axis. On such a plot, exponential growth appears as a straight line (Hardy, 2002).\n\n\n\n\n\n\nFigure 8: Typical stages of growth for bacteria in a fixed amount of medium (Hardy, 2002).\n\n\n\nFor now, we will concentrate on modeling the exponential phase of cell growth. What factors in the system might affect the growth? In general, we might expect the temperature, pH, and other environmental factors will influence growth. We will assume those environmental factors are held constant. We are being very restrictive in how we describe the system. This is typical in starting a modeling project. We start with simple models and work our way up in complexity. In our case, there is one state variable:\n\\[y\\left(t\\right) \\equiv \\text{number of cells per ml}\\]\nWhat will determine the rate of change of \\(y\\left(t\\right)\\)? A reasonable hypothesis is that the rate of change of y will depend on the current number of cells, or cell density, that are present.\nFormulate a model\nWe can express the hypothesis stated above with Equation 11, repeated below.\n\\[\\frac{dy}{dt} = ry\\left(t\\right) \\tag{13}\\]\nSolve the model\nThe model defined by Equation 13 can be solved with a little bit of calculus to give\n\\[y\\left(t\\right) = y\\left(0\\right)e^{rt} \\tag{14}\\]\nThis is the exponential growth model.\nWe will implement a numerical solution below since it is more common for the scientist or engineer to require such an approach.\nVerify and interpret the model’s solution\nWe have data for the state variables with which to compare the predictions from the model. This is the ideal way of verifying the model. The data used to produce Figure 1 is in the file PA01SuspCell0p25PerCentGlucose-3-2017.txt. This data uses optical density of the liquid in the growth container to represent the cell density. Optical density is usually proportional to the actual cell density but establishing the exact relationship can be time-consuming.\nThe code in Figure 7 can be adapted to display both the theory and the data. Since the data file is composed of simple numerical columns we use the loadtxt function from Numpy to read in the data rather using Pandas. We can get the initial value of the state variable from the first row of data in the file. The value of the growth rate, r, is adjusted through trial and error to improve the fit between model and data. Figure 9 shows the adapted code. We will use statistical methods in Chapter 10 to find the best-fit model parameters. Figure 10 shows the comparison of the model and data.\n\n\n\n\"\"\"\nProgram Name: PA01 Growth - Model and Data\nAuthor: C.D. Wentworth\nversion: 8.16.2022.1\nSummary: This program performs a numerical solution for the exponential\n         growth dynamical systems model and compares the model results\n         with actual growth data for PA01.\nHistory:\n    8.16.2022.1: base\n\n\"\"\"\n\nimport scipy.integrate as si\nimport numpy as np\nimport matplotlib.pylab as plt\n\ndef f(t, y, r):\n    #   y = a list that contains the system state\n    #   t = the time for which the right-hand-side of the system equations\n    #       is to be calculated.\n    #   p = a tuple with parameters needed for the model\n    #\n    import numpy as np\n\n    #   Unpack the state of the system\n    y0 = y[0]  # cell density\n\n    #   Calculate the rates of change (the derivatives)\n    dy0dt = r * y0\n    return [dy0dt]\n\n# Main Program\n\n# Read in data\ncols = np.loadtxt('PA01_SuspCell_0p25PerCentGlucose_5-3-2017.txt',skiprows=6)\ntimeData = cols[:,0]\nODData = cols[:,1]\n\n# Define the initial conditions\nyi = [0.074]\n\n# Define the time grid\nt = np.linspace(0, 400, 200)\n\n# Define the model parameters\nr = 0.01175\np = (r,)\n\n# Solve the DE\nsol = si.solve_ivp(f, (0, 400), yi, t_eval=t, args=p)\nys = sol.y[0]\n\n# Plot the theory and data\nplt.plot(t, ys, color='g', label='Model')\nplt.plot(timeData, ODData, linestyle='', marker='d',\n         markersize=5.0, color='blue', label='Data')\nplt.xlabel('t [min]')\nplt.ylabel('OD')\nplt.yscale('log')\nplt.title('PA01 Growth: Comparison with Exponential Growth Model',\n          fontsize= 12)\nplt.legend()\nplt.savefig('PA01_ExpGrowth_ModelAndData.png', dpi=300)\nplt.show()\n\n\nFigure 9: :Code for exponential growth model calculation and data comparison.\n\n\n\n\n\n\n\n\n\nFigure 10: Comparison of exponential growth model with PA01 data.\n\n\n\nThe exponential growth model shows a clear deficiency in describing the PA01 growth data for \\(t&gt;200[\\text{min}]\\). We can improve our model by including the effect of a finite amount of nutrients. At some point there will not be enough nutrients to allow cells to grow and divide. We must replace the rate equation Equation 13 with one that shows exponential growth for the rate equation for small values of y but eventually has the rate go to zero. One possible hypothesis is\n\\[\\frac{dy\\left(t\\right)}{dt} = ry\\left(1- \\frac{y}{M}\\right) \\tag{15}\\]\nM is a new model parameter that represents the carrying capacity of the growth environment. When y approaches M, the rate of change for y will go to zero. The rate equation in Equation 15 is a historically famous one that defines the logistics model. Calculus techniques can be used to solve this differential equation exactly yielding Equation 16.\n\\[y\\left(t\\right) = \\frac{My\\left(0\\right)e^{rt}}{M + y\\left(0\\right)(e^{rt}- 1)} \\tag{16}\\]\nInstead of using the exact solution of Equation 15 we will implement a numerical solution so as to gain a little more experience in setting up the numerical solution framework.\n\n\n\n\"\"\"\nProgram Name: PA01 Growth - Logistics Model and Data\nAuthor: C.D. Wentworth\nversion: 8.16.2022.1\nSummary: This program performs a numerical solution for the logistics\n         growth dynamical systems model and compares the model results\n         with actual growth data for PA01.\nHistory:\n    8.16.2022.1: base\n\n\"\"\"\n\nimport scipy.integrate as si\nimport numpy as np\nimport matplotlib.pylab as plt\n\ndef f(t, y, r, M):\n    #   y = a list that contains the system state\n    #   t = the time for which the right-hand-side of the system equations\n    #       is to be calculated.\n    #   r = the specific growth rate\n    #   M = the carrying capacity\n    #\n    import numpy as np\n\n    #   Unpack the state of the system\n    y0 = y[0]  # cell density\n\n    #   Calculate the rates of change (the derivatives)\n    dy0dt = r * y0 * (1.0 - y0/M)\n    return [dy0dt]\n\n# Main Program\n\n# Read in data\ncols = np.loadtxt('PA01_SuspCell_0p25PerCentGlucose_5-3-2017.txt', skiprows=6)\ntimeData = cols[:, 0]\nODData = cols[:, 1]\n\n# Define the initial conditions\nyi = [0.074]\n\n# Define the time grid\nt = np.linspace(0, 415, 200)\n\n# Define the model parameters\nr = 0.014\nM = 1.25\np = (r, M)\n\n# Solve the DE\nsol = si.solve_ivp(f, (0, 415), yi, t_eval=t, args=p)\nys = sol.y[0]\n\n# Plot the theory and data\nplt.plot(t, ys, color='g', label='Model')\nplt.plot(timeData, ODData, linestyle='', marker='d',\n         markersize=5.0, color='blue', label='Data')\nplt.xlabel('t [min]')\nplt.ylabel('OD')\nplt.yscale('log')\nplt.title('PA01 Growth: Comparison with Logistics Growth Model',\n          fontsize=12)\nplt.legend()\nplt.savefig('PA01_LogisticsGrowth_ModelAndData.png', dpi=300)\nplt.show()\n\n\nFigure 11: :Code for the logistics growth model calculation and data comparison.\n\n\n\n\n\n\n\n\n\nFigure 12: Comparison of logistics growth model with PA01 data.\n\n\n\nReport on the model\nWe used two different dynamical systems models to describe the PA01 bacteria growing in a glucose medium. The exponential growth model described by Equation 13 did not compare well with the available data over the time period in the data set, as can be seen in Figure 10. The logistics model given by Equation 15 described the available data well, as seen in Figure 12. The model parameter values that are appropriate for the PA01 strain of Pseudomonas aeruginosa grown in a 0.25% glucose minimal medium at 37 [C] are\n\\[\\begin{array}{l} r = 0.014\\left[{\\min}^{- 1}\\right] \\\\ M = 1.25\\left[\\text{OD units}\\right] \\\\  \\end{array}\\]\nMaintain the model\nIf we could obtain growth data over a longer period of time, then we would see the stationary phase give way to the death phase. We would then need to develop a more sophisticated model that could account for this phase. This could be the subject of a future research project.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#ch07-exercises:sec",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#ch07-exercises:sec",
    "title": "Dynamical Systems Modeling I",
    "section": "Exercises",
    "text": "Exercises\n1. A dynamical system is one that changes with ____.\n2. Select the statements that are true for a mathematical dynamical systems model.\n\nThe state of the system is described by a set of time-dependent variables.\nThe time rate of change of each state variable must be known.\nThe current state of the system does not depend on the past state.\nIt is a stochastic model.\n\n3. T/F: The solve_ivp function can solve a first-order differential equation using numerical methods.\n4. Calculate the integral of v(t) from t = 0 to t = 2 [s] where v(t) is shown in the figure below.\n\n5. Write a short Python program that will calculate the derivative of the function\n\\[f\\left(x\\right) = \\left(3x + 2x^3\\right)\\cos \\left(x\\right)\\]\nat \\(x=2\\). Use the cosine function in the Numpy module.\n6. Write a short Python program that will calculate the integral from \\(0 \\leq x \\leq 4\\) of the following function\n\\[f\\left(x\\right) = \\left(3x + 2x^3\\right)\\cos \\left(x\\right)\\]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#ch07-program-modification-problems:sec",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#ch07-program-modification-problems:sec",
    "title": "Dynamical Systems Modeling I",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. Your goal is to use a numerical solution to an exponential growth model to simulate bacteria growth in an unconstrained environment (plenty of food) and find the growth rate parameter for Escherichia coli grown in CSHA media. Start with the code in Ch7ProgModProb1.py . Add a section that reads in the growth data in BacterialGrowthData.txt. Make sure you read in the column with the CSHA optical density measurement. Calculate the exponential growth model values for the optical density over the same time period as the data. Plot the data on the same graph. Change the value of the growth rate parameter and make the theory fit the data as best as you can.\nYour plot should have the following features:\n\nThe theoretical (exponential growth model) values should be plotted with a solid green line.\nThe data points should be plotted using a filled circle as the marker. Make the color red and the size 8.\nAdd an appropriate title.\nSave the graph as a png file.\n\n2. Your goal is to use a numerical solution to a logistics growth model to simulate bacteria growth in a constrained environment (limitation in food) and find the growth rate parameter and carrying capacity for Vibrio natriegens grown in TSB media. Start with the code in Ch7ProgModProb2.py .\n\nChange the import data section that reads in the growth data in V_natriegensGrowthData.txt. Make sure you read in the column with the TSB optical density measurement.\nChange the function \\(f\\left(t,y,r\\right)\\) to implement the logistics model rate equation.\nChange the initial condition.\nChange the model parameter tuple p so that it contains both the growth rate r and the carrying capacity M.\nChange the value of the growth rate parameter and carrying capacity and make the theory fit the data as best as you can.\nCreate a plot of both theory and data on the same graph. Your plot should have the following features:\n\nThe theoretical (logistics model) values should be plotted with a solid green line.\nThe data points should be plotted using a triangle as the marker. Make the color red and the size 8.\nSave the graph as a png file.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#ch07-program-development-problems:sec",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#ch07-program-development-problems:sec",
    "title": "Dynamical Systems Modeling I",
    "section": "Program Development Problems",
    "text": "Program Development Problems\n1. Develop an argument that the numerical solution of a dynamical system model that we are using is valid. This will involve choosing a specific model for which we know the exact solution. The exponential growth model would be one choice. Next, create a program that solves the model numerically, add a function that calculates the exact solution, and then create a table that compares the numerical and the exact values for 10 values of the independent variable. Write a brief essay that summarizes your evidence that the numerical solution method is valid.\n2. Solve the following first-order differential equation with the given initial condition by developing a Python program that can solve the equation numerically.\n\\[\\frac{dy\\left(t\\right)}{dt} = \\frac{\\left(e^{rt}- 2y\\left(t\\right)\\right)}{\\left(1 + y^2\\left(t\\right)\\right)}\\text{,}y\\left(0\\right) = 0\\]\nYour program should make a plot of the solution for \\(0 \\leq t \\leq 5\\) and for r1 = 0.1 and r2 = 0.5 . The plot should have a solid blue continuous line for the model solution with r1 and a solid red line for the model solution with r2 . Add appropriate axis titles, a legend, and a chart title (y(t) versus t).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#references",
    "href": "chapters/Ch07/Ch07_DynamicalSystemsModeling1.html#references",
    "title": "Dynamical Systems Modeling I",
    "section": "References",
    "text": "References\n\nDiggle, S. P., & Whiteley, M. (2020). Microbe Profile: Pseudomonas aeruginosa: opportunistic pathogen and lab rat. Microbiology, 166(1), 30–33. https://doi.org/10.1099/mic.0.000860\nHardy, S. P. (2002). Chapter 2: Bacterial Growth. In Human Microbiology. Taylor & Francis.\nIserles, A. (2009). A first course in the numerical analysis of differential equations (2nd ed., Vol. 1–1 online resource (xviii, 459 pages) : illustrations). Cambridge University Press; WorldCat.org. http://www.books24x7.com/marc.asp?bookid=30922\nThe SciPy community. (2022a). scipy.integrate.quad—SciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html\nThe SciPy Community. (2022). scipy.integrate.solve_ivp—SciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\nThe SciPy community. (2022b). scipy.misc.derivative—SciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.derivative.html\n\n\n\n\n\nDiggle, S. P., & Whiteley, M. (2020). Microbe Profile: Pseudomonas aeruginosa: Opportunistic pathogen and lab rat. Microbiology, 166(1), 30–33. https://doi.org/10.1099/mic.0.000860\n\n\nHardy, S. P. (2002). Chapter 2: Bacterial Growth. In Human Microbiology. Taylor & Francis.\n\n\nIserles, A. (2009). A first course in the numerical analysis of differential equations (2nd ed., 1–1 online resource (xviii, 459 pages) : illustrations). Cambridge University Press. http://www.books24x7.com/marc.asp?bookid=30922\n\n\nThe SciPy community. (2022a). Scipy.integrate.quad — SciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html\n\n\nThe SciPy Community. (2022). Scipy.integrate.solve_ivp — SciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\n\n\nThe SciPy community. (2022b). Scipy.misc.derivative — SciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.derivative.html",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Dynamical Systems Modeling I</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html",
    "title": "Dynamical Systems Modeling II",
    "section": "",
    "text": "Motivating Problem: The Zombie Apocalypse\nChapter 7 introduced the concept of a dynamical system, a type of deterministic mathematical model with behavior determined by a first-order differential equation, the rate equation for the state variable. This chapter will expand the type of model that we can study to include more than one state variable. One consequence of this generalization is that we will develop the capability to solve problems based on a Newton’s second law analysis of a system. This will open up significant areas of physics and engineering to us.\nZombies are a fixture of modern popular culture. Wikipedia currently lists 588 movies with a zombie theme (Wikipedia Contributors, 2022). If we add in all of the television series, comics, novels, short stories, and electronic games, the list of zombie-themed entertainment titles would undoubtedly be in the thousands. Even the Center for Disease Control offers a pamphlet on preparing for a zombie pandemic (Centers for Disease Control and Prevention (U.S.) & Office of Public Health Preparedness and Response, 2011).\nThe first Hollywood box-office hit with a zombie theme was White Zombie, released in 1932 and starring Bela Lugosi, of Dracula fame, as Voodou master “Murder” Legendre, who kills and resurrects people as zombies using a potion (Kay & Brugués, 2012). The zombies in this film are mindless beasts controlled by their maker, not the brain-eating, decayed flesh monstrosities of more modern productions.\nThe 1968 film Night of the Living Dead defined critical elements of the modern zombie genre: normal humans become infected from the bite of a zombie, an infected person dies and becomes reanimated with an appetite for human flesh, and a zombie can be killed with a shot to the base of the skull or by fire. Night of the Living Dead did not use the term zombie for the reanimated, flesh-eating wanderers. These creatures were called ghouls in the movie.\nThe modern zombie story views the condition as an infectious disease spread through close contact with uninfected people. Typically, the infection is incredibly successful at spreading through the human population, leaving the world with a huge number of roaming, flesh-eating creatures in the midst of a dwindling number of humans. fig-Figure8ZombiePandemic shows one depiction of such a pandemic, as visualized by an artist at the U.S. Centers for Disease Control (Centers for Disease Control and Prevention (U.S.) & Office of Public Health Preparedness and Response, 2011). Our modeling problem is to understand the conditions for which the zombie infection can spread so as to essentially wipe out the human population. A related question is, what are the conditions that will allow humans to make a comeback?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#motivating-problem-the-zombie-apocalypse",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#motivating-problem-the-zombie-apocalypse",
    "title": "Dynamical Systems Modeling II",
    "section": "",
    "text": "Figure 1: The zombie pandemic, as pictured by the CDC (Centers for Disease Control and Prevention (U.S.) & Office of Public Health Preparedness and Response, 2011).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#compartmental-models",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#compartmental-models",
    "title": "Dynamical Systems Modeling II",
    "section": "Compartmental Models",
    "text": "Compartmental Models\nCompartmental models are a class of mathematical model for which the system under investigation is assumed to be composed of populations that can exist in one or more states or compartments. Each compartment can be described by one state variable and flows can occur between the compartments. In addition to flows between compartments, other processes that affect the population in a compartment can be included, such as birth and death events.\nCompartmental models have become useful in many areas of science and engineering including chemical engineering, ecology, environmental engineering, epidemiology, pharmacokinetics, and physiology. To introduce the concept, we will focus on developing a compartmental model of a chemostat, a type of bioreactor used in microbiology research and in bioengineering applications.\nA chemostat provides a continuous supply of microorganisms using constant and reproducible growth conditions. This allows the microorganisms to be used in research or industrial applications under predictable and controllable conditions. Figure 2 shows the conceptual physical structure of a chemostat.\n\n\n\n\n\n\nFigure 2: Physical structure of a simple chemostat.\n\n\n\nWe can start constructing a mathematical model of this device defining important variables or parameters that describe the system.\n\n\n\nTable 1: Chemostat model variables.\n\n\n\n\n\n\n\n\n\n\n\nVariable\nSymbol\nUnits\nUnits Example\n\n\n\n\n\n\n\n\nConcentration of bacteria\n\n\nin the culture chamber\n\n\n\n\nN\ncells/volume\ncells/ml\n\n\n\n\n\n\nNutrient concentration\n\n\nin the culture chamber\n\n\n\n\nC\nmass/volume\ng/ml\n\n\n\n\n\n\nNutrient concentration\n\n\nin the nutrient reservoir\n\n\n\n\nC0\nmass/volume\ng/ml\n\n\nVolume of the culture chamber\nV\nvolume\nml\n\n\nNutrient inflow and effluent outflow rate\nF\nvolume/time\nml/s\n\n\n\n\n\n\nWe will make some assumptions about our system to keep our model relatively simple.\n\nThe nutrient reservoir will always supply nutrient at the fixed concentration C0.\nThe nutrient inflow rate will always equal the outgoing effluent rate, F. This will keep the volume of the culture chamber constant.\nThe culture chamber is well mixed, so the bacteria and nutrient concentrations are constant throughout.\n\nWith these assumptions we can focus our attention on the culture chamber containing both the bacteria and the nutrient. Our system can be modeled conceptually by two compartments: a bacteria compartment and a nutrient compartment. Our conceptual compartmental model of the system is represented in Figure 3.\n\n\n\n\n\n\nFigure 3: Compartmental model of the system.\n\n\n\nTo define the dynamical system model we must specify rate equations for the two state variables, N and C. This will require some additional model parameters, defined in Table 2.\n\n\n\nTable 2: Chemostat model parameters.\n\n\n\n\n\nParameter\nSymbol\nUnits\n\n\n\n\nthe yield constant\nY\n(cells/volume)/(mass/volume)\n\n\nspecific growth rate\nK\n1/time\n\n\nmaximum specific growth rate\n\\(K_{max}\\)\n1/time\n\n\nsaturation constant\n\\(K_s\\)\nmass/volume\n\n\n\n\n\n\nThe rate equation for a state variable must contain terms corresponding to each arrow going into or out from the associated compartment in Figure 8.3. Following Leah Edelstein-Keshet, we will hypothesize the following rate equations (Edelstein-Keshet, 2005).\n\\[\\frac{dN}{dt} = K\\left(C\\right)N- \\frac{FN}{V} \\tag{1}\\]\n\\[\\frac{dC}{dt} = - \\frac{K\\left(C\\right)N}{Y}- \\frac{FC}{V} + \\frac{FC_0}{V} \\tag{2}\\]\nThe specific growth rate, K, is assumed to be a function of the nutrient concentration, C. The yield constant, Y, maximum specific growth rate, Kmax, and the saturation constant, Ks, will depend on the species of bacteria being modeled.\nWe must also hypothesize a model for the specific growth rate. A realistic model should show the growth rate reaching a maximum for large values of the nutrient concentration. A commonly used model is described by Michaelis-Menten kinetics equation (Edelstein-Keshet, 2005):\n\\[K\\left(C\\right) = \\frac{K_{\\max}C}{K_s + C} \\tag{3}\\]\nWith this choice for the growth kinetics model, the rate equations become\n\\[\\frac{dN}{dt} = \\left(\\frac{K_{\\max}C}{K_s + C}\\right)N- \\frac{FN}{V} \\tag{4}\\]\n\\[\\frac{dC}{dt} = - \\left(\\frac{K_{\\max}C}{K_s + C}\\right)\\frac{N}{Y}- \\frac{FC}{V} + \\frac{FC_0}{V} \\tag{5}\\]\nThis model has six parameters: Kmax, Ks, Y, V, F, C0. Exploring the behavior of the model can be complicated with so many parameters. Another complication that arises in performing numerical solutions of the model is that there can be a large range of numbers involved. Both of these complications can be mitigated to some extent by rewriting the equations in a dimensionless form. This can be done by writing the original variables N, C, and t as the product of a dimensionless variable and a dimensional number (Edelstein-Keshet, 2005).\n\\[\\begin{array}{l} N = N^* \\times \\widehat{N} \\\\ C = C^* \\times \\widehat{C} \\\\ t = t^* \\times \\widehat{t} \\\\  \\end{array} \\tag{6}\\]\nIn these definitions, \\(N^*\\), \\(C^*\\), and \\(t^*\\) are the new dimensionless variables and \\(\\widehat{N},\\widehat{C},\\text{ and }\\widehat{t}\\) are constants that contain dimensions. Our goal is to choose the values of these dimension-carrying constants in a way that reduces the number of model parameters in Equation 4 and Equation 5. Substituting the definitions from Equation 6 into Equation 4 and Equation 5 yields Equation 7 and Equation 8.\n\\[\\frac{dN^*}{dt^*} = \\widehat{t}K_{\\max}\\left(\\frac{C^*}{K_s/ \\widehat{C} + C^*}\\right)N^*- \\widehat{t}\\frac{FN^*}{V} \\tag{7}\\]\n\\[\\frac{dC^*}{dt^*} = - \\left(\\frac{\\widehat{t}K_{\\max}\\widehat{N}}{Y\\widehat{C}}\\right)\\left(\\frac{C^*}{K_s/ \\widehat{C} + C^*}\\right)N^*- \\widehat{t}\\frac{FC^*}{V} + \\widehat{t}\\frac{FC_0}{V\\widehat{C}} \\tag{8}\\]\nBy choosing the dimensional constants \\(\\widehat{N},\\widehat{C},\\text{ and }\\widehat{t}\\) appropriately, the number of independent model parameters can be reduced. The following choice yields two model parameters.\n\\[\\widehat{t} = \\frac{V}{F}\\text{ , }\\widehat{C} = K_s\\text{ , }\\widehat{N} = \\frac{YK_s}{\\widehat{t}K_{\\max}} \\tag{9}\\]\nTo facilitate performing a numerical solution of these equations to give N* and C* as functions of time, we will change the notation to the generic dynamical systems model notation.\n\\[\\begin{array}{l} N^*\\rightarrow y_0 \\\\ C^*\\rightarrow y_1 \\\\  \\end{array} \\tag{10}\\]\nMaking the substitutions defined in Equation 9 and the notation change defined by Equation 10 gives the final form of our dynamical systems model.\n\\[\\frac{dy_0}{dt} = a_1\\left(\\frac{y_1}{1 + y_1}\\right)y_0- y_0 \\tag{11}\\]\n\\[\\frac{dy_1}{dt} = - \\left(\\frac{y_1}{1 + y_1}\\right)y_0- y_1 + a_2 \\tag{12}\\]\nwhere\n\\[\\begin{array}{l} a_1 = \\widehat{t}K_{\\max} = \\frac{VK_{\\max}}{F} \\\\ \\\\ a_2 = \\frac{\\widehat{t}FC_0}{V\\widehat{C}} = \\frac{C_0}{K_s} \\\\  \\end{array} \\tag{13}\\]\nThe model parameters a1 and a2 are dimensionless.\nThe dynamical systems model defined by Equations (8.11) and (8.12) can be solved numerically by using the code template from Figure 7.7. Figure 4 shows the Figure 7.7 code adapted for the chemostat problem. Figure 5 shows the result of running the code. For these model parameter values, it takes about 40 dimensionless time units to achieve a stable steady-state production of bacteria.\n\n\n\n\"\"\"\nProgram: Chemostat Model\nAuthor: C.D. Wentworth\nVersion: 8.22.2022.1\nSummary:\n    This program implements a dynamical systems model of a\n    chemostat that used one growth-limiting nutrient and\n    produces one species of bacteria.\nVersion History:\n    8.22.2022.1: base\n\n\"\"\"\nimport scipy.integrate as si\nimport numpy as np\nimport matplotlib.pylab as plt\n\n# Create a function that defines the rhs of the differential equation system\n\ndef f(t, y, Kmax, Ks, Y, V, F, C0):\n    #   y = a list that contains the system state\n    #   t = the time for which the right-hand-side of the system equations\n    #       is to be calculated.\n    #   Kmax = maximum specific growth rate\n    #   Ks = saturation constant\n    #   Y = yield\n    #   V = volume\n    #   F = flow rate for nutrient and effluent\n    #   C0 = nutrient concentration in nutrient reservoir\n\n    #   Unpack the state of the system\n    y0 = y[0]  # N, density of bacteria\n    y1 = y[1]  # C, concentration of nutrient\n\n    #   Calculate the rates of change (the derivatives)\n    dy0dt = (Kmax*y1/(Ks + y1))*y0 - (F/V)*y0\n    dy1dt = -(Kmax*y1/(Ks + y1))*y0/Y - (F/V)*y1 + (F/V)*C0\n\n    return [dy0dt, dy1dt]\n\n\n# Main Program\n\n# Define the initial conditions\nyi = [1.0E7, 1.E-2]\n\n# Define the time grid\nti = 0.0\ntf = 2.0\nt = np.linspace(ti, tf, 5)\n\n# Define the parameter tuple\nKmax = 0.29     # [1/h]\nKs = 1.36E-2    # [mg/mL]\nY = 0.96        # dimensionless\nV = 300.        # [mL]\nF = 72          # [mL/h]\nC0 = 1.E-2      # [mg/mL]\np = (Kmax, Ks, Y, V, F, C0)\n\n# Solve the DE\nsol = si.solve_ivp(f, (ti, tf), yi, t_eval=t, args=p)\nN = sol.y[0]\nC = sol.y[1]\n\n# Plot the solution\nplt.plot(t, N, color='green', label='N')\nplt.plot(t, C, color='red', label='C')\nplt.xlabel('t')\nplt.ylabel('N , C')\nplt.legend()\nplt.savefig('chemostat.png')\nplt.show()\n\n\nFigure 4: :Adaptation of the dynamical systems code for the chemostat problem.\n\n\n\n\n\n\n\n\n\nFigure 5: The dimensionless cell density and nutrient concentration as functions of time.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#numerical-solution-of-2nd-order-differential-equations",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#numerical-solution-of-2nd-order-differential-equations",
    "title": "Dynamical Systems Modeling II",
    "section": "Numerical Solution of 2nd-Order Differential Equations",
    "text": "Numerical Solution of 2nd-Order Differential Equations\nMany scientific and engineering systems can be modeled with second-order differential equations. One reason this is the case is that Newton’s second law is really a second-order differential equation.\n\\[F_{net} = ma_x = m\\frac{d^2x}{dt^2} \\tag{14}\\]\nWe can solve such an equation numerically without being expert mathematicians by using our ability to solve a first-order equation numerically, as done in our dynamical systems models. We can make use of the dynamical systems approach to numerical solution by using a nice trick to turn a second-order differential equation into two first-order differential equations.\nThe key will be to define a new set of variables that produce a new model that is simply related to the old second-order differential equation model. We will learn how to define the new variables by considering a specific example. Equation 15 defines a second-order differential equation.\n\\[\\frac{d^2y\\left(t\\right)}{dt^2} + q\\left(t\\right)\\frac{dy\\left(t\\right)}{dt} = r\\left(t\\right) \\tag{15}\\]\nwhere we assume that the functions \\(q\\left(t\\right)\\) and \\(r\\left(t\\right)\\) are known. Define a new set of variables \\(y_0\\left(t\\right)\\) and \\(y_1\\left(t\\right)\\) as follows\n\\[\\begin{array}{left} y_0 = y \\\\ y_1 = \\frac{dy}{dt} \\\\  \\end{array} \\tag{16}\\]\nThe rate of change of \\(y_1\\left(t\\right)\\) can be obtained from the original second-order differential equation:\n\\[\\frac{d^2y\\left(t\\right)}{dt^2} = r\\left(t\\right)- q\\left(t\\right)\\frac{dy\\left(t\\right)}{dt}\\Rightarrow \\frac{dy_1\\left(t\\right)}{dt} = r\\left(t\\right)- q\\left(t\\right)y_1\\left(t\\right) \\tag{17}\\]\nThis is due to the second derivative of y being equal to the first derivative of y1. So, Equation 15 can be replaced by the following set of first-order differential equations:\n\\[\\begin{array}{left} \\frac{dy_0\\left(t\\right)}{dt} = y_1\\left(t\\right) \\\\ \\frac{dy_1\\left(t\\right)}{dt} = r- qy_1\\left(t\\right) \\\\  \\end{array} \\tag{18}\\]\nIf we solve this system numerically, then we will have also solved Equation 15 for y(t), since that is just the new variable y0.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#newtons-2nd-law-problems",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#newtons-2nd-law-problems",
    "title": "Dynamical Systems Modeling II",
    "section": "Newton’s 2nd Law Problems",
    "text": "Newton’s 2nd Law Problems\nLet’s look at performing a numerical solution to a specific problem: a mass attached to a spring. This is a good testing problem since it can be solved exactly without performing the numerical solution. This will allow us to verify our numerical approach.\nFigure 6 shows the scenario: a block of mass 0.15 [kg] is attached to a spring with spring constant of 20 [N/m]. The mass is stretched a distance x0 = 0.10 [m] and released from rest. The state variable x will be the position of the mass measured from the spring’s unstretched position.\n\n\n\n\n\n\nFigure 6: Mass attached to a spring and given an initial stretch.\n\n\n\nWe can create a model of the object’s motion by using Newton’s second law and Hooke’s law for the spring force, which is the only force in the x direction.\n\\[F_{net} = m\\frac{d^2x}{dt^2} \\tag{19}\\]\n\\[F_s = - kx \\tag{20}\\]\nCombining these equations leads to our model for x:\n\\[\\frac{d^2x\\left(t\\right)}{dt^2} = - \\frac{k}{m}x\\left(t\\right) \\tag{21}\\]\nNow we apply our trick to turn the second-order differential equation into two first-order equations. We define new state variables \\(y_0\\left(t\\right)\\) and \\(y_1\\left(t\\right)\\):\n\\[\\begin{array}{left} y_0 = x \\\\ y_1 = \\frac{dy_0}{dt} \\\\  \\end{array} \\tag{22}\\]\nThe rate equations for our new state variables are\n\\[\\begin{array}{left} \\frac{dy_0}{dt} = y_1 \\\\ \\frac{dy_1}{dt} = - \\frac{k}{m}y_0 = - \\frac{20\\left[N/ m\\right]}{0.15\\left[kg\\right]}y_0 \\\\  \\end{array} \\tag{23}\\]\nwith the initial conditions\n\\[y_0\\left(0\\right) = x_0 = 0.10\\left[m\\right]\\text{ , }y_1\\left(0\\right) = 0\\]\nThe model is now in a form that can be solved numerically using our Dynamical Systems Template adapted to this model. Figure 7 shows the code that will solve this model numerically. Figure 8 shows the graphical output produced by the code.\n\n\n\n\"\"\"\nProgram: Ideal Spring Simulation\nAuthor: C.D. Wentworth\nVersion: 2.20.2022.1\nSummary:\n    This program implements a dynamical systems model of the\n    one-dimensional ideal spring (Hooke's Law).\nVersion History:\n    2.20.2022.1: base\n\n    \n\"\"\"\n\nimport scipy.integrate as si\nimport numpy as np\nimport matplotlib.pylab as plt\n\n# Create a function that defines the rhs of the differential equation system\n\ndef f(t, y, m, k):\n    #   y = a list that contains the system state\n    #   t = the time for which the right-hand-side of the system equations\n    #       is to be calculated.\n    #   k = a parameter needed for the model - force constant\n    #   m = a paramteter needed for the model - mass\n\n#   Unpack the state of the system\n    y0 = y[0]  # x\n    y1 = y[1]  # vx\n\n#   Calculate the rates of change (the derivatives)\n    dy0dt = y1\n    dy1dt = -(k/m)*y0\n\n    return [dy0dt, dy1dt]\n\n# Main Program\n\n# Define the initial conditions\nyi = [0.10, 0.0]\n\n# Define the time grid\nti = 0.0\ntf = 2.0\nt = np.linspace(ti, tf, 100)\n\n# Define the parameter tuple\nm = 0.15  # mass in [kg]\nk = 20.0  # force constant in [N/m]\np = (m, k)\n    \n\n# Solve the DE\nsol = si.solve_ivp(f, (ti, tf), yi, t_eval=t, args=p)\nx = sol.y[0]\nvx = sol.y[1]\n\n\n# Plot the solution\nplt.plot(t, x, color='green', label='x')\nplt.xlabel('t [s]')\nplt.ylabel('x [m]')\nplt.savefig('idealSpring.png')\nplt.show()\n\n\nFigure 7: :Python code for solving the spring problem using the dynamical system numerical solution method.\n\n\n\n\n\n\n\n\n\nFigure 8: Graph produced by the spring program.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#computational-problem-solving-modeling-the-zombie-apocalypse",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#computational-problem-solving-modeling-the-zombie-apocalypse",
    "title": "Dynamical Systems Modeling II",
    "section": "Computational Problem Solving: Modeling the Zombie Apocalypse",
    "text": "Computational Problem Solving: Modeling the Zombie Apocalypse\nWe now return to the problem of modeling the Zombie Apocalypse introduced at the beginning of the chapter.\n\nAnalysis\nThe zombie problem we will model is one where it is an infectious disease that requires contact between a susceptible person and an undead individual. We will use a recently published academic study of this type of zombie by infectious disease scientists to help us develop a model (Munz et al., 2009). The population of humans and zombies is assumed to be composed of three compartments:\n\nSusceptibles (S)\nZombie (Z)\nRemoved (R)\n\nAssumptions we will make include\n\nThe susceptible population can die of natural causes.\nThe susceptible population can increase due to natural growth (birth).\nThe removed compartment contains humans who have died from natural causes and from fatal zombie encounters.\nMembers of the removed compartment can resurrect as zombies.\nThe zombie compartment can increase due to non-fatal susceptible-zombie interactions (infection) or from resurrection from the removed compartment.\n\nFigure 9 shows the compartmental model hypothesized by Munz, et al. (Munz et al., 2009). Table 3 lists the state variables and parameters used in the model.\n\n\n\n\n\n\nFigure 9: Compartmental model for the zombie disease.\n\n\n\n\n\n\nTable 3: Variables and model parameters for the SZR model.\n\n\n\n\n\n\n\n\n\nVariable or Model Parameter\nSymbol\n\n\n\n\nSusceptible Population\nS\n\n\nZombie Population\nZ\n\n\nRemoved Population\nR\n\n\nConstant Birth Rate for Susceptibles\nP\n\n\nNatural Death rate for Susceptibles\nd\n\n\nRate at which Susceptible-Zombie encounters produce Zombies\nb\n\n\nRate at which Susceptible-Zombie encounters produce dead Zombies\na\n\n\nRate at which Removed individuals resurrect as Zombies\nr\n\n\n\n\n\n\n\n\nDesign\nDefining the dynamical systems model for our zombie infection requires hypothesizing rate equations for each of the state variables. The compartmental model diagram shown in Figure 9 suggest the following rate equations.\n\\[\\frac{dS}{dt} = P- bSZ- dS  \\tag{24}\\]\n\\[\\frac{dZ}{dt} = bSZ + rR- aSZ \\tag{25}\\]\n\\[\\frac{dR}{dt} = dS + aSZ- rR \\tag{26}\\]\nWe can use the dynamical systems template from Figure 7.7 to perform a numerical solution of this system. The code implementation will be facilitated by making the following notation change.\n\\[\\begin{array}{l} S\\rightarrow y_0 \\\\ Z\\rightarrow y_1 \\\\ R\\rightarrow y_2 \\\\  \\end{array} \\tag{27}\\]\nThe rate equations Equation 24 - Equation 26 become\n\\[\\frac{dy_0}{dt} = P- by_0y_1- dy_0 \\tag{28}\\]\n\\[\\frac{dy_1}{dt} = by_0y_1 + ry_2- ay_0y_1 \\tag{29}\\]\n\\[\\frac{dy_2}{dt} = dy_0 + ay_0y_1- ry_2 \\tag{30}\\]\n\n\nImplementation\nPerforming a numerical solution for the model described by Equation 28 - Equation 30 is straightforward. We must add one more rate calculation in the Python f function and pass the required model parameters. The revised code is in Figure 10 and in the code file SZRModel.py. The units for the compartment populations is arbitrary. The initial conditions must specify a nonzero number for the zombie compartment for there to be any infection activity.\n\n\n\n\"\"\"\nProgram: SZR Model\nAuthor: C.D. Wentworth\nVersion: 8.28.2022.1\nSummary:\n    This program implements a dynamical systems model of a\n    zombie infection based on a three compartment model.\nVersion History:\n    8.28.2022.1: base\n\n\"\"\"\nimport scipy.integrate as si\nimport numpy as np\nimport matplotlib.pylab as plt\n\n# Create a function that defines the rhs of the differential equation system\n\ndef f(t, y, P, b, d, a, r):\n    #   y = a list that contains the system state\n    #   t = the time for which the right-hand-side of the system equations\n    #       is to be calculated.\n    #   a1 = a parameter needed for the model\n    #   a2 = a paramteter needed for the model\n\n    #   Unpack the state of the system\n    y0 = y[0]  # S\n    y1 = y[1]  # Z\n    y2 = y[2]  # R\n\n    #   Calculate the rates of change (the derivatives)\n    dy0dt = P - b*y0*y1 - d*y0\n    dy1dt = b*y0*y1 + r*y2 - a*y0*y1\n    dy2dt = d*y0 + a*y0*y1 - r*y2\n\n    return [dy0dt, dy1dt, dy2dt]\n\n\n# Main Program\n\n# Define the initial conditions\nyi = [100, 0.1, 0.0]\n\n# Define the time grid\nti = 0.0\ntf = 30.0\nt = np.linspace(ti, tf, 100)\n\n# Define the parameter tuple\nP = 0.1\nb = 9.5e-3\nd = 1.e-4\na = 5e-3\nr = 1.e-4\np = (P, b, d, a, r)\n\n# Solve the DE\nsol = si.solve_ivp(f, (ti, tf), yi, t_eval=t, args=p)\nS = sol.y[0]\nZ = sol.y[1]\nR = sol.y[2]\n\n# Plot the solution\nplt.plot(t, S, color='green', label='S')\nplt.plot(t, Z, color='red', linewidth=3, label='Z')\nplt.plot(t, R, color='blue', linestyle='--', label='R')\nplt.xlabel('t')\nplt.ylabel('S , Z , R')\nplt.legend()\nplt.savefig('SZRModel.png')\nplt.show()\n\n\nFigure 10: :Code for the SZR model.\n\n\n\n\n\nTesting\nWhen the code in Figure 10 is executed with the model parameter choices given in lines 49-53 and with the initial conditions in line 41, the result is shown in Figure 11. We see that the susceptible population (uninfected humans) eventually goes to a small number close to zero and the number of zombies and removed become constant. This behavior is consistent with many zombie movies and television shows, which tend to show zombies wiping out most of the human population. This provides some evidence that our model and numerical implementation of its solution are correct.\n\n\n\n\n\n\nFigure 11: Result of running the SZR model code.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#exercises",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#exercises",
    "title": "Dynamical Systems Modeling II",
    "section": "Exercises",
    "text": "Exercises\n1. True/False: The compartments that are used in a compartmental model must correspond to actual physical containers.\n2. True/False: A Newton’s second law problem cannot be solved numerically using the dynamical systems template developed in Chapter 7 since Newton’s second law yields a second-order differential equation rather than just a first-order equation. (Explain your answer.)\n3. Replace the following second-order differential equation with two first-order equations.\n\\[\\frac{d^2x}{dt^2} + at^2\\frac{dx}{dt} = e^{- bt}\\]\n4. A chemostat is used to provide a continuous supply of Pseudomonas aeruginosa bacteria for a research project. The following parameters are used for modeling the chemostat (Robinson et al., 1984):\n\\[\\begin{array}{l} K_{\\max} = 0.40\\left[\\text{h}^{\\text{-1}}\\right] \\\\ K_s = 2.0 \\times 10^{- 3}\\left[\\frac{mg}{mL}\\right] \\\\ Y = 0.30\\left[\\frac{\\text{mg cell}}{\\text{mg Gl}}\\right] \\\\ V = 500.\\left[\\text{mL}\\right] \\\\ F = 75\\left[\\frac{\\text{mL}}{\\text{h}}\\right] \\\\ C_0 = 1.0 \\times 10^{- 2}\\left[\\frac{\\text{mg}}{\\text{mL}}\\right] \\\\  \\end{array}\\]\nGlucose is used as the nutrient in this reactor. When the chemostat achieves steady-state, the dimensionless state variable values are\n\\[N* = 11.7\\text{ , }C* = 0.599\\]\nUsing the dimensional constants defined by Equation 9, find the actual steady-state values for the cell concentration, in (mg/mL), and the glucose concentration, in (mg/mL), in the chemostat vessel.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#program-modification-problems",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#program-modification-problems",
    "title": "Dynamical Systems Modeling II",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. Consider a large ball dropped from rest from a height. It will experience the force of gravity and an air drag force as it falls. The net force on the ball will be\n\\[F_{\\text{net}} =  - mg + kv_y^2\\]\nYou need to develop a model for the ball’s motion as it drops. After developing the equations describing the model, create a Python program that solves for the position of the ball as it drops. Use the following data:\nm = 0.220 [kg]\nk = 3.7x10-2[Ns2/m2]\ny(0) = 12 [m]\nThe program should create a graph of the ball’s position up to the time that it hits the ground. Also, include a calculation of the position as a function of time for the constant acceleration case (no air drag). You can start with the code in Figure 7, which is in the code file idealSpring.py.\n2. Consider the chemostat model in its dimensionless form, Equation 11 and Equation 12. The parameter a1 is easily changed by the person running the reactor by adjusting the flow rate, F. Using the chemostat code in chemostat_dimensionless.py, explore how changing the a1 parameter affects the steady-state concentration of bacteria, N*, and the time it takes to achieve the steady-state. Note that if a1 gets too low, corresponding to a high flow rate, the bacteria concentration goes down to a number close to zero, indicating the bacteria is getting washed out of the reactor.\nCreate a table of a1, steady-state value of N*, and time to steady-state columns. Put this table in a text file. Write a short program to create a plot of the steady-state value of N* versus a1. Write another program to create a plot of time to steady-state versus a1.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#program-development-problems",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#program-development-problems",
    "title": "Dynamical Systems Modeling II",
    "section": "Program Development Problems",
    "text": "Program Development Problems\n1. Develop a dynamical systems model for an object attached to a spring that also experiences a damping force from motion in a viscous liquid. The figure below shows the scenario.\n\n\n\n\n\n\nFigure 12: Damped oscillator set-up.\n\n\n\nAssume that the spring force is given by Hooke’s law.\n\\[F_s =  - ky\\left(t\\right)\\]\nAssume that the damping force is proportional to the object’s velocity.\n\\[F_d =  - cv_y\\]\nYou can ignore the gravitational force for this analysis. Use the following values for the model parameters.\n\\[\\begin{array}{l}\n    m = 0\\ldotp 150\\left[\\text{kg}\\right]   \\\\\n    k = 40\\ldotp 0\\left[\\text{N/m}\\right]   \\\\\n    c = 1\\ldotp 50\\left[\\text{Ns/m}\\right]  \n\\end{array}\\]\nFor the initial conditions, assume that the spring is stretched 15 [cm] and released from rest. This gives\n\\[\\begin{array}{cc}\n     & y\\left(0\\right) = 0.15\\left[\\text{m}\\right] \\\\\n     & v_y\\left(0\\right) = 0.0\\left[\\text{m/s}\\right]\n\\end{array}\\]\nYou should use Newton’s second law to find the differential equation for the object’s acceleration. Convert the 2nd order differential equation into two first-order equations. Perform a numerical solution of the two-state variable model. Create a plot of the object’s position as a function of time for \\(0 \\leq t \\leq 1.5\\left[\\text{s}\\right]\\). Properly label the graph.\n2. The SZR model introduced in Chapter 8 for modeling the zombie infection suggested that humans would always lose the battle and essentially become extinct. Zombie stories often will offer a little more hope for human survival. Can we create another model that might include this possibility? Munz, et al. say yes. They introduce another compartment, the infected population, I, and also allow that zombies can be cured of their disease. They hypothesize the following rate equations for the four compartments:\n\\[\\begin{array}{l}\n    \\frac{dS}{dt} = P- bSZ- dS + cZ      \\\\\n                                         \\\\\n    \\frac{dI}{dt} = bSZ- \\rho I- dI      \\\\\n                                         \\\\\n    \\frac{dZ}{dt} = \\rho I + rR- aSZ- cZ \\\\\n                                         \\\\\n    \\frac{dR}{dt} = dS + dI + aSZ- rR\n\\end{array}\\]\nDevelop a program that performs a numerical solution of this revised model, which we will call the SIZR model. Since the model has seven parameters \\((P, b, d, c, \\rho, r, c)\\), exploring its behavior is complicated. Start with a set of model parameters that are close to those used in the SZRmodel.py code shown in Figure 10. Assume that there is no cure so that c=0. The initial set of model parameters are\n\\[P = 0.1\\text{ , }b = 9.5e - 3\\text{ , }d = 1.e - 4\\text{ , }c = 0\\text{ , }\\rho  = 3.0e - 1\\text{ , }a = 5.0e - 3\\text{ , }r = 1.0e - 4\\]\nThe initial conditions are\n\\[S\\left(0\\right) = 100\\text{ , }I\\left(0\\right) = 0\\text{ , }Z\\left(0\\right) =0.1 \\text{ , }R\\left(0\\right) = 0\\]\nYou should find that humans, the S compartment, still get wiped out, but introducing the I compartment delays the time required. Next, explore the effect of a nonzero c parameter value. A good range to explore is \\(0 \\leq c \\leq 0.015\\). Calculate the compartment populations for \\(0 \\leq t \\leq 100\\).\nWrite an essay that describes the four steps in our problem-solving strategy. In the Analysis section, provide a figure that illustrates the relationships between the four compartments implied by the rate equations given above.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#references",
    "href": "chapters/Ch08/Ch08_DynamicalSystemsModelingII.html#references",
    "title": "Dynamical Systems Modeling II",
    "section": "References",
    "text": "References\n\nCenters for Disease Control and Prevention (U.S.) & Office of Public Health Preparedness and Response. (2011). Preparedness 101; zombie pandemic. https://stacks.cdc.gov/view/cdc/6023\nEdelstein-Keshet, L. (2005). Mathematical Models in Biology. Society for Industrial and Applied Mathematics. https://doi.org/10.1137/1.9780898719147\nKay, G., & Brugués, A. (2012). Zombie Movies: The Ultimate Guide (Second Edition, Second edition). Chicago Review Press.\nMunz, P., Hudea, I., Imad, J., & Smith, H. L. (2009). WHEN ZOMBIES ATTACK!: MATHEMATICAL MODELLING OF AN OUTBREAK OF ZOMBIE INFECTION. In J. M. Tchuenche & C. Chiyaka (Eds.), Infectious Disease Modelling Research Progress (pp. 133–150).\nRobinson, J. A., Trulear, M. G., & Characklis, W. G. (1984). Cellular reporoduction and extracellular polymer formation by Pseudomonas aeruginosa in continuous culture. Biotechnology and Bioengineering, 26(12), 1409–1417. https://doi.org/10.1002/bit.260261203\nWikipedia Contributors. (2022). List of zombie films. In Wikipedia. https://en.wikipedia.org/w/index.php?title=List_of_zombie_films&oldid=1104193295\n\n\n\n\n\nEdelstein-Keshet, L. (2005). Mathematical Models in Biology. Society for Industrial and Applied Mathematics. https://doi.org/10.1137/1.9780898719147\n\n\nMunz, P., Hudea, I., Imad, J., & Smith, H. L. (2009). WHEN ZOMBIES ATTACK!: MATHEMATICAL MODELLING OF AN OUTBREAK OF ZOMBIE INFECTION. In J. M. Tchuenche & C. Chiyaka (Eds.), Infectious Disease Modelling Research Progress (pp. 133–150).\n\n\nRobinson, J. A., Trulear, M. G., & Characklis, W. G. (1984). Cellular reporoduction and extracellular polymer formation by Pseudomonas aeruginosa in continuous culture. Biotechnology and Bioengineering, 26(12), 1409–1417. https://doi.org/10.1002/bit.260261203",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dynamical Systems Modeling II</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html",
    "title": "Stochastic Models and Simulations",
    "section": "",
    "text": "Motivating Problem: Comparing Betting Strategies at the Roulette Wheel\nOne way to categorize mathematical models of natural or engineered systems is to divide them into deterministic models or stochastic models. Deterministic models, such as the dynamical systems models we have considered previously, have no element of chance in their development. The exponential growth model for bacteria is an example. If we know how many bacteria are present at \\(t=0\\) and the growth rate r, then we can predict the number of bacteria precisely for \\(t&gt;0\\) . Using Newton’s Second Law to predict the trajectory of a ball given the physical forces on it is another example. There are no probabilities or uncertainties about our theoretical predications based on these models. Stochastic models, involve an element of probability or randomness in their predictions. Here is a more formal definition.\nStochastic or probabilistic models use random variables to describe the system. Values for the random variables are based on theoretical or empirical probability distributions.\nOne example of a system that is best modeled using a stochastic model is the diffusive motion of individual atoms in a gas, liquid, or solid material for which there will be a probabilistic element. Other examples would include a dynamical systems model for which the model parameters are not known precisely but take on values with some probability.\nIf we want to simulate the behavior of a stochastic model, then we must perform numerical experiments that use random numbers selected according to an appropriate probability distribution. Such simulations are called Monte Carlo simulations, which we will explore in section 9.1. Random walks are a specific kind of Monte Carlo simulation that can be useful for modeling many systems. Another category of model we will explore in this chapter is cellular automata models. This class of models is not always stochastic in nature, but often is, so we include it here.\nLet’s suppose you visit Las Vegas and want to play roulette. What kind of betting strategy should you employ so that you do not go broke? We can explore different strategies by using a computer simulation of a roulette wheel game. We want to develop a simulation for the American Roulette wheel shown in Figure 1. Roulette involves a long list of possible bets (Wikipedia Contributors, 2022), so we will use just a small subset of these and then explore some betting strategies such as the Martingale strategy or Anti-Martingale strategy.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html#motivating-problem-comparing-betting-strategies-at-the-roulette-wheel",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html#motivating-problem-comparing-betting-strategies-at-the-roulette-wheel",
    "title": "Stochastic Models and Simulations",
    "section": "",
    "text": "Figure 1: Roulette wheel in a casino for gambling entertainment. Photo by Derek Lynn on Unsplash(Derek Lynn, 2020).",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html#overview-of-monte-carlo-methods",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html#overview-of-monte-carlo-methods",
    "title": "Stochastic Models and Simulations",
    "section": "Overview of Monte Carlo Methods",
    "text": "Overview of Monte Carlo Methods\n\nDefinition\nStochastic models involve random variables. The behavior of the model will change depending on the specific values taken by the random variables in the model. Monte Carlo methods involve sampling the possible model behaviors from the set of all possible behaviors, which might by infinite, and then performing a statistical description of the behavior based on the set of samples. More succinctly, a Monte Carlo simulation involves repeated random sampling to explore the behavior of a system.\n\n\nGenerating Pseudorandom Numbers\nTo perform Monte Carlo simulations requires that computer programs have access to random numbers. The standard solution to this need is to actually use pseudorandom numbers, which are deterministically created lists of numbers that will pass a variety of statistical tests for lists of actual random numbers.\nThe pseudorandom number generators used by early computer programming languages used an algorithm known as a linear congruential generator. This algorithm is based on the following equation (Press et al., 1986).\n\\[I_j = \\left(aI_{j- 1} + c\\right)\\mathrm{mod}m\\]\nThe constants a, c, and m are chosen to yield acceptable statistical properties for the sequence \\(I_0,I_1,I_2,\\ldots\\)To get the sequence started, the user usually provides a seed number, I0.\nThere are recognized statistical problems with linear congruential generators if long sequences or subsets of sequences are required (Entacher, 1998). Modern numerical packages now use more sophisticated algorithms to produce pseudorandom number sequences including the Mersenne Twistor algorithm (Matsumoto & Nishimura, 1998) and the permuted congruential generator algorithm (O’Neill, 2014). To understand these more sophisticated algorithms requires the reader have more background in statistics and probability theory than this book assumes, so we will not discuss how they work.\nThe Python random module uses the Mersenne Twistor algorithm to generate pseudorandom numbers (Python Software Foundation, 2022). The numpy.random package uses the permuted congruential generator algorithm (NumPy Developers, 2022).\nThe following are the important functions from the random module that we use.\nrandom.seed(a=None)\nInitializes the random number generator. Any int can be used. If none is provided, then the system time is used. Using the same seed will generate the same sequence of pseudorandom numbers.\nrandom.randint(a, b)\nReturns a random integer N such that \\(a \\leq N \\leq b\\).\nrandom.random()\nReturns the next random floating point number in the range [0.0, 1.0).\nrandom.gauss(mu, sigma)\nReturns a random number selected from the normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation.\nThe following code is generally used to set up the random module for use in a program.\nimport random as rn\n# initialize the generator\nrn.seed(524287)\nIt is a good practice to explicitly set the seed so that a program gives reproducible results. This can be very helpful during the debugging phase of code development.\nNumpy has its own random submodule. In versions before 1.17, the use of the Numpy random functions proceeded in much the same way as with the Python random module.\nNumpy random module functions before Numpy version 1.17:\nnumpy.random.seed(a=None)\nInitializes the random number generator. Any int can be used for the value of a. If none is provided, then the system time is used. Using the same seed will generate the same sequence of pseudorandom numbers.\nnumpy.random.randint(a, b, size=None)\nReturns a random integer N such that \\(a \\leq N \\leq b\\). The size keyword argument can be provided a tuple that specifies the shape of a numpy array of random integers that will be returned.\nnumpy.random.random(size=None)\nReturns the next random floating point number in the range [0.0, 1.0). The size keyword argument can be provided a tuple that specifies the shape of a numpy array of random floats that will be returned.\nnumpy.random.normal(loc=0.0, scale=1.0, size=None)\nReturns a random number selected from the normal distribution, also called the Gaussian distribution. loc is the mean, and scale is the standard deviation. The size keyword argument can be provided a tuple that specifies the shape of a numpy array of random floats selected from the normal distribution that will be returned.\nStarting with Numpy version 1.17, while the functions listed above can still be used, the best use recommendation has changed. The goal of the new version usage is to avoid problems with the seed being unintentionally reset by complex codes. The new approach allows separate copies (instances, to use Object Oriented Programming language) of the random number generator to be created that are independent of random number generators used in other modules. The following code shows how to create a copy of the random number generator.\nrng = numpy.random.default_rng(seed=None)\nThe variable name rng will now refer to a separate copy of the numpy random module with scope restricted to the program unit in which it was defined. You can use any valid Python variable name instead of rng. If a seed number is not provided, then one generated from the computer operating system will be used.\nHere is an example of code in a Jupyter notebook that uses the new Numpy random number generator approach.\n\n\n\nCode segment in a Jupyter notebook for using the Numpy random number generator.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html#random-walks",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html#random-walks",
    "title": "Stochastic Models and Simulations",
    "section": "Random Walks",
    "text": "Random Walks\n\nDefinition\nA random walk is a process in which an object moves away from a starting position at random. Lattice random walks are a simple case of random walks where the object is assumed to move on a regular grid of sites. It is a series of steps taken in random directions. The steps can be considered to be taken in any kind of space that is of interest. In the simplest case, the walk starts at zero and then at each step a +1 or -1 is added to the current position to yield an updated position. The walk would be the list of integers giving the position at each time.\nMore generally, a random walk on a lattice envisions the walk occurring on a regular grid such as the one-dimensional grid shown in Figure 2. In a lattice random walk, each direction for taking a step is assigned a probability and at each time step the walker chooses a direction according to the assigned probability. Figure 2 shows one possible series of steps.\n\n\n\n\n\n\nFigure 2: Random walk on a one-dimensional lattice.\n\n\n\nA Monte Carlo simulation of a random walk will execute many separate walks and then perform statistical analyses of whatever property that is of interest.\n\n\nOne-dimensional Random Walk\nLet’s consider a simple situation that would not be described well by a deterministic model. Consider a bar with its entrance in a narrow alley. If someone exits the bar, then they can only move right, left, or stay in place. Now, imagine a man has been consuming alcoholic beverages in the bar for a couple of hours. Needless to say, he is rather intoxicated, so he decides to walk home (at least he knows not to drink and drive!). He leaves the bar, which means stepping into the alley where he can only move left or right. Given his level of intoxication, the man cannot think clearly or even walk in a straight line. He steps erratically left or right with no discernable pattern to his choice. His walk in the alley is random.\nWe will not be able to model this man’s walking behavior using a deterministic model, but we can still simulate the man’s motion using a stochastic model and look for possible patterns in his behavior. Models that simulate the behavior of a system based on an element of randomness are called Monte Carlo simulations. We will create a Monte Carlo simulation of the drunk man’s walking behavior called, appropriately enough, the random walk simulation. This type of model can be applied much more generally than simply describing the behavior of an intoxicated man, but this scenario is an easy one to visualize as we develop our understanding of stochastic simulations.\nRecall our general problem-solving strategy:\nAnalysis: Analyze the problem\nDesign: Describe the data and develop algorithms\nImplementation: Represent data using programming language data structures and implement the algorithms with specific programming language code\nTesting: Test and debug the code using test data\nLet’s analyze our problem: simulating the random walk of our intoxicated man. We note that the man can only move along the axis, so it is an inherently one-dimensional problem. The man will choose to take a step leftwards or rightwards with equal probability.\n\n\n\n\n\n\nFigure 3: Narrow alley for the drunk’s walk. The origin of the axis is at the door to the bar.\n\n\n\nNow we will move on to designing our model. We will assume the man moves on the x-axis, as shown in Figure 3. His position at a particular time t is given by his x-coordinate, x(t). We will make the following simplifying assumptions:\n\nThe man attempts a step at equal time intervals.\nThe man chooses to step left or right with equal probability, like a coin toss.\nAll steps have length of 1 spatial unit.\n\nData structures:\nN – total number of steps to simulate\ni – the particular step currently being considered\nxi – the position at step i\nx_list – a list containing the position at each step\nHere’s an initial pseudocode solution to the simulation:\n\nPROGRAM randomWalk1d\n    Initialize the drunk's position at the origin: xi = 0\n    Set up a list to contain the drunk’s position at each step:\n    defines x_list\n    # set up a loop to execute N steps\n    FOR i in the list (0,1,2,...N) DO\n        Generate a random step \n        Update xi\n        Add xi to x_list \n    ENDFOR\n    Create a graph of position as a function of time\nENDPROGRAM\n\nLet us take a more detailed look at the program step\nGenerate a random step\nWe will implement this step as a function named step(xi) that takes the current position xi and produces the next position, which is returned.\nHere is a pseudocode version of the step(xi) function.\n\nFUNCTION step\n    INPUT: xi\n    Choose a direction (left or right) at random\n    IF left THEN\n      xi = xi - 1\n    ELSE\n      xi = xi + 1\n    ENDIF\n    OUTPUT: xi\nENDFUNCTION\n\nWe will move on to the Implementation portion of our problem-solving strategy. Let us turn our attention to how we can generate random numbers in Python. The reality is that we cannot generate truly random numbers, but we can generate pseudorandom numbers that can pass tests for randomness as long as we do not try to generate too many of them.\nWe will use the Python random module to generate our pseudorandom numbers. We start our use of these functions with an import command:\nimport random as rn\nOne of the first steps in the main part of our program will be to set up the random number generator by providing a seed. We do this so that we can generate the same sequence of random numbers to aid in debugging the program.\nSo, how do we choose the left or right direction at random? We can use the random() function to generate a number between 0 and 1. If the number is less than 0.5 then we choose left for the direction. If the number is greater than or equal to 0.5 then we choose right for the direction. Here’s Python code for the step(xi) function:\ndef step(xi):\n    r = rn.random()\n    if r &lt; 0.5:\n        xi = xi -1\n    else:\n        xi = xi+1\n    return xi\nThis code assumes the random module was imported and renamed rn by the main program.\nA computer simulation of a random walk must assume a finite lattice size since the available memory for the simulation is finite. This fact means that we must decide how to handle the walker hitting a boundary. In the code being developed here, the step function must deal with the case of xi being on the boundary. There are two approaches to handling this situation. One is to assume reflective boundary conditions, which means that if the walker hits the boundary he just stays there. The other method is to use cyclic boundary conditions, which means that if the walker hits the boundary he actually goes to the other side, as if the x-axis wraps around on itself.\nLet’s implement the reflective boundary conditions. We need to define two more variables:\nlx – the lowest x value\nux – the highest x value\nHere is the revised step function:\ndef step(xi,lx,ux):\n    r = rn.random()\n    if r &lt; 0.5:\n        if xi &gt;lx:\n            xi = xi - 1\n    else:\n        if xi &lt; ux:\n            xi = xi + 1\n    return xi\nA complete code for performing this one-dimensional simulation is shown in Figure 4. The code is in the chapter file randomWalk1d.py. This code produces a plot of the position as a function of time (step number) shown in Figure 5. The mean and standard deviation of the position is also calculated in lines 41-43.\n\n\n\n\"\"\"\nProgram: 1-d Random Walk\nAuthor: C.D. Wentworth\nVersion: 9.23.2022.1\nSummary:\n        This program performs a 1-dimensional random\n        walk simulation.\nHistory:\n    9.23.2022.1: base\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport random as rn\n\ndef step(xi,lx,ux):\n    import random as rn\n    r = rn.random()\n    if r &lt; 0.5:\n        if xi &gt; lx:\n            xi = xi -1\n    else:\n        if xi &lt; ux:\n            xi = xi+1\n    return xi\n# Main Program\n\n# set up the grid\nlx = -100\nux = 100\n\n# set up random generator\nrn.seed(524287)\nN = 200\n\n# execute random walk\nxi = 0\nxlist = [xi]\nfor i in range(N):\n    xi=step(xi,lx,ux)\n    xlist.append(xi)\nxnp = np.array(xlist)\nxmean = xnp.mean()\nxsd = np.sqrt(xnp.var()/float(N-1))\n\n# create plot of x - t\nplt.plot(xlist)\nplt.xlabel('t [steps]', fontsize=14)\nplt.ylabel('x', fontsize=14)\nplt.title('Position - Time', fontsize=18)\nplt.savefig('randomwalk1d.png', dpi=300)\nplt.show()\n\n# print position\nprint('mean x = ',xmean,' sd = ',xsd)\nprint('final position x = ', xlist[-1])\n\n\nFigure 4: :Python code for the 1D random walk.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Plot of position versus time for one simulation.\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Distance-time for a one-dimensional random walk.\n\n\n\n\n\n\n\nAnother important random walk property to study is how the distance of the walker to the origin varies with time. For a one-dimensional random walk that starts at the origin, the distance to the origin is given by\n\\[D = \\left|x\\right|\\]\nFigure 6 shows the distance as a function of time for a one-dimensional random walk on a grid defined by \\(- 1000 &lt; x &lt; 1000\\).\nWhile the distance appears to increase with time, there is a significant amount of noise in this property. This is a typical result for any measured property in a stochastic simulation just as it is for a measurement taken in a real world experiment. To obtain a better picture of the distance as a function of time we should repeat the experiment, that is the simulation, many times and calculate the mean distance as a function of time where the mean is calculated from our sample of many simulations.\nThe key data structure for calculating the mean distance as a function of time is a numpy array that contains the distance to the origin at each time for each of the separate simulations. Table 1 shows the structure of this array.\n\n\n\nTable 1: Distance array. N = number of steps in a simulation. S = total number of simulations.\n\n\n\n\n\n\n\nD11\n\n\nD12\n\n\nD13\n\n\n…\n\n\nD1S\n\n\n\n\n\n\nD21\n\n\nD22\n\n\nD23\n\n\n…\n\n\nD2S\n\n\n\n\nD31\n\n\nD32\n\n\nD33\n\n\n…\n\n\nD3S\n\n\n\n\n . . .\n\n\n . . .\n\n\n . . .\n\n\n . . .\n\n\n . . .\n\n\n\n\nDN1\n\n\nDN2\n\n\nDN3\n\n\n…\n\n\nDNS\n\n\n\n\n\n\n\n\\[D_{tn} = \\text{distance at time }t\\text{ for simulation }n\\]\nThe mean distance at any particular time is calculated by averaging over all the columns of the row corresponding to the time of interest. Figure 7 shows the revised code that performs repetitions of the simulation and then calculates the mean distance as a function of time. Figure 8 shows a plot of the mean distance as a function of time (number of steps). Most of the random variation shown in Figure 6 has disappeared.\n\n\n\n\"\"\"\nProgram: 1-d Random Walk - Multi Sims Version\nAuthor: C.D. Wentworth\nVersion: 9.24.2022.1\nSummary:\n        This program performs a 1-dimensional random\n        walk simulation. It performs multiple simulations\n        and calculates the mean distance to the origin at each time.\nHistory:\n    9.24.2022.1: base\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport random as rn\n\n\ndef step(xi, lx, ux):\n    import random as rn\n    r = rn.random()\n    if r &lt; 0.5:\n        if xi &gt; lx:\n            xi = xi - 1\n    else:\n        if xi &lt; ux:\n            xi = xi + 1\n    return xi\n\n\n# Main Program\n\n# set up the grid\nlx = -1000\nux = 1000\n\n# set up random generator\nrn.seed(524287)\n\n# set up the simulations\nN = 500  # number of steps in a simulation\nS = 5000  # number of simulations\nD_array = np.empty((N + 1, S), dtype='float')  # distance storage\n\nfor s in range(S):\n    # execute random walk\n    x0 = 0\n    x = x0\n    D_array[0, s] = 0.0\n    for t in range(1, N + 1):\n        x = step(x, lx, ux)\n        D = np.abs((x - x0))\n        D_array[t, s] = D\n\n# calculate the mean distance at each time step and plot D-t\nDMean = np.mean(D_array, axis=1)\nplt.plot(DMean, linestyle='-')\nplt.xlabel('t [steps]', fontsize=14)\nplt.ylabel('D', fontsize=14)\ntitleString = 'D-t Mean of ' + str(S) + ' Simulations'\nplt.title(titleString, fontsize=18)\nplt.savefig('randomWalk1d_D-t_mean.png', dpi=300)\nplt.show()\n\n\nFigure 7: :Multi-simulation version of the one-dimensional random walk.\n\n\n\n\n\n\n\n\n\nFigure 8: Mean distance as a function of time from 5000 simulation repetitions.\n\n\n\n\n\nTwo-dimensional Random Walk\nLet’s give our intoxicated walker more room to roam around. We will place him in a large parking lot so that he can move about on a plane, a two-dimensional surface. We want to simulate his trajectory on the parking lot. Our model will be based on some simplifying assumptions, similar to the one-dimensional walk.\n\nThe man attempts a step at equal time intervals.\nThe man chooses to step north, south, east, or west with equal probability.\nAll steps have length of 1 spatial unit.\n\nWith these assumptions, our walker will roam about on a grid like chess pieces on a game board. The basic algorithm for performing the simulation will be the same as for the one-dimensional case. The major difference will be in the step function. It must now choose one of the four directions at random instead of either right or left. Here is a pseudocode version of the step function.\n\nFUNCTION step\n    INPUT: xi,yi\n    Pick a random number r, from (1,2,3,4)\n    IF r is 1 THEN\n        Step east by incrementing xi\n    ELIF r is 2 THEN\n        Step west by decreasing xi\n    ELIF r is 3 THEN\n        Step north by increasing yi\n    ELIF r is 4 THEN\n        Step south by decreasing yi\n    ENDIF\n    OUTPUT: xi,yi\nENDFUNCTION\n\nWe must implement boundary conditions since the simulated grid will be finite. This will require minimum and maximum values for both the x and y coordinates. These values will be defined using the variables lx,ux,ly,uy. Figure 9 gives the Python code for the two-dimensional step function with reflective boundaries. Figure 10 shows an example of the overall trajectory of this random walk.\n\n\n\n\"\"\"\nTitle: Random Walk in 2D: base\nAuthor: C.D. Wentworth\nversion: 3-21-2019.1\nSummary: This program performs a random walk on a\n         two-dimensional lattice. It uses reflective\n         boundary conditions.\nversion history:\n        3-21-2019.1: base\n\n\"\"\"\nimport matplotlib.pylab as plt\nimport numpy as np\nimport random as rn\nimport turtle as trt\n\n\ndef step(xi, yi, lx, ux, ly, uy):\n    import random as rn\n    r = rn.randint(1, 4)\n    if r == 1:\n        # go east\n        if xi &lt; ux:\n            xi = xi + 1\n    elif r == 2:\n        # go west\n        if xi &gt; lx:\n            xi = xi - 1\n    elif r == 3:\n        # go north\n        if yi &lt; uy:\n            yi = yi + 1\n    else:\n        # go south\n        if yi &gt; ly:\n            yi = yi - 1\n    return xi, yi\n\n\n# --Main Program\n# set up random generator\nrn.seed(42)\n\n# define the grid\nlx = -40\nux = 40\nly = -40\nuy = 40\n\n# set up the simulation\nN = 1000\nxi = 0\nyi = 0\nposition_array = np.zeros((N + 1, 2))\n\n# execute random walk\nfor i in range(1, N + 1):\n    xi, yi = step(xi, yi, lx, ux, ly, uy)\n    position_array[i, 0] = xi\n    position_array[i, 1] = yi\n\nx_array = position_array[:, 0]\ny_array = position_array[:, 1]\n\n# create plot\nx0 = x_array[0]  # initial x\ny0 = y_array[0]  # initial y\nxf = x_array[-1]  # final x\nyf = y_array[-1]  # final y\nplt.plot(x_array, y_array)\nplt.plot(x0, y0, linestyle='', marker='o', markersize=8,\n         markeredgecolor='green', markerfacecolor='green')\nplt.plot(xf, yf, linestyle='', marker='o', markersize=8,\n         markeredgecolor='red', markerfacecolor='red')\nplt.xlim(-20, 20)\nplt.ylim(-20, 20)\nplt.savefig('randomWalk2d.png', dpi=300)\nplt.show()\n\n\nFigure 9: :Code for random walk on a 2-d lattice.\n\n\n\n\n\n\n\n\n\nFigure 10: Trajectory of a random walk on a 2-d lattice. Green shows origin. Red shows final position.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html#cellular-automaton-model",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html#cellular-automaton-model",
    "title": "Stochastic Models and Simulations",
    "section": "Cellular Automaton Model",
    "text": "Cellular Automaton Model\nCellular automata can be considered as a particular abstract framework for describing the real world, that is, a modelling framework, or as a kind of mathematical object that can be used to build models or investigate computational problems (Berto & Tagliabue, 2022). We will start with a formal, mathematical definition of a cellular automaton. A cellular automaton model is defined as\n\na discrete lattice of sites or cells in d dimensions, L\noperating using discrete time steps\na discrete set of possible cell values, S\na defined neighborhood, N of each cell in L\na transition rule, \\(\\Phi\\), that specifies how the state of a cell will be updated depending on its current value and the values of sites in the neighborhood.\n\nWe will consider the cellular automaton to be the collection \\(〈L,S,N,\\Phi 〉\\). A specific example will be defined in the next section, which should make this definition less abstract. Cellular automata have been used to model\n\ncomputational machines\ngrowth of biological systems such as biofilms\nevolution of life\nphase transitions in magnetic materials\nurban development\n\nCellular automata are often used to show how complex patterns can be the result of simple rules governing the behavior of the system being considered.\n\nDeterministic Cellular Automata\nWe will define a simple one-dimensional cellular automaton. The lattice L is an infinite, one-dimensional set of cells, as shown in Figure 11.\n\n\n\n\n\n\nFigure 11: One-dimensional lattice of cells for a cellular automaton.\n\n\n\nThe possible cell values will be \\(S = \\left\\{0,1\\right\\}\\). We will visualize a cell with state 0 as white and state 1 as black. The neighborhood, N, of a cell will be defined as the nearest neighbors of the cell: the cell to the left and the cell to the right. A particular combination of neighbors and center will be symbolized by LCR.\nThe transition rule will be a new assignment of the C state based on the current value of the LCR combination. There are eight possible LCR combinations for this class of cellular automata, shown in Table 9.2. There are two possible new values for the C cell given a specific LCR combination. Therefore, there are 28 possible transition rules for this class of cellular automata.\nWe will enumerate each possibility by an integer from 1 to 256. The transition rule will be given by the binary representation of rule number given by the base 10 integer. For example, Rule 150 has the binary representation 10010110. Each of the eight digits in this representation gives the transition rule a specific LCR combination. Table 2 illustrates how this assignment can be made.\n\n\n\nTable 2: A specific transition rule (Rule 150) for the class of cellular automata being considered.\n\n\n\n\n\nL\nC\nR\nnew C\n\n\n\n\n1\n1\n1\n1\n\n\n1\n1\n0\n0\n\n\n1\n0\n1\n0\n\n\n1\n0\n0\n1\n\n\n0\n1\n1\n0\n\n\n0\n1\n0\n1\n\n\n0\n0\n1\n1\n\n\n0\n0\n0\n0\n\n\n\n\n\n\nNow we must construct a computer simulation of this simple cellular automaton model. We will base the code on one developed by Cyrille Rossant (Rossant, 2018).\n\n\n\nTable 3: Data structures required for the one-dimensional cellular automaton simulation.\n\n\n\n\n\n\n\n\n\n\nVariable\nType\nDescription\n\n\n\n\nsize\nint\nThe number of cells in the lattice.\n\n\nsteps\nint\nThe number of time steps to simulate.\n\n\nrule\nint\nThe state transition rule given as a decimal number.\n\n\nrule_b\nndarray\nThe state transition rule given as a binary number represented in a numpy array.\n\n\nx\nndarray\nA 2d numpy array where each row gives the state of the cellular automaton at a specific time. The array contains the entire simulated evolution of the automaton.\n\n\nLCR_array\nndarray\nEach column of the array gives the Left, Center, and Right state values for a particular cell in the automaton. Used in step function.\n\n\nxs\nndarray\nA 1-dim array that gives the cell states for each cell in the automaton at one time. Used in the step function.\n\n\n\n\n\n\nSince the cellular automaton is being simulated by a computer, the lattice used to define the automaton must by finite. This means we must specify how the neighbors are defined for the cells all the way on the left and all the way on the right of the lattice. We will use periodic boundary conditions. This means that for the cell all the way on the left, the left neighbor will be the cell all the way on the right of the lattice. For the cell all the way on the right, the right neighbor will be the cell all the way on the left of the lattice. Figure 12 shows the code contained in the file CA_sim.py for simulating the simple one-dimensional cellular automaton. Figure 13 shows the output from the simulation for a Rule 150 cellular automaton with an initial state comprised of one active cell in the middle of the lattice.\n\n\n\n\"\"\"\nProgram: 1-d Cellular Automaton Simulation\nAuthor: Based on code from Rossant, C. (2018).\n        IPython Interactive Computing and Visualization Cookbook—\n        Second Edition. Packt Publishing.\n        Revisions by C.D. Wentworth\nVersion: 9.29.2022.1\nSummary:\n        This program simulates a one-dimensional deterministic\n        cellular automaton.\nHistory:\n    9.29.2022.1: base\n\"\"\"\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nu = np.array([[4], [2], [1]])\n\ndef step(xs, rule_b):\n    \"\"\"\n    Compute a single state of an elementary cellular\n    automaton.\n    \"\"\"\n    # Define the array that gives the LCR state values\n    # for each cell.\n    LCR_array = np.vstack((np.roll(xs, 1), xs,\n                   np.roll(xs, -1))).astype(np.int8)\n    # We get the LCR pattern numbers between 0 and 7\n    # for each cell in the automaton.\n    z = np.sum(LCR_array * u, axis=0).astype(np.int8)\n    # We get the updated cell states given by the rule.\n    return rule_b[7 - z]\n\ndef generate(rule, size=100, steps=100):\n    \"\"\"\n    Simulate an elementary cellular automaton given\n    its rule (number between 0 and 255).\n    \"\"\"\n    # Compute the binary representation of the rule.\n    rule_b = np.array(\n        [int(_) for _ in np.binary_repr(rule, 8)],\n        dtype=np.int8)\n    x = np.zeros((steps, size), dtype=np.int8)\n    # Define the initial state\n    x[0, 50] = 1\n    # Apply the step function iteratively.\n    for i in range(steps - 1):\n        x[i + 1, :] = step(x[i, :], rule_b)\n    return x\n\n\n# Main Program\nrule = 150\nsize = 100\nsteps = 50\nx = generate(rule, size, steps)\nplt.matshow(x, cmap=plt.cm.binary)\ntitle_string = 'Rule ' + str(rule)\nplt.title(title_string, fontsize=18)\nfig_file = 'CA_rule' + str(rule) + '.png'\nplt.savefig(fig_file, dpi=300)\nplt.show()\n\n\nFigure 12: :One-dimensional cellular automaton simulation code.\n\n\n\n\n\n\n\n\n\nFigure 13: This figure shows the 1-d Rule 150 automaton simulated for 50 time steps.\n\n\n\n\n\nProbabilistic Cellular Automata\nThe cellular automata considered in the previous section are completely deterministic. Once the transition rule and initial state have been chosen the evolution of the lattice is determined. Repetition of the evolution will always yield the same result. We can introduce randomness in at least two ways:\n\ncreate a random initial state or\nestablish a transition rule that updates the state of a cell using the neighborhood state and then a new cell state chosen according to a probability distribution.\n\nProbabilistic cellular automata are usually defined using the second method of achieving randomness. We will not discuss coding of a probabilistic cellular automaton simulation here.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html#computational-problem-solving-comparing-betting-strategies-at-the-roulette-wheel",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html#computational-problem-solving-comparing-betting-strategies-at-the-roulette-wheel",
    "title": "Stochastic Models and Simulations",
    "section": "Computational Problem Solving: Comparing Betting Strategies at the Roulette Wheel",
    "text": "Computational Problem Solving: Comparing Betting Strategies at the Roulette Wheel\nWe began this chapter with the problem of comparing betting strategies when playing roulette. Let us return to that problem and develop a Monte Carlo simulation approach to solving the problem. We will consider playing American roulette and will restrict the betting types to a small subset of the possible ones.\n\nAnalysis\nAmerican roulette uses a wheel with 38 pockets that include both a 0 and a 00 pocket. The 0 and 00 pockets are green. The other pockets alternate between black and red. There are a large number of possible bets, so we will need to restrict the analysis to a small subset to facilitate the initial solution (Wikipedia Contributors, 2022). For this initial analysis, we will consider the following types of bets.\n\nStraight/Single: bet on a single number; 35:1 payout\nRed/Black: bet on either red or black; 1:1 payout\nGreen: bet on green; 17:1 payout\n\nEach pocket of the wheel has numerical value, including 00, and a color. Table 4 gives the sequence of the slots going clockwise around the wheel. We will assume that when the wheel spins, the ball has an equal chance of falling into any one of the 38 pockets. For this initial attempt at simulating roulette, we will assume that each play involves a constant bet and a choice betting type. A game will be defined as a series of plays. For a game, the series of plays will end when the players balance goes below zero or if the balance goes above a specified balance value. Our gambler will continue playing until either they run out of money or until they achieve a specified level of profit.\n\n\n\nTable 4: Layout of the American Roulette wheel, going clockwise.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npocket index\nvalue\ncolor\n\npocket index\nvalue\ncolor\n\n\n\n\n0\n0\ngreen\n\n19\n0\ngreen\n\n\n1\n28\nblack\n\n20\n27\nred\n\n\n2\n9\nred\n\n21\n10\nblack\n\n\n3\n26\nblack\n\n22\n25\nred\n\n\n4\n30\nred\n\n23\n39\nblack\n\n\n5\n11\nblack\n\n24\n12\nred\n\n\n6\n7\nred\n\n25\n8\nblack\n\n\n7\n20\nblack\n\n26\n19\nred\n\n\n8\n32\nred\n\n27\n31\nblack\n\n\n9\n17\nblack\n\n28\n18\nred\n\n\n10\n5\nred\n\n29\n6\nblack\n\n\n11\n22\nblack\n\n30\n21\nred\n\n\n12\n34\nred\n\n31\n33\nblack\n\n\n13\n15\nblack\n\n32\n16\nred\n\n\n14\n3\nred\n\n33\n4\nblack\n\n\n15\n24\nblack\n\n34\n23\nred\n\n\n16\n36\nred\n\n35\n35\nblack\n\n\n17\n13\nblack\n\n36\n14\nred\n\n\n18\n1\nred\n\n37\n2\nblack\n\n\n\n\n\n\n\n\nDesign\nLet us start the design of the algorithm by defining data structures that will be required. We will also create the roulette wheel data from Table 4 as columns in a tab-delimited text file. This file will be named wheel.txt. Table 5 gives a list of data structures that will be required for the roulette simulation.\n\n\n\nTable 5: Data structures for the roulette simulation.\n\n\n\n\n\n\n\n\n\n\nVariable\nType\nDescription\n\n\n\n\nbalance\nint\nThis contains the current balance value of the gambler’s purse.\n\n\nstop_balance\nint\nThe balance value that will stop the game. Assumed to be larger than the starting value\n\n\nbet_amount\nint\n\n\n\nbet_type\nstr\nSpecifies whether the gambler is betting on a color (‘black’, ‘red’, green’) or a specific value (‘0’, ‘1’, …, ‘00’)\n\n\nnumber_of_games\nint\nThe number of repeated games to play, which will create the Monte Carlo simulation sample.\n\n\nbet_types\ndictionary\nAssociates the payout value with a bet type.\n\n\ndf\npandas data frame\nContains the wheel information read in from the wheel.txt file.\n\n\nvalues\nlist\nContains all of the pocket values specified in the order found on the wheel going clockwise.\n\n\ncolors\nlist\nContains all of the pocket colors specified in the order found on the wheel going clockwise.\n\n\nbalance_series\nlist\nContains the balance value for each play in a game\n\n\nspin_value\nstr\nContains the pocket value after a spin of the wheel.\n\n\nspin_color\nstr\nContains the pocket color after a spin of the wheel.\n\n\n\n\n\n\nThe following gives a pseudocode version of the main program for the simulation.\n\nPROGRAM American_Roulette_Simulation-ConstantBetting\n    Specify gambler’s data (balance, stop_balance, bet_amount, \n                            bet_type, number_of_games)\n    Initialize the random number generator\n    Define the bet_types dictionary\n    Define the wheel variables (values, colors)\n    FOR g IN list_of_games DO\n        Play a game\n        Create a plot of the balance versus number of plays\n    ENDFOR\nENDPROGRAM\n\nThe Play a game line will require another function, which we name game_constant_bet, and this function will require another function called make_a_play.\n\nFUNCTION game_constant_bet\n    INPUT: balance, stop_balance, bet_amount, bet_type, bet_types,\n           values, colors\n    balance_series = [balance]\n    WHILE (balance &gt; 0) and (balance &lt; stop_balance) DO\n        balance = make_a_play(balance, bet_amount, bet_type,\n                              bet_types, values, colors)\n        balance_series.append(balance)\n    ENDWHILE\n    OUTPUT: balance_series\nENDFUNCTION\n\nThe function game_constant_bet requires another function make_play.\n\nFUNCTION make_a_play\n    INPUT: balance, bet_amount, bet_type, bet_types, values, colors\n    Perform a spin of the wheel (defines spin_value, spin_color)\n    IF bet_type == 'black'\n        IF spin_color == 'black'\n            balance = balance + bet_amount*bet_types['black']\n        ELSE\n            balance = balance - bet_amount\n        ENDIF\n    IF bet_type == 'red'\n        IF spin_color == 'red'\n            balance = balance + bet_amount*bet_types['red']\n        ELSE\n            balance = balance - bet_amount\n        ENDIF\n    IF bet_type == 'green'\n        IF spin_color == 'green'\n            balance = balance + bet_amount*bet_types['green']\n        ELSE\n            balance = balance - bet_amount\n        ENDIF\n    ELSE\n        IF spin_value == bet_type\n            balance = balance + bet_amount*bet_types['value']\n        ELSE\n            balance = balance - bet_amount\n        ENDIF\n    ENDIF\n    OUTPUT: balance\nENDFUNCTION\n\nThe function make_a_play requires a function which we call spin.\n\nFUNCTION spin\n    INPUT: values, colors\n    Get a random integer between 0 and 37 (defines i)\n    value = values(i)\n    color = colors(i)\n    OUTPUT: value, color\nENDFUNCTION\n\nThese pseudocode versions of the algorithm should allow an easy translation into Python code.\n\n\nImplementation\nFigure 14 gives the Python implementation of the American Roulette with Constant Bet simulation.\n\n\n\n\"\"\"\nProgram: American Roulette with Constant Bet\nAuthor: C.D. Wentworth\nVersion: 9.1.2022.1\nSummary:\n        This program performs a Monte Carlo simulation of the\n        American roulette game using a constant bet strategy based\n        either color choice or specific value choice.\nHistory:\n    9.1.2022.1: base\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\ndef spin(values,colors):\n#    i = rn.randint(0, 37)\n    i = rng.integers(low=0 , high=37 )\n    value = values[i]\n    color = colors[i]\n    return value, color\n\ndef make_a_play(balance, bet_amount, bet_type, bet_types,\n                values, colors):\n    spin_value, spin_color = spin(values, colors)\n    if bet_type == 'black':\n        if spin_color == 'black':\n            balance = balance + bet_amount*bet_types['black']\n        else:\n            balance = balance - bet_amount\n    if bet_type == 'red':\n        if spin_color == 'red':\n            balance = balance + bet_amount*bet_types['red']\n        else:\n            balance = balance - bet_amount\n    if bet_type == 'green':\n        if spin_color == 'green':\n            balance = balance + bet_amount*bet_types['green']\n        else:\n            balance = balance - bet_amount\n    else:\n        if spin_value == bet_type:\n            balance = balance + bet_amount*bet_types['value']\n        else:\n            balance = balance - bet_amount\n    return balance\n\ndef game_constant_bet(balance, stop_balance, bet_amount, bet_type,\n                      bet_types, values, colors):\n    balance_series = [balance]\n    while (balance &gt; 0) and (balance &lt; stop_balance):\n        balance = make_a_play(balance, bet_amount, bet_type, bet_types,\n                  values, colors)\n        balance_series.append(balance)\n    return balance_series\n\n\n# Main Program\n# Initialize gambler's data\nbalance = 1000\nstop_balance = 1200\nbet_amount = 10\nbet_type = 'green'\nnumber_of_games = 100\n\n# Set up the numpy random number generator\nrng = np.random.default_rng(314159)\n\n# Initialize the bet type payout\nbet_types = {'black': 1, 'red': 1, 'green': 17, 'value': 35  }\n\n# Read in the wheel data\ndf = pd.read_csv('wheel.txt', sep='\\t', header=1,\n       dtype={'index':int, 'value':'string', 'color':'string'})\n\n# Convert pandas columns to tuples\nvalues = tuple(df['value'].tolist())\ncolors = tuple(df['color'].tolist())\n\nfor g in range(number_of_games):\n    balance_series = game_constant_bet(balance, stop_balance,\n                                       bet_amount, bet_type,\n                                       bet_types, values, colors)\n    plt.plot(balance_series)\nplt.xlabel('play')\nplt.ylabel('balance')\ntitle_string = 'Constant Bet Strategy: ' + bet_type\nplt.title(title_string, fontsize=18)\nplt.savefig('roulette_constantBet_value15_1200.png', dpi=300)\nplt.show()\n\n\nFigure 14: Python implementation of the American Roulette with Constant Bet simulation.\n\n\n\nThis code is in the file roulette_constantBet.py.\n\n\nTesting\nA good strategy for testing the program is to create a series of small programs that test the individual functions. If the individual functions work as expected, then you will have some significant evidence that the overall program works as expected. Figure 15 shows a short code that will test the spin function. A write statement is inserted into the function to write out some test data to a file. Table 6 shows data generated by this code. The rows are compared with Table 4. After the test, lines 10-13 are deleted.\n\n\n\nTable 6: Generated test data from the spin function. A comparison is made with Table 9.4 to determine correctness.\n\n\n\n\n\npocket index\npocket value\npocket color\ncorrect entry\n\n\n\n\n29\n6\nblack\nyes\n\n\n4\n30\nred\nyes\n\n\n14\n3\nred\nyes\n\n\n32\n16\nred\nyes\n\n\n31\n33\nblack\nyes\n\n\n28\n18\nred\nyes\n\n\n29\n6\nblack\nyes\n\n\n2\n9\nred\nyes\n\n\n27\n31\nblack\nyes\n\n\n3\n26\nblack\nyes\n\n\n\n\n\n\n\n\n\n\"\"\"\nProgram: Test Spin Function\nAuthor: C.D. Wentworth\nVersion: 9.1.2022.1\nSummary:\n        This program tests the spin function from the American\n        Roulette Constant Bet simulation.\nHistory:\n    9.1.2022.1: base\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport random as rn\n\ndef spin(values,colors):\n    i = rn.randint(0, 37)\n    value = values[i]\n    color = colors[i]\n    # write test data\n    write_string = str(i) + '\\t' + value + '\\t' + color + '\\n'\n    out_file.write(write_string)\n    # end write test data\n    return value, color\n\n\n# Main Program\nnumber_of_tests = 10\n\n# Initialize random number generator\nrn.seed(524287)\n\n# Read in the wheel data\ndf = pd.read_csv('wheel.txt', sep='\\t', header=1,\n       dtype={'index':int, 'value':'string', 'color':'string'})\n\n# Convert pandas columns to tuples\nvalues = tuple(df['value'].tolist())\ncolors = tuple(df['color'].tolist())\n\nout_file = open('testSpinFunctionData.txt', 'w')\nfor t in range(number_of_tests):\n    value, color = spin(values, colors)\nout_file.close()\n\n\nFigure 15: Short program to test the spin function.\n\n\n\nSimilar short programs can be used to test the other functions.\nTo obtain some initial data for the constant bet strategy we will choose the following initial gambler’s data:\nbalance = 1000\nstop_balance = 1200\nbet_amount = 10\nnumber_of_games = 100\nWe will run the simulation for the following bet types: ‘red’, ‘green’, ‘15’, and compare the plots of balance as a function of play. Figure 16 – Figure 18 show the results of these simulations. Each simulation is for 100 games. Based on this data, we can say that if you want to make any money on this game with the constant bet strategy you must bet on one of higher payout choices (green or a specific value). Be forewarned though; you will also have a significant chance of quickly losing your purse.\n\n\n\n\n\n\nFigure 16: Monte Carlo simulation of roulette with a constant bet on red strategy.\n\n\n\n\n\n\n\n\n\nFigure 17: Monte Carlo simulation of roulette with a constant bet on green strategy.\n\n\n\n\n\n\n\n\n\nFigure 18: Monte Carlo simulation of roulette with a constant bet on the value 15 strategy.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html#program-modification-problems",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html#program-modification-problems",
    "title": "Stochastic Models and Simulations",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. Starting with the two-dimension random walk code in Ch9ProgModProb1.py, write a program that calculates the distance to the origin of the walker as a function of step number (time). The program should produce a plot of D versus t. You can remove the plot of the actual walk.\n2. Starting with the one-dimensional cellular automata simulation code in Ch9ProgModProb2.py, create a program that assigns an initial state of 1 to several randomly selected cells. Explore the differences in the patterns obtained between the revised program and the original one with initial state of 1 in the middle of the lattice.\n3. Starting with the American Roulette with Constant Bet code in Ch9ProgModProb3.py, create a program to calculate the proportion of games that end with a profit for the bet on green and bet on a specific value bet types.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html#program-development-problems",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html#program-development-problems",
    "title": "Stochastic Models and Simulations",
    "section": "Program Development Problems",
    "text": "Program Development Problems\n1. Create a program that simulates a two-dimensional random walk repeatedly and calculates the mean distance at each step over the sample of repeated simulations and produces a plot of mean distance as a function of step. The sample size should be large enough so that you get a smooth curve.\n2. Create a program that will simulate the American roulette game using the Martingale strategy that involves doubling the bet value after losing a play. Explore the behavior of this strategy for the different betting types considered in the program American Roulette with Constant Bet contained in the file roulette_constantBet.py.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch09/Ch09_StochasticSimulations.html#references",
    "href": "chapters/Ch09/Ch09_StochasticSimulations.html#references",
    "title": "Stochastic Models and Simulations",
    "section": "References",
    "text": "References\n\nBerto, F., & Tagliabue, J. (2022). Cellular Automata. In E. N. Zalta (Ed.), The Stanford Encyclopedia of Philosophy (Spring 2022). Metaphysics Research Lab, Stanford University. https://plato.stanford.edu/archives/spr2022/entries/cellular-automata/\nDerek Lynn. (2020). Roulette wheel in a casino for gambling entertainment [Photograph]. https://unsplash.com/photos/mD1V-eS1Wb4\nEntacher, K. (1998). Bad subsequences of well-known linear congruential pseudorandom number generators. ACM Transactions on Modeling and Computer Simulation, 8(1), 61–70. https://doi.org/10.1145/272991.273009\nMatsumoto, M., & Nishimura, T. (1998). Mersenne twister: A 623-dimensionally equidistributed uniform pseudo-random number generator. ACM Transactions on Modeling and Computer Simulation, 8(1), 3–30. https://doi.org/10.1145/272991.272995\nNumPy Developers. (2022). Random Generator—NumPy v1.23 Manual. https://numpy.org/doc/stable/reference/random/generator.html\nO’Neill, M. E. (2014). PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation (HMC-CS-2014-0905). Harvey Mudd College Computer Science Department. https://www.pcg-random.org/paper.html\nPress, W. H., Teukolsky, S. A., Vetterling, W. T., & Flannery, B. P. (1986). Numerical Recipes: The Art of Scientific Computing. http://www.librarything.com/work/249712/book/225760462\nPython Software Foundation. (2022). Random—Generate pseudo-random numbers—Python 3.10.7 documentation. https://docs.python.org/3/library/random.html\nRossant, C. (2018). IPython Interactive Computing and Visualization Cookbook—Second Edition. Packt. https://www.packtpub.com/product/ipython-interactive-computing-and-visualization-cookbook-second-edition/9781785888632\nRoulette. (2022). In Wikipedia. https://en.wikipedia.org/w/index.php?title=Roulette&oldid=1106799426\n\n\n\n\n\nBerto, F., & Tagliabue, J. (2022). Cellular Automata. In E. N. Zalta (Ed.), The Stanford Encyclopedia of Philosophy (Spring 2022). Metaphysics Research Lab, Stanford University. https://plato.stanford.edu/archives/spr2022/entries/cellular-automata/\n\n\nDerek Lynn. (2020). Roulette wheel in a casino for gambling entertainment [Graphic]. https://unsplash.com/photos/mD1V-eS1Wb4\n\n\nEntacher, K. (1998). Bad subsequences of well-known linear congruential pseudorandom number generators. ACM Transactions on Modeling and Computer Simulation, 8(1), 61–70. https://doi.org/10.1145/272991.273009\n\n\nMatsumoto, M., & Nishimura, T. (1998). Mersenne twister: A 623-dimensionally equidistributed uniform pseudo-random number generator. ACM Transactions on Modeling and Computer Simulation, 8(1), 3–30. https://doi.org/10.1145/272991.272995\n\n\nNumPy Developers. (2022). Random Generator — NumPy v1.23 Manual. https://numpy.org/doc/stable/reference/random/generator.html\n\n\nO’Neill, M. E. (2014). PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation (HMC-CS-2014-0905). Harvey Mudd College Computer Science Department. https://www.pcg-random.org/paper.html\n\n\nPress, W. H., Teukolsky, S. A., Vetterling, W. T., & Flannery, B. P. (1986). Numerical Recipes: The Art of Scientific Computing. http://www.librarything.com/work/249712/book/225760462\n\n\nPython Software Foundation. (2022). Random — Generate pseudo-random numbers — Python 3.10.7 documentation. https://docs.python.org/3/library/random.html\n\n\nRossant, C. (2018). IPython Interactive Computing and Visualization Cookbook - Second Edition. Packt Publishing. https://www.amazon.com/IPython-Interactive-Computing-Visualization-Cookbook/dp/1785888633/?_encoding=UTF8&pd_rd_w=FBfz6&content-id=amzn1.sym.8cf3b8ef-6a74-45dc-9f0d-6409eb523603&pf_rd_p=8cf3b8ef-6a74-45dc-9f0d-6409eb523603&pf_rd_r=TRGJAR2YQD6W7JS9CKZM&pd_rd_wg=7PdJO&pd_rd_r=361fb22c-bf7e-483b-993c-a686ae72e5c8&ref_=pd_gw_ci_mcx_mi\n\n\nWikipedia Contributors. (2022). Roulette. In Wikipedia. https://en.wikipedia.org/w/index.php?title=Roulette&oldid=1106799426",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Stochastic Models and Simulations</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "",
    "text": "Motivating Problem: Damped Spring {\n@ shows the setup for a physics experiment involving a mass m (= 0.550 [kg]) attached to a spring. The spring is stretched from rest and released. Position data collected by a motion detector is shown in Figure 2. Since the data shows significant damping, the situation will require more than simply the ideal force law (Hooke’s Law: \\(F=-ky\\)) to understand. By adding a drag force proportional to velocity, \\(-bv_y\\), an appropriate model can be constructed. The solution to Newton’s 2nd Law is discussed in most general physics textbooks and yields (Knight, 2016)\n\\[\\begin{array}{l} y\\left(t\\right) = Ae^{- bt/ 2m}\\cos \\left(\\omega t + \\phi_0\\right) \\\\ \\\\ \\omega  = \\sqrt{\\omega_0^2- \\frac{b^2}{4m^2}}\\text{ , }\\omega_0 = \\sqrt{\\frac{k}{m}} \\\\  \\end{array} \\tag{1}\\]\nIn Equation Equation 1, \\(y(t)\\) is the position measured with respect to the mass’s equilibrium position.\nOur computational problem will be to choose the best-fit values for the model parameters, A, b, and k, so that the model equation fits the provided data.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#motivating-problem-damped-spring",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#motivating-problem-damped-spring",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "",
    "text": "Figure 1: Spring experiment setup.\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Data from the spring experiment.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#ch10-introduction:sec",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#ch10-introduction:sec",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "Introduction",
    "text": "Introduction\nIn Chapter 7 on dynamical systems, we considered a mathematical model for the growth of bacteria. Our development of the model was guided by some actual data on growth for a couple of different species of bacteria. When we needed to choose values for parameters that appeared in the model, we used a trial-and-error method to choose values that gave a good fit of the model to the available data. We need a more statistically sophisticated method that can choose best-fit values and estimate how much experimental uncertainty the values have.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#the-method-of-least-squares",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#the-method-of-least-squares",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "The Method of Least Squares",
    "text": "The Method of Least Squares\n\nDefinition\nWhile there are several methods that can be used to statistically estimate best-fit model parameter values, we will use the method of least squares. It is a widely used method and usually a good first-choice for the models we often encounter in science and engineering. We will introduce the basic framework with some formal definitions and then move on to implementing the method computationally, first with simple linear models and then with more complex non-linear models.\nLet us assume that we have a model with independent variables \\(\\mathbf x = \\left(x_1,x_2,\\ldots  ,x_v\\right)\\), a set of model parameters \\(\\mathbf p = \\left(p_1,p_2,\\ldots ,p_m\\right)\\), and the model function \\(f\\left(\\mathbf x;\\mathbf p\\right)\\) that determines the dependent variable y.\n\\[y = f\\left(\\mathbf x;\\mathbf p\\right) \\tag{2}\\]\nIn the simplest case there will be just one independent variable, but the method works for more complex cases.\nSuppose we have performed an experiment that produced n data points\n\\[\\left(\\mathbf x_1,y_1\\right),\\ldots ,\\left(\\mathbf x_n,y_n\\right)\\]\nNext, we define a function called the Least Square Estimator, \\(L\\left(\\textbf{p}\\right)\\), by the equation\n\\[L\\left(\\mathbf p\\right) = \\sum_{i = 1}^n\\left(y_i- f\\left(\\mathbf x_i;\\mathbf p\\right)\\right)^2 \\tag{3}\\]\nNote that L is a function of the model parameters. The least squares method for data fitting involves choosing the model parameter values p that minimize the function L.\n\n\nLinear Regression\nIf we are using a simple linear model\n\\[y=ax+b \\tag{4}\\]\nthen statisticians have derived closed-form formulae for the best-fit slope, a, and intercept, b. They use the calculus principle that necessary conditions for a function to be a minimum are that first partial derivatives with respect to the independent variables must be zero. This is symbolized by\n\\[\\begin{array}{left} \\frac{\\partial L\\left(a,b\\right)}{\\partial a} = 0 \\\\ \\frac{\\partial L\\left(a,b\\right)}{\\partial b} = 0 \\\\  \\end{array} \\tag{5}\\]\nThese equations can be solved for the best-fit values of a and b. We will not work through the calculus or give the explicit formulae. You will learn to do that in a more advanced statistics course (Akritas, 2018). Instead, we will learn how to implement the linear least squares technique numerically, letting the computer do all of the work.\nWe will use a specific example to learn this technique. Consider a rigid container with some air in it. We measure the pressure of this gas as the temperature is varied. The volume is held constant. Figure 3 shows some of the data from the file GasData.txt.\n\n\n\n\n\n\nFigure 3: Pressure data as a function of temperature for a fixed volume of gas.\n\n\n\nVisual inspection of the figure suggests that a linear model should fit this data rather well. We will use the method of least squares, linear regression version, to find the best fit slope and intercept. We expect the data presented in Figure 3 to fit the following model equation:\n\\[P=aT+b \\tag{6}\\]\nMinimizing the Least Squares Estimator function involves minimizing the vertical distance between the data points and the theoretical model value. Consider Figure 4, which shows our data with a linear model drawn as a red line.\n\n\n\n\n\n\nFigure 4: Gas data with a linear model.\n\n\n\nThe method of least-squares will find the model parameters, the slope and intercept in this case, that will minimize the sum of the squares of the residuals. The model line shown in Figure 4 was produced by the linear regression formulae from the least squares method. It is hard to imagine a different line that would come closer to the data points.\nWe will make use of a Python library function that will apply the linear regression formulae to the data set and give the user the optimized slope and intercept. The function is from the scipy.stats library. It is the scipy.stats.linregress() function (The SciPy Community, 2022b).\nSyntax:\nout = scipy.stats.linregress(x,y)\nx = a list with the independent variable values\ny = a list with corresponding dependent variable values\nThe function returns a list-like data structure, called out above, containing the following values (data type in parentheses)\nslope : (float) slope of the regression line\nintercept : (float) intercept of the regression line\nr-value : (float) correlation coefficient\np-value : (float) two-sided p-value for a hypothesis test whose null hypothesis is that the slope is zero.\nstderr : (float) Standard error of the slope estimate\nThe following lines of code will retrieve all of these values from the variable out.\nslope = out[0]\nintercept = out[1]\nrvalue = out[2]\npvalue = out[3]\nse = out[4]\nFigure 5 shows a Python script that will apply the linregress function to the gas data. The code produces the following text output.\nslope= 0.0948\nintercept= 0.8803\nrvalue= 0.9986\npvalue= 1.32e-20\nse= 0.0013\nFigure 4 shows the graph produced by the code.\n\n\n\n\"\"\"\nProgram: Gas Data Fit\nAuthor: C.D. Wentworth\nVersion: 3-20-2017.1\nSummary:\n    This program reads in pressure-temperature data and fits\n    the data to a linear model using the scipy.stats.linregress()\n    function.\nVersion History:\n    3-20-2017.1: Base\n\n\"\"\"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.stats as ss\n# import data\ncols = np.loadtxt('GasData.txt',  skiprows=3)\ntData = cols[:, 0]\nPData = cols[:, 1]\n# Fit data to linear model\nout = ss.linregress(tData, PData)\nslope = out[0]\nintercept = out[1]\nrvalue = out[2]\npvalue = out[3]\nse = out[4]\nprint('slope= ', format(slope,'7.4f'))\nprint('intercept= ',format(intercept,'7.4f'))\nprint('rvalue= ',format(rvalue,'7.4f'))\nprint('pvalue= ',format(pvalue,'7.2e'))\nprint('se= ',format(se,'7.4f'))\n# Plot the data\nplt.plot(tData,PData,linestyle='',marker='d',label='Data')\nplt.xlabel('T [K]')\nplt.ylabel('P [kPa]')\nplt.xlim((0,500))\n\n# Plot the theory\ntTheory = np.linspace(0,500,100)\nPTheory = slope*tTheory + intercept\nplt.plot(tTheory,PTheory,label='Model')\nplt.legend()\nplt.savefig('GasData.png') \n\n\nFigure 5: :Python code to fit gas data to linear model.\n\n\n\n\n\nNon-linear Regression\n\nCase 1: Model Function is Known Explicitly\nThe method of least-squares can also be applied to fitting data to a non-linear model, such as the exponential growth model. Figure 6 shows the growth of bacteria.\n\n\n\n\n\n\nFigure 6: Growth of bacteria during the exponential growth phase.\n\n\n\nIt is clear that a linear model will not describe this data. Indeed we know that an exponential growth model should work well. Equation 7 gives the equation defining this model.\n\\[N\\left(t\\right) = N_0e^{rt} \\tag{7}\\]\nThe complication with applying the method of least-squares to a non-linear model is that we do not have explicit formulae for the model parameters, N0 and r, as we did in the linear case. The computational problem is to perform a search through the parameter space to find the values that will minimize the Least Square Estimator good starting place. We will make use of a Python library function that will search for the model parameter values that minimize the Least Squares Estimator function given an initial starting guess for the values. The function is from the scipy.optimize library. It is the scipy.optimize.curve_fit()function (The SciPy Community, 2022a). Here is the basic syntax for using the curve_fit function.\npopt, pcov = scipy.optimize.curve_fit( f , tData , fData , p )\nf is the callable function that calculates the theoretical value for the independent variable t. It must be in the form\n\\(f(t, parameters)\\)\nwhere t, the independent variable must be listed first, and parameters must be listed separately, not in a tuple variable.\ntData and fData are lists containing independent and dependent variable values for data points.\npopt will be the list of optimized parameter values.\npcov contains the covariance matrix. It gives information about the uncertainty in the parameter estimates. Explicit values for statistical uncertainty are obtained using\npsterr = np.sqrt(np.diag(pcov))\npsterr is a list containing the standard error of each parameter estimate in the same order as in popt.\nFigure 7 shows a program that can fit the exponential growth model of Equation 7 to the data of Figure 6.\n\n\n\n\"\"\"\nProgram: Non-linear Least Squares - Explicit Function Form\nAuthor: C.D. Wentworth\nVersion: 10.25.2022.1\nSummary: This program reads in bacterial growth data and fits\nthe data to the non-linear exponential growth model using the  \nscipy.optimize.curve_fit() function. \nVersion History:\n  3.28.2017.1: base version\n  10.25.2022.1: added parameter uncertainty calculation\n\n\"\"\"\n\nimport numpy as np\nimport matplotlib.pylab as plt\nimport scipy.optimize as so\n\ndef N(t,N0,r):\n    tmp = N0*np.exp(r*t)\n    return tmp\n\n# import data\ncols = np.loadtxt('BacterialGrowthData.txt', skiprows=9)\ntData = cols[:, 0]\nODData = cols[:, 1]\n\n# Define initial guess for model parameters\nN0 = 0.021\nr = 0.020\np = N0,r\n\n# Fit data to exponential growth model\npopt,pcov = so.curve_fit(N, tData, ODData, p)\np_stderr = np.sqrt(np.diag(pcov))\n\n# Plot the data\nplt.plot(tData, ODData, linestyle='', marker='d',\n         markersize=10.0, label='Data')\n\n# Plot the theory\nN0,r = popt\ndN0 = p_stderr[0]\ndr = p_stderr[1]\ntTheory = np.linspace(0, 300, 50) \nODTheory = N(tTheory,N0,r)\nplt.plot(tTheory, ODTheory, label='Theory')\nplt.xlabel('t [min]')\nplt.ylabel('OD [rel]')\nplt.legend()\nplt.savefig('bacterialGrowthFitData.png')\n\n# print out best-fit model parameters\nprint('N0 = ', format(N0,'6.4f'), '+-', format(dN0,'7.4f'))\nprint('r = ', format(r,'6.4f'), '+-', format(dr,'6.4f'))\n\n\nFigure 7: :Python program for using the curve_fit function.\n\n\n\nFigure 6 shows the model fit to the data. The program will produce the following printed output giving least squares fit model parameter values and uncertainties.\nN0 = 0.0112 +- 0.0007\nr = 0.0133 +- 0.0002\n\n\nCase 2: Model Function value must be obtained by numerical integration\nWe have worked with mathematical models where the actual model function describing how the dependent variable depends on the independent variable is not known, but instead the model is defined by an ordinary differential equation or system of such equations. We learned how to numerically integrate the differential equation to obtain model values for selected independent variable values.\nHow can we use the least squares technique for finding best-fit model parameters for this case where we must integrate a differential equation to get model values? We can still use the curve_fit function to perform the least squares minimization search, but we must do some extra work to give it the required callable model function. The function will be defined to have the form\nf(t, parameters)\nbut inside this function definition we use the numerical integration function scipy.integrate.solve_ivp and integrate the differential equation from the initial independent variable value up to the desired independent variable value. The function will return just this last calculated dependent variable value, as required by the curve_fit function.\nWe will continue to work with the exponential growth model as a test case for working through the details of this method. The rate equation for the population function \\(y\\left(t\\right)\\) is\n\\[\\frac{dy}{dt} = ry\\left(t\\right) \\tag{8}\\]\nand there is a known initial condition of the form\n\\[y\\left(0\\right) = y_i\\]\nLet’s start with the basic setup required to use solv_ivp to integrate the exponential growth rate equation that we discussed back in Chapter 7. We must define a Python function f that calculates the rate of change of the state variable y for an array of independent variable values t.\nimport scipy.integrate as si\nimport numpy as np\nimport matplotlib.pylab as plt\nimport scipy.optimize as so\n\n# Create a function that defines the rhs of the differential equation system\n\ndef f(t,y,r):\n#   y = a list that contains the system state\n#   t = the time for which the right-hand-side of the system equations\n#       is to be calculated.  \n#   r = a parameter needed for the model\n#\n#   Unpack the state of the system\n    y0 = y[0] # value of the state variable y at t\n#   Calculate the rates of change (the derivatives)\n    dy0dt = r*y0\n    return [dy0dt]\nNext, we will define the callable model function required by curve_fit that will use the numerical integration method to calculate the value of the state variable y. We will name this function yf.\ndef yf(t,yi,r):\n    p = r,\n    yv = []\n    y_0 = [yi]\n    for tt in t:\n        if np.abs(tt)&lt;1.e-5:\n            yvt = yi\n        else:\n            ta = np.linspace(0,tt,10)\n            # Solve the DE\n            sol = si.solve_ivp(f,(0,tt),y_0,t_eval=ta,args=p)\n            yvt = sol.y[0][-1]\n        yv.append(yvt)\n    return yv\nThe callable function yf for the curve_fit function is designed to accept an array of independent variable values in the t array, which will normally be a numpy array. This requires the for loop to calculate the model function value by numerical integration for each value in t. The Python code that implements this idea is shown in Figure 8 and is contained in the file expGrowthModelNonLinRegNumSol.py.\n\n\n\n\"\"\"\nProgram Name: Non-linear Least Squares - \n              Numerical Integration Form\nAuthor: C.D. Wentworth\nversion: 10.27.2022.1\nSummary: This program reads in bacterial growth data and fits\n         the data to the non-linear exponential growth model \n         using the scipy.optimize.curve_fit() function. This\n         version uses a numerical integration method for \n         calculating values of the model function.\nHistory:\n         3.17.2020.1: base\n         10.27.2022.1: changed variable names\n\n\"\"\"\n \nimport scipy.integrate as si\nimport numpy as np\nimport matplotlib.pylab as plt\nimport scipy.optimize as so\n\n# Create a function that defines the rhs of the differential equation system\n\ndef f(t,y,r):\n#   y = a list that contains the system state\n#   t = the time for which the right-hand-side of the system equations\n#       is to be calculated.\n#   r = a parameter needed for the model\n#\n\n#   Unpack the state of the system\n    y0 = y[0] # value of the state variable at t\n\n#   Calculate the rates of change (the derivatives)\n    dy0dt = r*y0\n\n    return [dy0dt]\n\ndef yf(t,yi,r):\n    p = r,\n    yv = []\n    y_0 = [yi]\n    for tt in t:\n        if np.abs(tt)&lt;1.e-5:\n            yvt = yi\n        else:\n            ta = np.linspace(0,tt,10)\n            # Solve the DE\n            sol = si.solve_ivp(f,(0,tt),y_0,t_eval=ta,args=p)\n            yvt = sol.y[0][-1]\n        yv.append(yvt)\n    return yv\n    \n# Main Program\n\n# Read in data\ncols = np.loadtxt('BacterialGrowthData.txt',skiprows=9)\ntd = cols[:,0]\nOD = cols[:,1]\n\n# Define initial guess for model parameters\nyi = 0.022\nr = 0.02\np = (yi,r)\n\npopt,pcov = so.curve_fit(yf,td,OD,p)\np_stderr = np.sqrt(np.diag(pcov))\n\n# Calculate theoretical values\n# Define the time grid\nta = np.linspace(0,300,200)\nyi,r = popt\ndyi = p_stderr[0]\ndr = p_stderr[1]\n\nyTheory = yf(ta,yi,r)\n\n# print out best-fit model parameters\nprint('yi = ', format(yi,'6.4f'), '+-', format(dyi,'7.4f'))\nprint('r = ', format(r,'6.4f'), '+-', format(dr,'6.4f'))\n\n# Plot the solution\nplt.plot(td,OD,linestyle='',marker='o',markersize=10.0, \n         label='Data')\nplt.plot(ta,yTheory,color='g', label='Theory')\nplt.legend()\nplt.xlabel('t [min]')\nplt.ylabel('OD [rel]')\nplt.savefig('bacterialGrowthFitDataNumInt.png', dpi=300)\nplt.show()\n\n\nFigure 8: :Python code for performing nonlinear least squares data fitting using numerical integration.\n\n\n\nThe graph and print out of the best-fit model parameters are exactly the same as were produced by the code in Figure 7, which provides evidence that the more complicated numerical integration method for calculating the model function values works for the curve_fit function.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#computational-problem-solving-damped-spring-best-fit-model-parameter-values:sec",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#computational-problem-solving-damped-spring-best-fit-model-parameter-values:sec",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "Computational Problem Solving: Damped Spring – Best-fit Model Parameter Values",
    "text": "Computational Problem Solving: Damped Spring – Best-fit Model Parameter Values\nWe return now to the problem of the damped spring, described at the beginning of the chapter. The experimental setup is shown in Figure 10.1 and the data is contained in the file dampedSpringData.txt.\nProblem Statement: Given the position-time data shown in Figure 10.2, find the best-fit model parameters by fitting the data to the damped spring position-time model function given by Equation (10.1) reproduced here.\n\\[\\begin{array}{l} y\\left(t\\right) = Ae^{- bt/ 2m}\\cos \\left(\\omega t + \\phi_0\\right) \\\\ \\\\ \\omega  = \\sqrt{\\omega_0^2- \\frac{b^2}{4m^2}}\\text{ , }\\omega_0 = \\sqrt{\\frac{k}{m}} \\\\  \\end{array} \\tag{9}\\]\n\nAnalysis: Analyze the problem\nWe will not reproduce the physics analysis of the situation here, since it is covered in standard university physics textbooks (Knight, 2016). The mass of the object is assumed to be fixed at the measured value of m = 0.550 [kg]. A static force constant value of k=22.9 [N/m] is also provided with the data. This value of k will not necessarily be the best-fit value for the damped oscillator. The model parameters that must be determined are \\((A,b,k)\\). We will use the least squares technique to find the optimum values of these parameters. We will need to use the nonlinear version of this method available to us through the curve_fit function.\n\n\nDesign: Describe the data and develop algorithms\nThe position data shows an oscillation about a nonzero equilibrium point, but the model function we are using assumes an oscillation about y=0. We can adjust the position data by a constant amount to achieve this. Use the basic data plotting template and add the following line to adjust the position.\n# Read in data\ncols = np.loadtxt('dampedSpringData.txt',skiprows=3)\ntData = cols[:,0]\nyData = cols[:,1]\n\n# Adjust the y values by a constant amount\nyData = yData - 0.7    \nAn adjustment value of 0.7 appears to work well, as shown in Figure 9. The adjustment is applied to all values in the array yData since it is a numpy array.\n\n\n\n\n\n\nFigure 9: Adjusted spring position data.\n\n\n\nStarting guesses for the model parameters must be provided to the curve_fit function. Here are some possible values to use.\n\\[\\begin{array}{l} \\begin{array}{l} A = 0.22\\left[\\text{m}\\right] \\\\ b = 1.0 \\\\ k = 22.9\\left[\\text{N/m}\\right] \\\\  \\end{array} \\\\ \\phi_0 = \\pi \\left[\\text{radians}\\right] \\\\  \\end{array}\\]\nWe can reuse the algorithm design used for the code in Figure 7. We just need to replace the model function N used in that code with the model function from Equation 9 .\n\n\nImplementation\nThe design described above implemented in Python code is shown in Figure 10. The code is in the file dampedSpringModelNonlinearRegression.py.\n\n\n\n\"\"\"\nProgram: Damped Spring Model Data Fitting\nAuthor: C.D. Wentworth\nVersion: 10.25.2022.1\nSummary: This program reads in position-time data for\nan object attached to a damped spring and fits\nthe data to the standard damped spring model function\nusing the scipy.optimize.curve_fit() function. \nVersion History:\n  10.25.2022.1: base\n\n\"\"\"\n\nimport numpy as np\nimport matplotlib.pylab as plt\nimport scipy.optimize as so\n\ndef yf(t, A, b, k, phi0):\n    m = 0.550  # [kg]\n    w0 = np.sqrt(k/m)\n    w = np.sqrt(w0**2 - b**2/(4.0*m**2))\n    tmp = A*np.exp(-b*t/(2.0*m))*np.cos(w*t + phi0)\n    return tmp\n\n# Read in data\ncols = np.loadtxt('dampedSpringData.txt',skiprows=3)\ntData = cols[:,0]\nyData = cols[:,1]\n\n# Adjust the y data values by a constant amount\nyData = yData - 0.7\n\n# Define initial guess for model parameters\nA = 0.22\nb = 1.0\nk = 22.9\nphi0 = np.pi\np = A, b, k, phi0\n\n# Fit data to the damped spring model\npopt,pcov = so.curve_fit(yf, tData, yData, p)\np_stderr = np.sqrt(np.diag(pcov))\n\n# Plot the data\nplt.plot(tData, yData, linestyle='', marker='d',\n         markersize=7.0, label='Data')\n\n# Plot the theory\nA, b, k, phi0 = popt\ndA = p_stderr[0]\ndb = p_stderr[1]\ndk = p_stderr[2]\ndphi0 = p_stderr[3]\ntTheory = np.linspace(0, 10, 500) \nyTheory = yf(tTheory, A, b, k, phi0)\nplt.plot(tTheory, yTheory, color='red', linewidth=3, label='Theory')\nplt.xlabel('t [s]')\nplt.ylabel('y [m]')\nplt.legend()\nplt.title('Least Squares Fit to Damped Spring Model', fontsize=14)\nplt.savefig('dampedSpringFitData.png', dpi=300)\n\n# print out best-fit model parameters\nprint('A = ', format(A,'6.4f'), '+-', format(dA,'7.4f'))\nprint('b = ', format(b,'6.4f'), '+-', format(db,'6.4f'))\nprint('k = ', format(k,'6.3f'), '+-', format(dk,'6.3f'))\nprint('phi0 = ', format(phi0,'6.3f'), '+-', format(dphi0,'6.3f'))\n\n\nFigure 10: :Python code for performing the least squares fit of spring position data to the damped spring model.\n\n\n\n\n\nTesting\nThe code in Figure 10 produces the following print and graphical output.\nA =  0.2203 +-  0.0024\nb =  0.2084 +- 0.0038\nk =  18.662 +-  0.023\nphi0 =   3.072 +-  0.011\n\n\n\n\n\n\nFigure 11: Graph of damped spring data and model function with best-fit parameters.\n\n\n\nFigure 11 shows a reasonable fit between the position data and the theoretical model, although there may be some bias in the theory towards lower position values. This might be due to the constant adjustment made on the position data to yield oscillations about y = 0. This could be easily tested by adjusting the constant used in line 31.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#ch10-exercises:sec",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#ch10-exercises:sec",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "Exercises",
    "text": "Exercises\n1. Which statements below are true for the Least Squares Method for fitting data to a model?\n\nIt only applies to a model with one independent variable.\nIt allows more than one model parameter to be estimated at a time.\nIt involves minimizing the Least Squares Estimator Function.\nIt can only be used to fit data to a linear model.\n\n2. What is the calculus rule used to derive the least squares formulae for slope and intercept when fitting data to a linear model?\n3. What is the name of the Python function that can perform a least squares fit of data to linear model?\n4. What is the name of the Python function that can perform a least squares fit of data to nonlinear model?",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#program-modification-problems",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#program-modification-problems",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "Program Modification Problems",
    "text": "Program Modification Problems\n1. The Python program contained in Ch10ProgModProb1.py performs a linear regression (least-squares) fitting of some pressure versus temperature data for a gas held at constant volume. The data file for this program is GasData.txt.\nThe data file irisData.txt gives petal length and petal width measurements for many species of flower. You need to modify the Python code so that it performs a linear regression on this data. The program should also produce a plot of the data and the best-fit model. The graph should have\n\nproper axis labels\na legend that shows what is the model and what is the data\nmajor gridlines\n\nThe program should print out a message that gives\n\nbest-fit values for model parameters\nstandard error for the slope\nthe \\(R^2\\) value\nthe p-value for the fit\n\n2. The Python program contained in Ch10ProgModProb2.py performs a non-linear regression (least-squares) fitting of bacterial growth data to the exponential model. The data file for this program is bacterialGrowthData.txt . The program fits the exponential model to the bacteria grown in Cold Spring Harbor A + 0.1% glucose (CSHA) media. The file V_natriegensGrowthData.txt contains growth data for another bacteria species. You need to modify the Python code so that it performs a non-linear regression on this data using the logistics model function. The theoretical model function is\n\\[y\\left(t\\right) = \\frac{My\\left(0\\right)e^{rt}}{M + y\\left(0\\right)(e^{rt}- 1)}\\]\nYou can use the initial OD reading for y(0), and then find the best-fit model parameters M and r. The program should also produce a plot of the data and the best-fit model. The graph should have\n\nproper axis labels\na legend that shows what is the model and what is the data\nmajor gridlines\n\nThe program should print out\n\nbest-fit values for the model parameters\nthe standard error for the model parameter estimates\n\n3. The Python program contained in Ch10ProgModProb3.py performs a non-linear regression (least-squares) fitting of bacterial growth data to the exponential model using the numerical integration technique for obtaining the model function. The data file for this program is bacterialGrowthData.txt . The program fits the exponential model to the bacteria grown in Cold Spring Harbor A + 0.1% glucose (CSHA) media. The file V_natriegensGrowthData.txt contains growth data for another bacteria species. You need to modify the Python code so that it performs a non-linear regression on this data using the logistics model function obtained through the numerical integration technique. The theoretical rate equation is\n\\[\\frac{dy\\left(t\\right)}{dt} = ry\\left(1- \\frac{y}{M}\\right)\\]\nYou can use the initial OD reading for y(0), and then find the best-fit model parameters M and r using the least squares technique. The program should also produce a plot of the data and the best-fit model. The graph should have\n\nproper axis labels\na legend that shows what is the model and what is the data\nmajor gridlines\n\nThe program should print out\n\nbest-fit values for the model parameters\nthe standard error for the model parameter estimates\n\nYou should get the same final results as found in the Chapter 10 Program Modification Problem 2.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#ch10-program-development-problems:sec",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#ch10-program-development-problems:sec",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "Program Development Problems",
    "text": "Program Development Problems\n1. The following video shows a physics experiment where six bundled coffee filters are dropped from rest.\nhttps://youtu.be/muxKA3kK4IA\nThe mass of the six filters is mass = 5.3 [g]. The vertical position of the filters as a function of time was obtained from the video using video analysis software. The data is contained in the file coffeeFilterData.txt.\nYour task is to develop a dynamical systems model for the coffee filter motion. Go through the steps of our general problem-solving strategy. Develop the model and implement its solution in Python code. Estimate any model parameters using least squares fitting of the model to the data. Include an estimate of uncertainty in the model parameter(s). You can assume the mass of the filters and the acceleration due to gravity are already known, so the only model parameter that must be estimated is the air drag coefficient, k. An air drag force proportional to the square of the velocity will probably work well for this problem.\nThe position data starts at a nonzero time value. It may simplify developing the model to adjust the times to start at zero by subtracting the constant initial time from each time value.\nAdd a plot of the constant acceleration model (just gravity) to the figure so that a comparison can be made between the simple theory and the more complex one that includes air drag.\nCreate a documentation essay that describes how you went through the problem-solving strategy, detailing each step. Make sure you include a plot of the data and the best fit to the model. Specify the best-fit values of the model parameters with uncertainty.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#references",
    "href": "chapters/Ch10/Ch10_Least-squaresMethodsForData-fitting.html#references",
    "title": "Fitting Models to Data: The Method of Least Squares",
    "section": "References",
    "text": "References\n\nAkritas, M. (2018). Chapter 6 Fitting Models to Data. In Probability & Statistics with R for Engineers and Scientists (Classic Version) (Pearson Modern Classics for Advanced Statistics Series). Pearson. http://www.librarything.com/work/17953304/book/228047240\nKnight, R. (2016). Chapter 15 Oscillations. In Physics for Scientists and Engineers: A Strategic Approach with Modern Physics (4th edition). Pearson.\nThe SciPy Community. (2022a). scipy.optimize.curve_fit—SciPy v1.9.3 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html\nThe SciPy Community. (2022b). scipy.stats.linregress—SciPy v1.9.3 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html\n\n\n\n\n\nAkritas, M. (2018). Chapter 6 Fitting Models to Data. In Probability & Statistics with R for Engineers and Scientists (Classic Version) (Pearson Modern Classics for Advanced Statistics Series). Pearson. http://www.librarything.com/work/17953304/book/228047240\n\n\nKnight, R. (2016). Chapter 15 Oscillations. In Physics for Scientists and Engineers: A Strategic Approach with Modern Physics (4th edition). Pearson.\n\n\nThe SciPy Community. (2022a). Scipy.optimize.curve_fit — SciPy v1.9.3 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html\n\n\nThe SciPy Community. (2022b). Scipy.stats.linregress — SciPy v1.9.3 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Fitting Models to Data: The Method of Least Squares</span>"
    ]
  },
  {
    "objectID": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html",
    "href": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html",
    "title": "Project Ideas: Dynamical Systems Models",
    "section": "",
    "text": "Overview\nOne of the best ways to develop computational science skills for creating and solving models of scientific and engineering systems is to work on substantive projects that require analysis of the problem, finding appropriate data, and then developing code by reusing elements learned in previous chapters.\nIn this chapter, we will focus on developing dynamical systems models of several topics in the areas of biology, engineering, and physics. For each topic, we will present some basic background, provide references for additional background, define some of the key features of a model, and then suggest questions that can be explored with a computational solution to the model.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Project Ideas: Dynamical Systems Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html#biology:sec",
    "href": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html#biology:sec",
    "title": "Project Ideas: Dynamical Systems Models",
    "section": "Biology",
    "text": "Biology\n\nHIV Infection of an Individual\nHuman Immunodeficiency Viruses (HIV) are virus species that cause Acquired Immunodeficiency Syndrome (AIDS). There are two known species of HIV, labeled HIV-1 and HIV-2, both of which can cause AIDS. HIV are retroviruses, which contain RNA that can produce the DNA required for viral reproduction once a virus particle infects a host cell. HIV infects primarily T-lymphocyte cells, although they eventually infect a wide variety of cell types in the human host (Levy, 1993).\nFigure 1 shows the life cycle of viral load and CD4+ Lymphocyte concentration in an individual after infection (Wikipedia Contributors, 2022). The time development of the infection can be divided into three periods: the primary (or acute) infection, the latent (or asymptotic or chronic) period, and finally the onset of AIDS. The appearance of AIDS, usually several years after HIV infection, is associated with the destruction of the immune system, as illustrated by the significant reduction in CD4+ T-cell concentration.\nMathematical modeling of HIV infection dynamics has played a critical role in understanding how AIDS develops and in aiding creation of effective antiviral treatments (Ribeiro & Perelson, 2004). In this project you will focus on developing a model of HIV dynamics during the acute stage of the infection. In particular, the model must predict the initial rapid increase in viral load and then its decrease to a stable longer term value. Additionally, the model should predict the initial rapid decrease in the uninfected CD4+ T-cell concentration and then its rise to a longer-term value that slowly decreases over time.\n\n\n\n\n\n\nFigure 1: Generalized view of virus particle and CD4+ Lymphocyte concentration after infection in an individual.\n\n\n\nA good approach to this modeling problem is to use the dynamical systems framework with different compartments to represent the kind of cells and free viral particles that will be considered. The simplest compartment model that shows success at modeling the primary stage of infection is a three compartment model described by the state variables\n\\[\\begin{array}{l} T = \\text{concentration of uninfected T-cells} \\\\ I = \\text{concentration of infected T-cells} \\\\ V = \\text{concentration of free virus} \\\\  \\end{array}\\]\nand represented by Figure 2.\n\n\n\n\n\n\nFigure 2: Representation of the 3-compartment model for the HIV infection.\n\n\n\nThe rate equations associated with Figure 2 are (Perelson & Ribeiro, 2013)\n\\[\\begin{array}{l} \\frac{dT}{dt} = \\lambda - d_TT- \\beta VT \\\\ \\\\ \\frac{dI}{dt} = \\beta VT- d_II \\\\ \\\\ \\frac{dV}{dt} = pI- d_VV \\\\  \\end{array}\n    \\tag{1}\\]\n\n\nEpidemiology of the COVID-19 Infection\nEpidemiology is the study of patterns in the development of a disease in a population, and is of interest to researchers in basic science and by public health policymakers. One disease that is of particular interest at the time of publication is COVID-19, a serious global pandemic that appeared at the end of 2019.\nCOVID-19 is a disease caused by the severe acute respiratory syndrome coronavirus 2 (SARS‑CoV‑2). There have been 651,918,402 confirmed cases and 6,656,601 deaths globally of COVID-19 since December 2019 (WHO Coronavirus (COVID-19) Dashboard, 2020). In addition to the clear health consequences, the disease triggered significant economic and political disruption throughout the world.\nMathematical models of epidemics in a population can aid exploration of basic questions about an infectious disease and offer guidance to policy makers about preparing for or responding to an epidemic. These observations are true for the study of the COVID-19 pandemic (Adiga et al., 2020). Mathematical models can help answer critical questions such as\n\nHow quickly will the disease sweep through a population?\nHow many people will be infected during the outbreak?\nWill the disease persist in the population?\n\nThe starting point for investigating population-level dynamics of infectious diseases is the Susceptible-Infectious-Recovered (SIR) compartmental model. The state variables are\n\\[\\begin{array}{l} S = \\text{The number of susceptible people} \\\\ I = \\text{The number of infected people} \\\\ R = \\text{The number of recovered people} \\\\  \\end{array}\\]\nThe basic SIR model is represented in Figure 3. The assumptions that are used in the basic model are\n\nThere is no birth and death of people, so the total population of people is a constant.\nSusceptible people will become infected through exposure to infected people.\nInfected people are immediately infectious.\nThe rate of recovery \\(\\gamma\\) is assumed to be constant and recovered people are immune to infection.\n\n\n\n\n\n\n\nFigure 3: Graphical representation of the basic SIR model.\n\n\n\nThe rate equations for the state variables that describe the model shown in Figure 3 are\n\\[\\begin{array}{l} \\frac{dS}{dt} = - \\lambda \\left(I\\right)S \\\\ \\\\ \\frac{dI}{dt} = \\lambda \\left(I\\right)S- \\gamma I \\\\ \\\\ \\frac{dR}{dt} = \\gamma I \\\\  \\end{array}\n     \\tag{2}\\]\nSince the total population N is constant we have the following relationship between S, I, and R.\n\\[N=S+I+R \\tag{3}\\]\nTherefore, the dynamics of the system are really determined by two rate equations rather than three. The function \\(\\lambda \\left(I\\right)\\) is called the force of infection and gives the per capita rate at which susceptible individuals acquire infection. Different versions of the SIR model can be defined by choosing different forms for \\(\\lambda \\left(I\\right)\\). A typical choice is given by\n\\[\\lambda \\left(I\\right) = \\beta \\frac{I}{N} \\tag{4}\\]\n\\(\\beta\\) is called the transmission rate.\nWe can convert the state variables to dimensionless form by dividing by the total population.\n\\[s = \\frac{S}{N}\\text{ , }i = \\frac{I}{N}\\text{ , }r = \\frac{R}{N} \\tag{5}\\]\nWith these definitions for s, i, and r the rate equations become\n\\[\\begin{array}{left} \\frac{ds}{dt} = - \\beta si \\\\ \\frac{di}{dt} = \\beta si- \\gamma i \\\\ \\frac{dr}{dt} = \\gamma i \\\\  \\end{array} \\tag{6}\\]\nand the conservation law Equation 3 becomes\n\\[1=s+i+r \\tag{7}\\]\nFigure 4 shows an example of the results of this model. This model shows an infection that always dies out eventually with all infected people eventually recovering.\n\n\n\n\n\n\nFigure 4: Solution of the basic SIR model with \\(\\beta=0.30\\) and \\(\\gamma = 0.09\\).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Project Ideas: Dynamical Systems Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html#physics",
    "href": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html#physics",
    "title": "Project Ideas: Dynamical Systems Models",
    "section": "Physics",
    "text": "Physics\n\nBungee Jumping\nBungee jumping involves attaching a long bungee cord, a type of elastic cord, to a person and then having the person step off a bridge and plunge downwards, and then be pulled back up by the cord, shown in Figure 5.\n\n\n\n\n\n\n\n\n\n\nFigure 5: Bungee jumping off the Zambezi Bridge, Victoria Falls, Africa (Spy007au, 1996).\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Land diving on Pentecost Island (Stein, 2010).\n\n\n\n\n\n\n\nIn the modern world it is a popular form of extreme activity, but there are examples of similar activities in history including the land diving ritual performed by men living on Pentecost Island, Vanuatu, shown in Figure 6.\nWe will develop a basic mathematical model for the trajectory of a jumper using Newton’s Second Law (Menz, 1993). The coordinate system that will be used to describe the jumper’s position is shown in Figure 7. The origin of the y-axis is at the platform where the jumper steps off, and we take the +y direction to be down. The unstretched length of the cord is L. The mass of the jumper is m. We assume the bungee cord is massless.\n\n\n\n\n\n\nFigure 7: Coordinate system for the bungee jump.\n\n\n\nThe y-component of Newton’s Second Law is\n\\[\\begin{array}{l} \\sum_iF_{iy} = m\\ddot{y} \\\\ \\\\ mg- B\\left(t\\right)H\\left(y- L\\right)- D\\left(t\\right) = m\\ddot{y} \\\\  \\end{array} \\tag{8}\\]\nwhich gives\n\\[\\ddot{y} = g- \\frac{1}{m}B\\left(t\\right)H\\left(y- L\\right)- \\frac{1}{m}D\\left(t\\right) \\tag{9}\\]\nNote that the bungee force is nonzero only when y&gt;L. This fact can be implemented by using the Heaviside function\n\\[H\\left(y\\right) = \\left\\{\\begin{array}{cc} 1\\text{ , }y \\geq 0 \\\\ 0\\text{ , }y &lt; 0 \\\\  \\end{array}\\right. \\tag{10}\\]\nThe following model for the air drag force will be used.\n\\[D_y\\left(v_y\\right) = - \\frac{1}{2}\\rho C_DA\\left(v_y^2\\right)sign\\left(v_y\\right) \\tag{11}\\]\nwhere\n\\[\\begin{array}{l} \\rho  = \\text{density of air} \\\\ C_D = \\text{dimensionless drag coefficient for the rocket} \\\\ A = \\text{cross-sectional area of the rocket} \\\\ sign\\left(v_y\\right) = \\left\\{\\begin{array}{cc}  + 1\\text{ , }v_y &gt; 0 \\\\ - 1\\text{ , }v_y &lt; 0 \\\\  \\end{array}\\right. \\\\  \\end{array}\\]\nWe need a model for the bungee force B. The simplest bungee force model is to assume that it acts as an ideal spring\n\\[B = k_1\\left(y- L\\right) \\tag{12}\\]\nA more realistic bungee force is suggested by Figure 8\n\n\n\n\n\n\nFigure 8: Bungee force model.\n\n\n\nwhere x is the amount of cord stretch from equilibrium. The equation describing the force implied by this figure is\n\\[B = \\left\\{\\begin{array}{cc} K_1x\\text{ , }0 \\leq x \\leq X_1 \\\\ K_2x + \\left(K_1- K_2\\right)X_1\\text{ , }X_1 &lt; x \\leq X_2 \\\\ K_2X_2 + \\left(K_1- K_2\\right)X_1\\text{ , }X_2 &lt; x \\\\  \\end{array}\\right. \\tag{13}\\]\n\n\nModel Rocket Trajectory\nModel rocketry is a popular hobby for many adults and children. The rockets are constructed from cardboard, plastic, and balsa wood and are powered by commercially available solid propellant engines that can generate a thrust force of a few Newtons over one to three seconds (Estes Rockets, 2021). Figure 9 shows an example of the thrust data for a particular engine. The second small thrust peak corresponds to the parachute ejection shot. It can be ignored in the trajectory analysis that follows.\n\n\n\n\n\n\nFigure 9: Thrust data for the Estes B4-2 engine.\n\n\n\nThe trajectory of the model rocket can be predicted from the thrust data by performing a Newton’s Second Law analysis. The resulting equations of motion will be most easily studied using a numerical integration procedure, as discussed in previous chapters. The Newton’s 2nd Law analysis begins with a free body diagram. The physical forces acting on the rocket include gravity, \\(\\overrightarrow{\\mathbf F}_g\\), the rocket thrust, \\(\\overrightarrow{\\mathbf T}\\), and the air drag, \\(\\overrightarrow{\\mathbf D}\\). Figure 10 shows the free body diagram and the definition of the +y direction that will be assumed in the analysis.\n\n\n\n\n\n\nFigure 10: Model rocket free body diagram while rocket is not in contact with the ground.\n\n\n\nWe introduce the following function definitions\n\\[\\begin{array}{l} m\\left(t\\right) = \\text{mass of the rocket and engine as a function of time t} \\\\ D\\left(t\\right) = \\text{magnitude of the drag force as a function of time} \\\\ T\\left(t\\right) = \\text{magnitude of the thrust force as a function of time} \\\\  \\end{array}\\]\nNewton’s Second Law expressed in terms of momentum is\n\\[\\overrightarrow{\\text{F}}_{\\text{net}} = \\frac{d\\overrightarrow{\\text{p}}}{dt}\\text{,}\\overrightarrow{\\mathbf p} = m\\left(t\\right)\\overrightarrow{\\mathbf v} \\tag{14}\\]\nWe will assume that the rocket travels only in the vertical direction, so only the y-component of the forces and Newton’s Second Law will be needed.\n\\[F_{gy} = - m\\left(t\\right)g \\tag{15}\\]\nThe model for the air drag force is given by Equation 11. We also need a model for the thrust function based on the available thrust data. This will be developed below.\nNewton’s Second Law, Equation , can now be written as\n\\[T\\left(t\\right) + D_y\\left(v_y\\right)- m\\left(t\\right)g = \\frac{dm}{dt}v_y\\left(t\\right) + m\\left(t\\right)a_y\\left(t\\right) \\tag{16}\\]\nwhere\n\\[a_y\\left(t\\right) = \\text{y-component of acceleration at time t}\\]\nWe will assume that the mass of the rocket will not change as the engine burns since the fuel mass is a very small percentage of the total mass. This assumption gives\n\\[\\frac{dm}{dt} = 0 \\tag{17}\\]\nwhich allows us to write Equation 16 as\n\\[a_y\\left(t\\right) = \\frac{1}{m}\\left[T\\left(t\\right) + D_y\\left(v_y\\right)- mg\\right] \\tag{18}\\]\nNext, we will develop a mathematical model for the rocket thrust. Figure 9 suggests that a possible mathematical model for the thrust is given by Figure 11.\n\n\n\n\n\n\nFigure 11: Graphical representation of the rocket thrust model.\n\n\n\nUsing analytical geometry, we can find the equation representing Figure 11 to be\n\\[T\\left(t\\right) = \\left\\{\\begin{array}{cc} s_1t\\text{ , }0 \\leq t \\leq t_1 \\\\ s_2t + b\\text{ , t}_1 &lt; t \\leq t_2 \\\\ T_2\\text{ , }t_2 &lt; t \\leq t_3 \\\\ 0\\text{ , t&gt;t}_3 \\\\\n  \\end{array}\\right. \\tag{19}\\]\nwhere\n\\[s_1 = \\frac{T_1}{t_1}\\text{ , }s_2 = \\frac{\\left(T_2- T_1\\right)}{\\left(t_2- t_1\\right)}\\text{ , }b = \\left(T_1- s_2t_1\\right)\\]\nAdditional background information about model rocket trajectories can be found in Keeports (1990).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Project Ideas: Dynamical Systems Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html#ch11-projects:sec",
    "href": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html#ch11-projects:sec",
    "title": "Project Ideas: Dynamical Systems Models",
    "section": "Projects",
    "text": "Projects\nHIV Infection of an Individual\n\nFit the data in the file HIVData.txt to the HIV model defined by Equation 1 using the least squares method to find the best fit model parameters. Explore how making variations in model parameters affects the time behavior of the infection.\nExplore the effect of antiretroviral therapy by modifying the rate equation for V as suggested by Perelson & Ribeiro (2013). First explore how the theoretical predictions for the original model of Equation 1 compare with theoretical predictions of the modified model. Next, locate data on viral concentration after antiretroviral therapy and compare the viral clearance rate, dV, with therapy and without therapy.\n\nEpidemiology of the COVID-19 Infection\n\nUse the data file owid-covid-data.xlsx from the Our World in Data website (Mathieu et al., 2020) to obtain COVID infection data for the US. Fit the US data for the early stage of the epidemic to the model of Equation 6. Is there any time period for which the basic SIR model provides an adequate description? Calculate the basic reproductive rate for the infected population (see Blackwood & Childs (2018) for discussion of the reproductive rate).\nAdd birth and death terms to the rate equations. Implement a numerical solution to the revised model. Explore the effect of changing birth and death rates on the time behavior of the model. What is the effect of birth and death on the basic reproduction rate?\n\nBungee Jumping\n\nImplement a numerical solution to the model of Equation 9. Investigate bungee jumping sites to determine typical drop lengths for participants. If possible, determine typical times for a jumper to come to rest. Use this data to determine best fit model parameter values. Explore the behavior of velocity and acceleration over the time of the jump. Use the model to explore possible health effects of bungee jumping.\nImplement a numerical solution to the model of Equation 9. Use the model to assist in designing a bungee jump site. You will need to decide about the range of jumper masses your site will accommodate, the maximum jump height, and the required bungee cords that will serve people of different mass. Research safety and health concerns and verify that your design meets all required safety criteria.\n\nModel Rocket Trajectory\n\nUse the thrust data given for the Estes A8-3, B4-2, and B6-2 engines to estimate the parameters for the thrust model given by Equation 18. The thrust data is contained in the files A8-3_ThrustData.txt, B4-2_ThrustData.txt, and B6-2_ThrustData.txt. Create a Python thrust force function for each of the engines. Choose a model rocket from the Estes catalog. Note the rocket’s mass, cross-sectional area, and suggested maximum height. Implement a numerical solution of the trajectory model given by Equation 18 for each of the engines. Compare the theoretical maximum height with the height suggested by Estes.\nDevelop a mathematical model for a two-dimensional rocket trajectory. This will require analyzing motion in both the vertical and horizontal directions. Explore how the launch angle affects the maximum height and range of the rocket for each of the engines.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Project Ideas: Dynamical Systems Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html#references",
    "href": "chapters/Ch11/Ch11_Projects_DynamicalSystems.html#references",
    "title": "Project Ideas: Dynamical Systems Models",
    "section": "References",
    "text": "References\n\nAdiga, A., Dubhashi, D., Lewis, B., Marathe, M., Venkatramanan, S., & Vullikanti, A. (2020). Mathematical Models for COVID-19 Pandemic: A Comparative Analysis. Journal of the Indian Institute of Science, 100(4), 793–807. https://doi.org/10.1007/s41745-020-00200-6\nBlackwood, J., & Childs, L. (2018). An introduction to compartmental modeling for the budding infectious disease modeler. Letters in Biomathematics, 5(1), Article 1. https://doi.org/10.30707/LiB5.1Blackwood\nEstes Rockets. (2021). Estes Industries. https://estesrockets.com/\nKeeports, D. (1990). Numerical calculation of model rocket trajectories. The Physics Teacher, 28(5), 274–280. https://doi.org/10.1119/1.2343024\nLevy, J. A. (1993). Pathogenesis of human immunodeficiency virus infection. Microbiological Reviews, 57(1), 183–289. https://doi.org/10.1128/mr.57.1.183-289.1993\nMathieu, E., Ritchie, H., Rodés-Guirao, L., Appel, C., Giattino, C., Hasell, J., Macdonald, B., Dattani, S., Beltekian, D., Ortiz-Ospina, E., & Roser, M. (2020). Coronavirus Pandemic (COVID-19). Our World in Data. https://ourworldindata.org/coronavirus-source-data\nMenz, P. G. (1993). The physics of bungee jumping. The Physics Teacher, 31(8), 483–487. https://doi.org/10.1119/1.2343852\nPerelson, A. S., & Ribeiro, R. M. (2013). Modeling the within-host dynamics of HIV infection. BMC Biology, 11, 96. https://doi.org/10.1186/1741-7007-11-96\nRibeiro, R. M., & Perelson, A. S. (2004). The Analysis of HIV Dynamics Using Mathematical Models. In AIDS and Other Manifestations of HIV Infection (4th ed.). Elsevier.\nSpy007au. (1996). Bungee jumping off the Zambezi Bridge, Victoria Falls, Africa. Own work by the original uploader. https://commons.wikimedia.org/wiki/File:Bill%27s_Bungy_Jump.jpg\nStein, P. (2010). The Tower. https://commons.wikimedia.org/w/index.php?curid=10438782\nWHO Coronavirus (COVID-19) Dashboard. (2020). WHO Coronavirus (COVID-19) Dashboard. https://covid19.who.int\nWikipedia Contributors. (2022). HIV. In Wikipedia. https://en.wikipedia.org/w/index.php?title=HIV&oldid=1119384291\n\n\n\n\n\nAdiga, A., Dubhashi, D., Lewis, B., Marathe, M., Venkatramanan, S., & Vullikanti, A. (2020). Mathematical Models for COVID-19 Pandemic: A Comparative Analysis. Journal of the Indian Institute of Science, 100(4), 793–807. https://doi.org/10.1007/s41745-020-00200-6\n\n\nBlackwood, J., & Childs, L. (2018). An introduction to compartmental modeling for the budding infectious disease modeler. Letters in Biomathematics, 5(1, 1), 195–221. https://doi.org/10.30707/LiB5.1Blackwood\n\n\nEstes Rockets. (2021). Estes Industries. https://estesrockets.com/\n\n\nKeeports, D. (1990). Numerical calculation of model rocket trajectories. The Physics Teacher, 28(5), 274–280. https://doi.org/10.1119/1.2343024\n\n\nLevy, J. A. (1993). Pathogenesis of human immunodeficiency virus infection. Microbiological Reviews, 57(1), 183–289. https://doi.org/10.1128/mr.57.1.183-289.1993\n\n\nMathieu, E., Ritchie, H., Rodés-Guirao, L., Appel, C., Giattino, C., Hasell, J., Macdonald, B., Dattani, S., Beltekian, D., Ortiz-Ospina, E., & Roser, M. (2020). Coronavirus Pandemic (COVID-19). Our World in Data. https://ourworldindata.org/coronavirus-source-data\n\n\nMenz, P. G. (1993). The physics of bungee jumping. The Physics Teacher, 31(8), 483–487. https://doi.org/10.1119/1.2343852\n\n\nPerelson, A. S., & Ribeiro, R. M. (2013). Modeling the within-host dynamics of HIV infection. BMC Biology, 11, 96. https://doi.org/10.1186/1741-7007-11-96\n\n\nSpy007au. (1996). Bungee jumping off the Zambezi Bridge, Victoria Falls, Africa [Graphic]. https://commons.wikimedia.org/wiki/File:Bill%27s_Bungy_Jump.jpg\n\n\nStein, P. (2010). The Tower [Graphic]. https://commons.wikimedia.org/w/index.php?curid=10438782\n\n\nWHO Coronavirus (COVID-19) Dashboard. (2020). WHO Coronavirus (COVID-19) Dashboard. https://covid19.who.int",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Project Ideas: Dynamical Systems Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch12/Ch12_Projects_Stochastic.html",
    "href": "chapters/Ch12/Ch12_Projects_Stochastic.html",
    "title": "Project Ideas: Stochastic Models",
    "section": "",
    "text": "Forest Fire Propagation\nWhen forest fires encroach on regions with human habitation, the damage done can be substantial, including property damage, health effects, and death. Between 2017 and 2021 the average cost per year of wildfires in the U.S. was $16.8 billion, and the average number of deaths per year was 43 (Smith, 2020). If health effects of particulate inhalation are included, the death toll from wildfires climbs to about 33000 deaths per year globally (Verzoni, 2021). Figure 1 shows the acres burned by wildfires in the U.S. between 1983 and 2021, which suggests an upward trend over this time (NICC, 2022).\nAs the acres burned and human migration into forest increases, the money spent on wildfire suppression also increases, as shown in Figure 2.\nThe economic and health costs of wildfires have provided motivation for developing models that can help us understand and predict forest fire propagation. Historically, fire propagation models were based on partial differential equations, but more recently cellular automata models have been developed (Perry, 1998). We will explore the use of cellular automata (CA) to model forest fire propagation since the technique is mathematically and computationally simpler than using PDE’s.\nSeveral cellular automata models for forest fires have been proposed. Some models focus on basic physics questions concerning self-organized criticality and are not meant to model real forest fires in detail (Bak et al., 1990). Other models attempt to build in features from observations of actual fires including effects of fuel moisture, wind speed, local temperature, and relative humidity (Clarke et al., 1994). More recent CA models incorporate real forest fire data to calculate the transition rules governing a cell’s change of state (Collin et al., 2011) or incorporate the effects of inhomogeneous terrain (Encinas et al., 2007).\nWe will outline a basic forest fire cellular automaton model. Chapter 9 gives the basic elements of a cellular automaton model. It requires\nThe cellular automaton model is described by the collection \\(\\langle L,S,N,\\Phi \\rangle\\).\nWe will develop an adaptation of the Encinas model (Encinas et al., 2007). Our model will use a 2-dimensional lattice L that can represent the earth’s surface. We will assume that L is square, with the number of grid points on one side set to a fixed value. A time step in the simulation corresponds to allowing each grid point in the lattice the chance to change state. The state of a cell is defined as\n\\[S_{ij} = \\frac{A_{bij}}{A} \\tag{1}\\]\nwhere \\(A_{bij}\\) is the burned area of the cell, and A is the total area of a cell. The neighborhood of a cell at (i,j) will be taken to be the Moore neighborhood illustrated in Figure 3. (Wikipedia Contributors, 2022). If (i,j) is on the lattice boundary then \\(S_{ij} = 0\\).\nThe transition rule is\n\\[\\begin{array}{l} \\Phi :S_{ij}^{(t + 1)} = \\frac{R_{ij}}{R}S_{ij}^{(t)} + \\sum_{(\\alpha ,\\beta )\\varepsilon N_{adj}}\\mu_{\\alpha \\beta}\\frac{R_{i + \\alpha ,j + \\beta}}{R}S_{i + \\alpha ,j + \\beta}^{(t)} \\\\ \\\\ \\quad + \\sum_{(\\alpha ,\\beta )\\varepsilon N_{diag}}\\mu_{\\alpha \\beta}\\frac{\\pi (R_{i + \\alpha ,j + \\beta})^2}{4R^2}S_{i + \\alpha ,j + \\beta}^{(t)} \\\\  \\end{array} \\tag{2}\\]\nwhere \\(\\mu_{\\alpha \\beta}\\) incorporates physical effects including wind speed and slope height at each cell. The values \\((\\alpha,\\beta)\\) that define the neighbors of \\((i,j)\\) in Equation 2 are given by\n\\[N_{adj} = \\left\\{\\left(- 1,0\\right),\\left(0,1\\right),\\left(1,0\\right),\\left(0,- 1\\right)\\right\\} \\tag{3}\\]\n\\[N_{diag} = \\left\\{\\left(- 1,1\\right),\\left(1,1\\right),\\left(1,- 1\\right),\\left(- 1,- 1\\right)\\right\\} \\tag{4}\\]\nIn this version of the model, we will take \\(\\mu_{\\alpha \\beta}\\) to be\n\\[\\mu_{\\alpha \\beta} = w_{i + \\alpha ,j + \\beta} \\cdot h_{i + \\alpha ,j + \\beta} \\tag{5}\\]\nand \\(w_{i + \\alpha ,j + \\beta}\\) are the entries in the wind speed matrix\n\\[W_{ij} = \\left[\\begin{array}{ccc} w_{i- 1,j- 1} & w_{i- 1,j} & w_{i- 1,j + 1} \\\\ w_{i,j- 1} & 1 & w_{i,j + 1} \\\\ w_{i + 1,j- 1} & w_{i + 1,j} & w_{i + 1,j + 1} \\\\  \\end{array}\\right] \\tag{6}\\]\nand \\(h_{i + \\alpha ,j + \\beta}\\) are entries in the slope height matrix\n\\[H_{ij} = \\left[\\begin{array}{ccc} h_{i- 1,j- 1} & h_{i- 1,j} & h_{i- 1,j + 1} \\\\ h_{i,j- 1} & 1 & h_{i,j + 1} \\\\ h_{i + 1,j- 1} & h_{i + 1,j} & h_{i + 1,j + 1} \\\\  \\end{array}\\right] \\tag{7}\\]\nIf Equation 2 yields a value greater than 1 then \\(S_{ij}^{\\left(t + 1\\right)}\\) should be replaced by 1. Finally, to introduce a stochastic element into the state transition rule we assume that the cell state changes according to Equation 2 with probability p, otherwise it remains unchanged.\nThe state of a cellular automaton cell is usually taken to be discrete. Since Equation 2 can generally yield a continuous result, forming discrete values requires an additional step. One way to achieve state values that are discrete is to use the following definition. Assume the number of discrete values desired is Ns.\n\\[\nS_{ij}^{\\prime} = \\left\\{\\begin{array}{left} 0 & ,S_{ij} = 0 \\\\ \\frac{1}{\\left(N_s- 1\\right)} & ,0 &lt; S_{ij} &lt; \\frac{1}{\\left(N_s- 1\\right)} \\\\ \\frac{2}{\\left(N_s- 1\\right)} & ,\\frac{1}{\\left(N_s- 1\\right)} \\leq S_{ij} &lt; \\frac{2}{\\left(N_s- 1\\right)} \\\\ \\vdots  &  \\\\ 1 & ,S_{ij} \\geq 1 \\\\  \\end{array}\\right.\n\\tag{8}\\]\nSome system properties that might be studied using the simulation include the percentage of cells that have not burned (Sij = 0), are burning (0&lt;Sij &lt;1), and have burnt out (Sij = 1) as functions of time.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Project Ideas: Stochastic Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch12/Ch12_Projects_Stochastic.html#forest-fire-propagation",
    "href": "chapters/Ch12/Ch12_Projects_Stochastic.html#forest-fire-propagation",
    "title": "Project Ideas: Stochastic Models",
    "section": "",
    "text": "Figure 1: Acres burned from forest fires in the U.S. (NICC, 2022).\n\n\n\n\n\n\n\n\n\n\nFigure 2: Federal wildfire suppression costs in the U.S. (NIFC, 2022).\n\n\n\n\n\n\n\na discrete lattice of sites or cells in d dimensions, L\noperating using discrete time steps\na discrete set of possible cell values, S\na defined neighborhood, N of each cell in L\na transition rule, \\(\\Phi\\), that specifies how the state of a cell will be updated depending on its current value and the values of sites in the neighborhood.\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Moore neighborhood for a 2-d cellular automaton.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Project Ideas: Stochastic Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch12/Ch12_Projects_Stochastic.html#solid-state-diffusion",
    "href": "chapters/Ch12/Ch12_Projects_Stochastic.html#solid-state-diffusion",
    "title": "Project Ideas: Stochastic Models",
    "section": "Solid-State Diffusion",
    "text": "Solid-State Diffusion\nDiffusion is the transport of matter through the movement of individual atoms or molecules. Macroscopically, diffusion involves movement from a region of high concentration to low concentration of the diffusing material. Diffusion can be contrasted with fluid flow, where all the atoms move together due to a pressure gradient. Solid-state diffusion involves the motion of individual atoms in a solid material.\nSolid-state diffusion plays a significant role in many industrial applications. Examples of materials in which solid-state diffusion plays a significant role are steel, doped semiconductors, and superionic conductors.\nSteel is made from iron by the addition of carbon to iron. Uniform distribution of carbon can be achieved by diffusion of carbon atoms during a sintering process. The carbon content of solid steel can be adjusted by diffusion of carbon at the solid surface, a process called carburizing (Mandal, 2015). Other elements, such as titanium or nitrogen, can be added to iron in the same way as carbon to change the mechanical properties of the steel.\nThe electrical and optical properties of semiconductor materials can be adjusted by doping the base material, such as silicon, with other elements, such as gallium. This can be done by exposing the silicon to a gas containing the dopant and allowing it to diffuse into the silicon (Zant, 2014).\nSuperionic, or fast-ion, conductors are materials in which charge transport is achieved by moving ions rather than moving electrons, as occurs in metallic conductors (Beard, 2019). These materials are important in creating solid-state batteries, supercapacitors, and fuel cells, where solid electrolytes are required. Charge transport in these materials can be modeled by a hopping motion of ions in the solid with a preferred direction of motion established by an electric field.\nWe will develop a model of solid-state diffusion based on the idea of a lattice gas, in which particles that can move are placed in a lattice structure and can move between sites in the lattice. The following assumptions will be made for the model.\n\nThe diffusive motion is accomplished by a particle hopping to a nearby lattice site.\nParticles can only hop to nearest-neighbor lattice sites, which are assumed to be separated by a distance a.\nThe particles do not interact with each other except that double occupancy of a lattice site is not allowed.\nAt each time step, a particle will choose a direction at random and attempt to move to the nearest-neighbor lattice site in that direction.\n\n\n\n\n\n\n\nFigure 4: Two-dimensional lattice gas.\n\n\n\nFigure 4 shows an example of a lattice gas in a two-dimensional, square lattice. The allowed nearest-neighbor hops for one particle are shown.\nAn important property that can be studied with this model is the tracer diffusion coefficient, D*. Tracer diffusion refers to diffusion of a single particle that can be tracked over time. The tracer diffusion coefficient can be defined in terms of the mean square displacement of the tracer particle. For the square lattice, this definition is\n\\[D^* = \\frac{〈\\left|\\overrightarrow{r}\\left(t\\right)- \\overrightarrow{r}\\left(0\\right)\\right|^2〉}{4t} \\tag{9}\\]\nwhere \\(\\overrightarrow{r}\\left(t\\right)\\) is the position of the tracer at time t and the averaging, indicated by the angle brackets, is over all the diffusing particles in the lattice, since each one can be considered as a tracer.\nWe want to implement a Monte Carlo simulation of this model. The time t in a simulation will be considered as one pass through all the diffusing particles, attempting to allow each one to hop. The long-term time behavior of the mean square tracer displacement should be linear, giving a time-independent tracer diffusion coefficient. We can use the simulation to calculate D* as a function of particle concentration in the lattice. Table 1 defines the most important data structures or variables that might be used in the simulation code.\n\n\n\nTable 1: Data structures used in the Monte Carlo simulation of diffusion.\n\n\n\n\n\n\n\n\n\n\nVariable Name\nData Type\nDescription\n\n\n\n\nconcentration\nfloat\ngives the fraction of lattice sites occupied by diffusing particles\n\n\ninit_particle_positions\nlist\ninit_particle_positions[p] is a list of the initial x/y coordinates of particle number p\n\n\nlattice_size\ninteger\nthe length of one side of the lattice as a number of sites\n\n\nnum_of_particles\ninteger\nthe number of particles in the lattice\n\n\np\ninteger\nparticle number\n\n\nparticle_positions\nlist\nparticle_positions[p] is a list of the current x/y coordinates of particle number p\n\n\nsite_occupancy\n2d numpy array of integers\nsite_occupancy[xi,yi] specifies whether the lattice site with coordinates (xi,yi) is occupied\n\n\nt\ninteger\ncurrent time step being considered\n\n\ntotal_time_steps\ninteger\nthe number of time steps in a simulation",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Project Ideas: Stochastic Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch12/Ch12_Projects_Stochastic.html#creating-animations-with-python:sec",
    "href": "chapters/Ch12/Ch12_Projects_Stochastic.html#creating-animations-with-python:sec",
    "title": "Project Ideas: Stochastic Models",
    "section": "Creating Animations with Python",
    "text": "Creating Animations with Python\nAnimations can be used to facilitate exploring a model or data particularly when identifying time-dependent patterns. Basic animations can be created using the matplotlib package. Two methods will be discussed here.\n\nplacing the matplotlib.pyplot pause function in a for loop\nusing the FuncAnimation function from the matplotlib.animation package\n\nAnimations can be useful in the early stages of analyzing the models discussed in this chapter.\n\nUsing the pause() Function\nThe pause(interval) function from the matplotlib.pyplot package will pause program execution for the number of seconds indicated by the interval parameter. An animation can be created by setting up a for loop in which the plot function is executed and then the pause function is executed within the loop. Figure 1.5 shows an example of code that will animate plotting a function using the pause() function.\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = []\ny = []\n\nfor i in range(100):\n    x.append(i)\n    y.append(np.sqrt(i))\n\n    # Mention x and y limits to define their range\n    plt.xlim(0, 100)\n    plt.ylim(0, 10)\n    \n    # Ploting graph\n    plt.plot(x, y, color = 'green')\n    plt.pause(0.01)\n\nplt.show()\n\n\nFigure 5: :. Example of animation using the pause function.\n\n\n\n\n\nUsing the FuncAnimation Function\nThe matplotlib.animation package has a function named FuncAnimation that requires a bit more work to set up than just using the pause function but allows for more flexibility including being able to save the animation in a gif, avi, mov, or mp4 file format. Using FuncAnimation to create an animation requires the following steps\n\ndefining an empty figure object\ndefining a callable Python function that can create one frame of the animation, usually performed using the matplotlib plot function\nmaking a call to the FuncAnimation function\n\nDefining the empty figure object is done using the Object Oriented interface for matplotlib. The basic syntax for creating an empty plotting grid is\nfig = plt.figure()\naxes = fig.add_subplot(1,1,1)\nThe callable function that creates a frame must have the frame number as the first argument with any other arguments following:\ndef func(frame, *fargs)\nwhere frame will be an integer specifying the frame number being created.\nFuncAnimation has many parameters (The Matplotlib development team, 2023). A basic call will be of the form\nanimation_name = animation.FuncAnimation(fig=fig_name, \n                 func=frame_creation_function, interval=time , \n                 save_count=num_of_frames)\nwhere\nfig_name is the figure object\nframe_creation_function is the callable function that creates one frame in the animation\ninterval is the time between frames in millisecond\nnum_of_frames is an integer that specifies the number of frames in the animation\nanimation_name is a user specified variable that refers to the animation object and can be used to play the animation or save it as video file\nFigure 6 gives an example of a program that produces an animation of a two-dimensional random walk.\n\n\n\n\"\"\"\nTitle: Random Walk in 2D: animations\nAuthor: C.D. Wentworth\nversion: 12.31.2022.1\nSummary: This program performs a random walk on a\n         two-dimensional lattice. It uses reflective\n         boundary conditions. It produces an animation \n         of the walk\nversion history:\n        12.31.2022.1: base\n\n\"\"\"\nimport random as rn\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom matplotlib import rc\n\nrc('animation', html='html5')\n\ndef createFrame(t):\n    x_frame.append(x_array[t])\n    y_frame.append(y_array[t])\n    axes.set_title(str(t))\n    plt.plot(x_frame,y_frame, scaley=True, scalex=True, linewidth=2, color=\"blue\")\n    \n\ndef step(xi, yi, lx, ux, ly, uy):\n    import random as rn\n    r = rn.randint(1, 4)\n    if r == 1:\n        # go east\n        if xi &lt; ux:\n            xi = xi + 1\n    elif r == 2:\n        # go west\n        if xi &gt; lx:\n            xi = xi - 1\n    elif r == 3:\n        # go north\n        if yi &lt; uy:\n            yi = yi + 1\n    else:\n        # go south\n        if yi &gt; ly:\n            yi = yi - 1\n    return xi, yi\n\n\n# --Main Program\n# set up random generator\nrn.seed(42)\n\n# define the grid\nlx = -30\nux = 30\nly = -30\nuy = 30\n\n# set up the simulation\nN = 500\nxi = 0\nyi = 0\nposition_array = np.zeros((N + 1, 2))\n\n# execute random walk\nfor i in range(1, N + 1):\n    xi, yi = step(xi, yi, lx, ux, ly, uy)\n    position_array[i, 0] = xi\n    position_array[i, 1] = yi\n\nx_array = position_array[:, 0]\ny_array = position_array[:, 1]\nx_frame = []\ny_frame = []\n\n# Create the animation\nfig = plt.figure()\naxes = fig.add_subplot(1,1,1)\naxes.set_ylim(lx, ux)\naxes.set_xlim(ly, uy)\n#writervideo = animation.FFMpegWriter(fps=10)\nani = animation.FuncAnimation(fig=fig, func=createFrame, interval=100 ,\n                              save_count=N)\nani\n\n\nFigure 6: :Example code that uses FuncAnimation to show a 2-d random walk.\n\n\n\nThe animation object is named ani, and it is played in a Jupyter notebook by just entering the name as the last statement of the program. If you want to play the animation within an IDE such as Spyder then additional steps will usually need to be completed.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Project Ideas: Stochastic Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch12/Ch12_Projects_Stochastic.html#projects",
    "href": "chapters/Ch12/Ch12_Projects_Stochastic.html#projects",
    "title": "Project Ideas: Stochastic Models",
    "section": "Projects",
    "text": "Projects\nForest Fire Propagation\nDevelop code that implements the model described in section 12.1. This can be done in stages, depending on available time. One way to start the fire is to initialize one cell to the state in the range \\(0 &lt; S_{ij} &lt; 1\\). Another possible initial state would be to allow a given concentration c of the cells to be burning. For each of the following scenarios, measure the percentage of cells in the burning state as a function of time. Consider the effect of varying p and c.\n1. Assume a homogeneous lattice, so there is no variation in burn rates, no wind, and no variation in height. This is accomplished by\n\nsetting all entries of R to one\nletting the wind and height matrices be defined by\n\n\\[W_{ij} = \\left[\\begin{array}{ccc} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\  \\end{array}\\right]\\text{ , }H_{ij} = \\left[\\begin{array}{ccc} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\  \\end{array}\\right]\\]\n2. Consider an inhomogeneous system with burn rates that vary in some way on the lattice. You might consider dividing the lattice into two regions with different burn rates.\n3. Explore the effect of wind speed. A north-to-south wind is represented by the wind matrix\n\\[W_{ij} = \\left[\\begin{array}{ccc} 1.5 & 1.5 & 1.5 \\\\ 1 & 1 & 1 \\\\ 0.5 & 0.5 & 0.5 \\\\  \\end{array}\\right]\\]\nSolid-State Diffusion\n1. Implement the 2-dimensional diffusion model discussed in section 12.2. Study the mean square displacement of a particle \\(〈\\left|\\overrightarrow{r}\\left(t\\right)- \\overrightarrow{r}\\left(0\\right)\\right|^2〉\\) as a function of time and as a function of concentration. Does it become linear after some period of time, indicating a well-defined tracer diffusion coefficient? Does the lattice size have an effect on the results? Remember that when performing a Monte Carlo simulation of a model, measured properties of the system will show random variation. To eliminate the effects of this random variation you must repeat the simulation multiple time and form a mean over all the simulations for any measured property, as discussed in Chapter 9.\n2. Develop a model for diffusion in a one-dimensional lattice similar to the two-dimensional model. Implement a Monte Carlo simulation of the model. Does the mean-square displacement \\(〈\\left|x\\left(t\\right)- x\\left(0\\right)\\right|^2〉\\) behave the same as in two dimensions?",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Project Ideas: Stochastic Models</span>"
    ]
  },
  {
    "objectID": "chapters/Ch12/Ch12_Projects_Stochastic.html#ch12-references:sec",
    "href": "chapters/Ch12/Ch12_Projects_Stochastic.html#ch12-references:sec",
    "title": "Project Ideas: Stochastic Models",
    "section": "References",
    "text": "References\n\nBak, P., Chen, K., & Tang, C. (1990). A forest-fire model and some thoughts on turbulence. Physics Letters A, 147(5), 297–300. https://doi.org/10.1016/0375-9601(90)90451-S\nBeard, K. W. (Ed.). (2019). SECTION C: SOLID-STATE ELECTROLYTES (CERAMIC, GLASS, POLYMER). In Linden’s Handbook of Batteries (5th edition.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/9781260115925/toc-chapter/chapter22/section/section24\nClarke, K. C., Brass, J. A., & Riggan, P. J. (1994). A cellular automaton model of wildfire propagation and extinction. Photogrammetric Engineering and Remote Sensing. 60(11): 1355-1367, 60(11), Article 11.\nCollin, A., Bernardin, D., & Séro-Guillaume, O. (2011). A Physical-Based Cellular Automaton Model for Forest-Fire Propagation. Combustion Science and Technology, 183(4), 347–369. https://doi.org/10.1080/00102202.2010.508476\nEncinas, A. H., Encinas, L. H., White, S. H., Rey, A. M. del, & Sánchez, G. R. (2007). Simulation of forest fire fronts using cellular automata. Advances in Engineering Software, 38(6), 372–378. https://doi.org/10.1016/j.advengsoft.2006.09.002\nMandal, S. K. (2015). Heat Treatment and Welding of Steels. In Steel Metallurgy: Properties, Specifications and Applications (First edition.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/ 9780071844611/chapter/chapter8\nNICC. (2022). Wildfires and Acres. National Interagency Fire Center. https://www.nifc.gov/fire-information/statistics/wildfires\nNIFC. (2022). Suppression Costs National Interagency Fire Center. National Interagency Fire Center. https://www.nifc.gov/fire-information/statistics/suppression-costs\nPerry, G. L. W. (1998). Current approaches to modelling the spread of wildland fire: A review. Progress in Physical Geography: Earth and Environment, 22(2), 222–245. https://doi.org/10.1177/030913339802200204\nSmith, A. B. (2020). U.S. Billion-dollar Weather and Climate Disasters, 1980—Present (NCEI Accession 0209268) [Data set]. NOAA National Centers for Environmental Information. https://doi.org/10.25921/STKW-7W73\nThe Matplotlib development team. (2023). Matplotlib.animation.FuncAnimation. Matplotlib 3.6.3 Documentation. https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html\nVerzoni, A. (2021). Global Wildfire Deaths. http://www.nfpa.org/News-and-Research/Publications-and-media/NFPA-Journal/2021/Winter-2021/News-and-Analysis/Dispatches/International\nWikipedia Contributors. (2022). Moore neighborhood. In Wikipedia. https://en.wikipedia.org/w/index.php?title=Moore_neighborhood&oldid=1128664897\nZant, P. V. (2014). Doping. In Microchip Fabrication (6th ed.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/9780071821018/ chapter/chapter11\n\n\n\n\n\nBak, P., Chen, K., & Tang, C. (1990). A forest-fire model and some thoughts on turbulence. Physics Letters A, 147(5), 297–300. https://doi.org/10.1016/0375-9601(90)90451-S\n\n\nBeard, K. W. (Ed.). (2019). SECTION C: SOLID-STATE ELECTROLYTES (CERAMIC, GLASS, POLYMER). In Linden’s Handbook of Batteries (5th edition.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/9781260115925/toc-chapter/chapter22/section/section24\n\n\nClarke, K. C., Brass, J. A., & Riggan, P. J. (1994). A cellular automaton model of wildfire propagation and extinction. Photogrammetric Engineering and Remote Sensing. 60(11): 1355-1367, 60(11, 11), 1355–1367. https://www.fs.usda.gov/research/treesearch/41203\n\n\nCollin, A., Bernardin, D., & Séro-Guillaume, O. (2011). A Physical-Based Cellular Automaton Model for Forest-Fire Propagation. Combustion Science and Technology, 183(4), 347–369. https://doi.org/10.1080/00102202.2010.508476\n\n\nEncinas, A. H., Encinas, L. H., White, S. H., Rey, A. M. del, & Sánchez, G. R. (2007). Simulation of forest fire fronts using cellular automata. Advances in Engineering Software, 38(6), 372–378. https://doi.org/10.1016/j.advengsoft.2006.09.002\n\n\nMandal, S. K. (2015). Heat Treatment and Welding of Steels. In Steel Metallurgy: Properties, Specifications and Applications (First edition.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/9780071844611/chapter/chapter8\n\n\nNICC. (2022). Wildfires and Acres. National Interagency Fire Center. https://www.nifc.gov/fire-information/statistics/wildfires\n\n\nNIFC. (2022). Suppression Costs | National Interagency Fire Center. National Interagency Fire Center. https://www.nifc.gov/fire-information/statistics/suppression-costs\n\n\nPerry, G. L. W. (1998). Current approaches to modelling the spread of wildland fire: A review. Progress in Physical Geography: Earth and Environment, 22(2), 222–245. https://doi.org/10.1177/030913339802200204\n\n\nSmith, A. B. (2020). U.S. Billion-dollar Weather and Climate Disasters, 1980 - present (NCEI Accession 0209268) [Dataset]. NOAA National Centers for Environmental Information. https://doi.org/10.25921/STKW-7W73\n\n\nThe Matplotlib development team. (2023). Matplotlib.animation.FuncAnimation. Matplotlib 3.6.3 documentation. https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html\n\n\nWikipedia Contributors. (2022). Moore neighborhood. In Wikipedia. https://en.wikipedia.org/w/index.php?title=Moore_neighborhood&oldid=1128664897\n\n\nZant, P. V. (2014). Doping. In Microchip Fabrication (6th ed.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/9780071821018/chapter/chapter11",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Project Ideas: Stochastic Models</span>"
    ]
  },
  {
    "objectID": "bibliography.html",
    "href": "bibliography.html",
    "title": "Bibliography",
    "section": "",
    "text": "ActiveState Software Inc. (2024). ActiveState Python\nDistribtution. ActiveState. https://www.activestate.com/products/python/\n\n\nAdiga, A., Dubhashi, D., Lewis, B., Marathe, M., Venkatramanan, S.,\n& Vullikanti, A. (2020). Mathematical Models for\nCOVID-19 Pandemic: A Comparative Analysis.\nJournal of the Indian Institute of Science, 100(4),\n793–807. https://doi.org/10.1007/s41745-020-00200-6\n\n\nAkritas, M. (2018). Chapter 6 Fitting Models to\nData. In Probability & Statistics with\nR for Engineers and Scientists\n(Classic Version) (Pearson Modern Classics for\nAdvanced Statistics Series). Pearson. http://www.librarything.com/work/17953304/book/228047240\n\n\nAmin, O. S. M. (14 March 2019, 11:03:07). Babylonian Clay\nTablet [Graphic]. https://commons.wikimedia.org/wiki/File:Clay_tablet,_mathematical,_geometric-algebraic,_similar_to_the_Pythagorean_theorem._From_Tell_al-Dhabba%27i,_Iraq._2003-1595_BCE._Iraq_Museum.jpg\n\n\nAnaconda, Inc. (2024). Anaconda Distribution.\nAnaconda. https://www.anaconda.com/download\n\n\nAtkinson, J. (2017, April 10). What is Earth’s Energy Budget? Five\nQuestions with a Guy Who Knows [Text]. NASA. http://www.nasa.gov/feature/langley/what-is-earth-s-energy-budget-five-questions-with-a-guy-who-knows\n\n\nAusoni, C. O., Frey, P., & Tierny, J. (2014). Scientific\nVisualization at the interfaces. https://www.ljll.math.upmc.fr/frey/visu.html\n\n\nBak, P., Chen, K., & Tang, C. (1990). A forest-fire model and some\nthoughts on turbulence. Physics Letters A, 147(5),\n297–300. https://doi.org/10.1016/0375-9601(90)90451-S\n\n\nBeard, K. W. (Ed.). (2019). SECTION C: SOLID-STATE\nELECTROLYTES (CERAMIC, GLASS,\nPOLYMER). In Linden’s Handbook of\nBatteries (5th edition.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/9781260115925/toc-chapter/chapter22/section/section24\n\n\nBerto, F., & Tagliabue, J. (2022). Cellular Automata.\nIn E. N. Zalta (Ed.), The Stanford Encyclopedia of\nPhilosophy (Spring 2022). Metaphysics Research Lab,\nStanford University. https://plato.stanford.edu/archives/spr2022/entries/cellular-automata/\n\n\nBlackwood, J., & Childs, L. (2018). An introduction to compartmental\nmodeling for the budding infectious disease modeler. Letters in\nBiomathematics, 5(1, 1), 195–221. https://doi.org/10.30707/LiB5.1Blackwood\n\n\nBoden, T. A., Andres, R. J., & Marland, G. (2013). Global,\nRegional, and National Fossil-Fuel CO2\nEmissions (1751 - 2010) (V. 2013).\nEnvironmental System Science Data Infrastructure for a Virtual Ecosystem\n(ESS-DIVE) (United States); Carbon Dioxide Information Analysis Center\n(CDIAC), Oak Ridge National Laboratory (ORNL), Oak Ridge, TN (United\nStates). https://doi.org/10.3334/CDIAC/00001_V2013\n\n\nClarke, K. C., Brass, J. A., & Riggan, P. J. (1994). A cellular\nautomaton model of wildfire propagation and extinction.\nPhotogrammetric Engineering and Remote Sensing. 60(11):\n1355-1367, 60(11, 11), 1355–1367. https://www.fs.usda.gov/research/treesearch/41203\n\n\nCollin, A., Bernardin, D., & Séro-Guillaume, O. (2011). A\nPhysical-Based Cellular Automaton Model for\nForest-Fire Propagation. Combustion Science and\nTechnology, 183(4), 347–369. https://doi.org/10.1080/00102202.2010.508476\n\n\nDerek Lynn. (2020). Roulette wheel in a casino for gambling\nentertainment [Graphic]. https://unsplash.com/photos/mD1V-eS1Wb4\n\n\nDietrich, A., Wald, I., & Slusallek, P. (2005). Large-scale\nCAD Model Visualization on a Scalable\nShared-memory Architecture. In G. Greiner, J. Hornegger, H.\nNiemann, & M. Stamminger (Eds.), Vision, Modeling,\nand Visualization 2005 (pp. 303–310). Akademische\nVerlagsgesellschaft Aka.\n\n\nDiggle, S. P., & Whiteley, M. (2020). Microbe Profile:\nPseudomonas aeruginosa: Opportunistic pathogen and lab rat.\nMicrobiology, 166(1), 30–33. https://doi.org/10.1099/mic.0.000860\n\n\nEdelstein-Keshet, L. (2005). Mathematical Models in\nBiology. Society for Industrial and Applied\nMathematics. https://doi.org/10.1137/1.9780898719147\n\n\nEncinas, A. H., Encinas, L. H., White, S. H., Rey, A. M. del, &\nSánchez, G. R. (2007). Simulation of forest fire fronts using cellular\nautomata. Advances in Engineering Software, 38(6),\n372–378. https://doi.org/10.1016/j.advengsoft.2006.09.002\n\n\nEntacher, K. (1998). Bad subsequences of well-known linear congruential\npseudorandom number generators. ACM Transactions on Modeling and\nComputer Simulation, 8(1), 61–70. https://doi.org/10.1145/272991.273009\n\n\nEnthought, Inc. (2024). Enthought Downloads. https://assets.enthought.com/downloads/\n\n\nEstes Rockets. (2021). Estes Industries. https://estesrockets.com/\n\n\nFeild, A. (2019). Galaxy Types [Graphic]. https://hubblesite.org/contents/media/images/4508-Image.html\n\n\nFisher, R. A. (1936). The Use of Multiple\nMeasurements in Taxonomic Problems. Annals of\nEugenics, 7(2), 179–188. https://doi.org/10.1111/j.1469-1809.1936.tb02137.x\n\n\nFry, Ben. (2008). Visualizing data. O’Reilly Media, Inc. https://www.loc.gov/catdir/toc/fy0804/2008297507.html\n\n\nGISTEMP Team. (2022a). Data.GISS: GISS Surface\nTemperature Analysis (v4): Analysis Graphs and\nPlots. https://data.giss.nasa.gov/gistemp/graphs/\n\n\nGISTEMP Team. (2022b). GISS Surface Temperature\nAnalysis (GISTEMP), version 4. [Database]. NASA\nGoddard Institute for Space Studies. https://data.giss.nasa.gov/gistemp/\n\n\nHardy, S. P. (2002). Chapter 2: Bacterial Growth. In\nHuman Microbiology. Taylor & Francis.\n\n\nIris Species. (n.d.). Retrieved July 31, 2022,\nfrom https://www.kaggle.com/datasets/uciml/iris\n\n\nIserles, A. (2009). A first course in the numerical analysis of\ndifferential equations (2nd ed., 1–1 online resource (xviii, 459\npages) : illustrations). Cambridge University Press. http://www.books24x7.com/marc.asp?bookid=30922\n\n\nKeeports, D. (1990). Numerical calculation of model rocket trajectories.\nThe Physics Teacher, 28(5), 274–280. https://doi.org/10.1119/1.2343024\n\n\nKnight, R. (2016). Chapter 15 Oscillations. In Physics\nfor Scientists and Engineers: A\nStrategic Approach with Modern Physics (4th\nedition). Pearson.\n\n\nKnuth, D. E. (1972). Ancient Babylonian algorithms.\nCommunications of the ACM, 15(7), 671–677. https://doi.org/10.1145/361454.361514\n\n\nKoske, K. (18 October 2009, 11:52). United Airlines B777-222\nN780UA [Graphic]. https://commons.wikimedia.org/wiki/File:United_Airlines_B777-222_N780UA.jpg\n\n\nLevy, J. A. (1993). Pathogenesis of human immunodeficiency virus\ninfection. Microbiological Reviews, 57(1), 183–289. https://doi.org/10.1128/mr.57.1.183-289.1993\n\n\nMaggs, M. (2007). Falling Ball [Graphic]. https://commons.wikimedia.org/wiki/File:Falling_ball.jpg\n\n\nMandal, S. K. (2015). Heat Treatment and\nWelding of Steels. In Steel\nMetallurgy: Properties,\nSpecifications and Applications (First\nedition.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/9780071844611/chapter/chapter8\n\n\nMathieu, E., Ritchie, H., Rodés-Guirao, L., Appel, C., Giattino, C.,\nHasell, J., Macdonald, B., Dattani, S., Beltekian, D., Ortiz-Ospina, E.,\n& Roser, M. (2020). Coronavirus Pandemic\n(COVID-19). Our World in Data. https://ourworldindata.org/coronavirus-source-data\n\n\nMatsumoto, M., & Nishimura, T. (1998). Mersenne twister: A\n623-dimensionally equidistributed uniform pseudo-random number\ngenerator. ACM Transactions on Modeling and Computer\nSimulation, 8(1), 3–30. https://doi.org/10.1145/272991.272995\n\n\nMenz, P. G. (1993). The physics of bungee jumping. The Physics\nTeacher, 31(8), 483–487. https://doi.org/10.1119/1.2343852\n\n\nMercator, P. (2013). Spherical trigonometry [Graphic]. https://commons.wikimedia.org/wiki/File:Spherical_trigonometry_basic_triangle.svg\n\n\nMunz, P., Hudea, I., Imad, J., & Smith, H. L. (2009). WHEN\nZOMBIES ATTACK!: MATHEMATICAL MODELLING OF AN OUTBREAK OF\nZOMBIE INFECTION. In J. M. Tchuenche & C. Chiyaka (Eds.),\nInfectious Disease Modelling Research Progress\n(pp. 133–150).\n\n\nNASA Exoplanet Archive. (n.d.). Retrieved August\n3, 2022, from https://exoplanetarchive.ipac.caltech.edu/index.html\n\n\nNASA’s Scientific Visualization Studio. (2021, January 14).\nSVS: Global Temperature Anomalies from\n1880 to 2020. NASA Scientific Visualizations Studio. https://svs.gsfc.nasa.gov/4882\n\n\nNew York Public Library / Science Source / Science Photo Library.\n(n.d.). Hipparchus, Greek Astronomer and\nMathematician [Graphic]. https://www.sciencephoto.com/media/1011097/view\n\n\nNICC. (2022). Wildfires and Acres. National\nInteragency Fire Center. https://www.nifc.gov/fire-information/statistics/wildfires\n\n\nNIFC. (2022). Suppression Costs | National\nInteragency Fire Center. National Interagency Fire Center.\nhttps://www.nifc.gov/fire-information/statistics/suppression-costs\n\n\nNumpy. (2022). NumPy. https://numpy.org/\n\n\nNumPy Developers. (2022). Random Generator —\nNumPy v1.23 Manual. https://numpy.org/doc/stable/reference/random/generator.html\n\n\nO’Neill, M. E. (2014). PCG: A Family of\nSimple Fast Space-Efficient Statistically Good Algorithms\nfor Random Number Generation (HMC-CS-2014-0905).\nHarvey Mudd College Computer Science Department. https://www.pcg-random.org/paper.html\n\n\nPandas.read_csv — pandas 1.4.3 documentation. (n.d.). Retrieved\nAugust 1, 2022, from https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html\n\n\nPaul Peter Urone, & Roger Hinrichs. (2012). Trajectory of a\nrock [Graphic]. https://openstax.org/books/college-physics/pages/3-4-projectile-motion\n\n\nPerelson, A. S., & Ribeiro, R. M. (2013). Modeling the within-host\ndynamics of HIV infection. BMC Biology,\n11, 96. https://doi.org/10.1186/1741-7007-11-96\n\n\nPerry, G. L. W. (1998). Current approaches to modelling the spread of\nwildland fire: A review. Progress in Physical Geography: Earth and\nEnvironment, 22(2), 222–245. https://doi.org/10.1177/030913339802200204\n\n\nPolya, G. (1971). How to Solve It: A New\nAspect of Mathematical Method (2nd ed.).\nPrinceton University Press.\n\n\nPower Project Team. (n.d.). NASA POWER |\nPrediction Of Worldwide Energy Resources. Retrieved\nJuly 30, 2022, from https://power.larc.nasa.gov/\n\n\nPress, W. H., Teukolsky, S. A., Vetterling, W. T., & Flannery, B. P.\n(1986). Numerical Recipes: The Art of\nScientific Computing. http://www.librarything.com/work/249712/book/225760462\n\n\nPython Software Foundation. (2021). Python 3.6.15\nDocumentation. https://docs.python.org/3.6/\n\n\nPython Software Foundation. (2022). Random — Generate\npseudo-random numbers — Python 3.10.7 documentation.\nhttps://docs.python.org/3/library/random.html\n\n\nRathod, V. (2020). Iris Flower CaseStudy. RPubs.\nhttps://rpubs.com/vidhividhi/irisdataeda\n\n\nRobinson, J. A., Trulear, M. G., & Characklis, W. G. (1984).\nCellular reporoduction and extracellular polymer formation by\nPseudomonas aeruginosa in continuous culture.\nBiotechnology and Bioengineering, 26(12), 1409–1417.\nhttps://doi.org/10.1002/bit.260261203\n\n\nRossant, C. (2018). IPython Interactive Computing and\nVisualization Cookbook - Second Edition.\nPackt Publishing. https://www.amazon.com/IPython-Interactive-Computing-Visualization-Cookbook/dp/1785888633/?_encoding=UTF8&pd_rd_w=FBfz6&content-id=amzn1.sym.8cf3b8ef-6a74-45dc-9f0d-6409eb523603&pf_rd_p=8cf3b8ef-6a74-45dc-9f0d-6409eb523603&pf_rd_r=TRGJAR2YQD6W7JS9CKZM&pd_rd_wg=7PdJO&pd_rd_r=361fb22c-bf7e-483b-993c-a686ae72e5c8&ref_=pd_gw_ci_mcx_mi\n\n\nRossum, G. van, Warsaw, B., & Coghlan, N. (2022).\nPEP 8 – Style Guide for Python\nCode | peps.python.org. https://peps.python.org/pep-0008/\n\n\nShinker, J. J. (2016). Global Climate Animations.\nGobal Climate Animations. https://climvis.org/animations.html\n\n\nShneiderman, B. (2003). The Eyes Have It: A\nTask by Data Type Taxonomy for Information\nVisualizations. In B. B. Bederson & B. Shneiderman (Eds.),\nThe Craft of Information\nVisualization (pp. 364–371). Morgan Kaufmann. https://doi.org/10.1016/B978-155860915-0/50046-9\n\n\nSmith, A. B. (2020). U.S. Billion-dollar Weather and Climate\nDisasters, 1980 - present (NCEI Accession\n0209268) [Dataset]. NOAA National Centers for Environmental\nInformation. https://doi.org/10.25921/STKW-7W73\n\n\nSpy007au. (1996). Bungee jumping off the Zambezi\nBridge, Victoria Falls, Africa\n[Graphic]. https://commons.wikimedia.org/wiki/File:Bill%27s_Bungy_Jump.jpg\n\n\nSpyder Doc Contributors. (2024). Quickstart — Spyder 5\ndocumentation. https://docs.spyder-ide.org/current/quickstart.html\n\n\nStein, P. (2010). The Tower [Graphic]. https://commons.wikimedia.org/w/index.php?curid=10438782\n\n\nTemperature Composite. (n.d.). Skeptical Science.\nRetrieved January 9, 2022, from https://skepticalscience.com//graphics.php?g=7\n\n\nThe Matplotlib Development team. (2021). Matplotlib —\nVisualization with Python. https://matplotlib.org/\n\n\nThe Matplotlib development team. (2022). List of named colors —\nMatplotlib 3.5.2 documentation. https://matplotlib.org/stable/gallery/color/named_colors.html\n\n\nThe Matplotlib Development Team. (2022). Tutorials —\nMatplotlib 3.5.2 documentation. https://matplotlib.org/stable/tutorials/index.html\n\n\nThe Matplotlib development team. (2023).\nMatplotlib.animation.FuncAnimation. Matplotlib\n3.6.3 documentation. https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html\n\n\nThe Matplotlib Development Team. (2023a). Plot types —\nMatplotlib 3.7.1 documentation. https://matplotlib.org/stable/plot_types/index.html\n\n\nThe Matplotlib Development Team. (2023b). Writing mathematical\nexpressions — Matplotlib 3.7.1 documentation. https://matplotlib.org/stable/tutorials/text/mathtext.html\n\n\nThe pandas development team. (2022). Pandas - Python Data\nAnalysis Library. https://pandas.pydata.org/\n\n\nThe SciPy community. (2022a). Scipy.integrate.quad —\nSciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html\n\n\nThe SciPy Community. (2022a). Scipy.integrate.solve_ivp —\nSciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html\n\n\nThe SciPy community. (2022b). Scipy.misc.derivative —\nSciPy v1.9.0 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.derivative.html\n\n\nThe SciPy Community. (2022b). Scipy.optimize.curve_fit —\nSciPy v1.9.3 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html\n\n\nThe SciPy Community. (2022c). Scipy.stats.linregress —\nSciPy v1.9.3 Manual. https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html\n\n\nThe Shodor Education Foundation. (2000). Overview of\nComputational Science. ChemViz Curriculum Support\nResources. http://www.shodor.org/chemviz/overview/compsci.html\n\n\nTory, M., & Moller, T. (2004). Rethinking\nVisualization: A High-Level Taxonomy.\nIEEE Symposium on Information\nVisualization, 151–158. https://doi.org/10.1109/INFVIS.2004.59\n\n\nUnicode Consortium. (2021). Unicode. Unicode. https://home.unicode.org/\n\n\nunknown. (1983). Commemorative Stamp of\nMuḥammad ibn Mūsā\nal-Ḵwārizmī [Graphic]. https://commons.wikimedia.org/wiki/File:1983_CPA_5426_(1).png\n\n\nVogelsberger, M., Genel, S., Springel, V., Torrey, P., Sijacki, D., Xu,\nD., Snyder, G., Bird, S., Nelson, D., & Hernquist, L. (2014).\nProperties of galaxies reproduced by a hydrodynamic simulation.\nNature, 509(7499, 7499), 177–182. https://doi.org/10.1038/nature13316\n\n\nWHO Coronavirus (COVID-19)\nDashboard. (2020). WHO Coronavirus (COVID-19)\nDashboard. https://covid19.who.int\n\n\nWicks, R. (2022). Twelfth night [Graphic]. https://unsplash.com/photos/FMARk9s_20s\n\n\nWikipedia Contributors. (2022a). Moore neighborhood. In\nWikipedia. https://en.wikipedia.org/w/index.php?title=Moore_neighborhood&oldid=1128664897\n\n\nWikipedia Contributors. (2022b). Roulette. In Wikipedia. https://en.wikipedia.org/w/index.php?title=Roulette&oldid=1106799426\n\n\nWing, J. M. (2006). Computational thinking. Communications of the\nACM, 49(3), 33–35. https://doi.org/10.1145/1118178.1118215\n\n\nZant, P. V. (2014). Doping. In Microchip\nFabrication (6th ed.). McGraw-Hill Education. https://www.accessengineeringlibrary.com/content/book/9780071821018/chapter/chapter11\n\n\nZhang, Y., & Zhao, Y. (2015). Astronomy in the Big Data\nEra. Data Science Journal, 14(0, 0), 11. https://doi.org/10.5334/dsj-2015-011",
    "crumbs": [
      "Bibliography"
    ]
  },
  {
    "objectID": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html",
    "href": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html",
    "title": "Python Programming Environments",
    "section": "",
    "text": "Installing a Python Distribution\nAs discussed in Chapter 1, there are several ways to establish a good programming environment that uses Python:\nThe last method was discussed in detail in Chapter 1. We will consider the other methods here.\nThere are several Python distributions used for scientific and engineering application development. The most common ones include:\nWe will focus on the Anaconda distribution here. Setting up a working programming environment based on the Anaconda distribution should be straightforward.\nCertainly, one major benefit of programming in Python is the large number of packages available. These packages, such as matplotlib, allow for developing powerful scientific applications, but they are not all preinstalled when you perform the default installation of your distribution. You will need to install the packages to be used by this textbook.\nEach package will have a set of dependencies (other required packages). To ensure that these dependencies are also installed a package manager app is used. Anaconda comes with a package manager called conda. Instead of using conda directly, we will use a conda graphical user interface app called Navigator, which is installed with the Anaconda distribution. Navigator will help you to manage the installed packages without learning all the details of the conda app.\nLocate the Navigator app that was installed with the Anaconda distribution and start it up. Figure 1 shows the Navigator home screen. The rectangular application tiles are additional apps that can be installed using Navigator. We will ignore these apps for now.\nNow click on the Environments tab. Some Python packages have inconsistent dependencies. To avoid this problem, the Anaconda distribution allows separate programming environments to be set up depending on the project you are working on. These programming environments exist in separate file structures on your computer and are isolated from each other. Figure 2 shows the default Environments screen. By default, there is one environment set up labelled “base (root)”. While we can add packages to this environment, if we want, a better practice is to create a separate environment for each major programming project. We will create an environment that should work for all the examples and problems in the textbook.\nTo create a new environment,\nBefore repeating this process for the other packages, you should add an additional channel for Navigator to use.\nNow repeat the above process for adding packages for the other packages that are not already installed. You will find that installing matplotlib will automatically install numpy, since it is a dependency.\nThere are several ways to execute Python code using the created environment. One method is to start Navigator, go to the Environments page, and select the green arrow, pointed out in Figure 3.\nClicking the arrow tool gives you access to several choices for running Python. The Terminal gives you access to the operating system command prompt, which will allow you to execute a Python program from a file. The IPython selection opens up the IPython interactive interpreter from which you can execute individual Python commands.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Python Programming Environments</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html#installing-a-python-distribution",
    "href": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html#installing-a-python-distribution",
    "title": "Python Programming Environments",
    "section": "",
    "text": "Anaconda (Anaconda, Inc., 2024)\nEnthought (Enthought, Inc, 2024)\nActive State (ActiveState Software Inc., 2024)\n\n\n\nNavigate to the Anaconda download page.\nFill in your email information and submit.\nChoose the download for your operating system.\nAfter the installer downloads, open it up and follow the instructions. Accept the default locations for files.\n\n\n\n\n\n\n\n\n\n\nFigure 1: Navigator home screen.\n\n\n\n\n\n\n\n\n\n\nFigure 2: Default Environment screen.\n\n\n\n\n\nClick on the “Create” tool at the bottom of the Environments screen.\nType in an appropriate name, such as “CompSciBook”, and select the version of Python you wish to use. The default Python version should be acceptable for now.\nSelect “Not installed” from the package filter drop down menu at the top.\nSearch for the matplotlib, which is the first package listed in Table A1‑1.\nSelect the package\nClick on “Apply”.\n\n\n\nClick on Channels\nType in conda-forge\nClick on Update channels\n\n\n\n\n\nTable 1: Required packages for textbook problems.\n\n\n\n\n\nPackage\n\n\n\n\nmatplotlib\n\n\nnumpy\n\n\npandas\n\n\nscipy\n\n\nseaborn\n\n\nstatsmodels\n\n\nnumdifftools\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: The execute Python button is shown by the arrow.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Python Programming Environments</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html#using-jupyter-notebooks-with-the-anaconda-distribution",
    "href": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html#using-jupyter-notebooks-with-the-anaconda-distribution",
    "title": "Python Programming Environments",
    "section": "Using Jupyter Notebooks with The Anaconda Distribution",
    "text": "Using Jupyter Notebooks with The Anaconda Distribution\nJupyter Notebook is an application for interactive code development and commentary. The computational notebook format is a file that has cells for executable code and output and cells for text that can be formatted using the Markdown language. The notebooks open in a browser where the executable code is run on a cloud-based server or alternatively on your computer, if the appropriate Jupyter Notebook application has been installed.\nWhen the Anaconda distribution is installed on your computer, the Jupyter Notebook application should be installed by default and will execute code from a browser using the base environment. One way to create a Jupyter Notebook file is to\n\nstart Navigator\ngo to the Environments window\nclick on the base environment\nclick on the green arrow for the environment drop-down menu\nselect “Open with Juptyer Notebook”, as shown in Figure 4.\n\n\n\n\n\n\n\nFigure 4: The Navigator environments window. The arrow points out the selection to start a Jupyter notebook using the base environment.\n\n\n\nTo create a Jupyter notebook that uses another environment, such as the CompSciBook environment, use Navigator to install the Jupyter package into the selected environment. You can now start a Jupyter Notebook session from selected environment tab in Navigator.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Python Programming Environments</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html#use-the-spyder-ide-with-the-anaconda-distribution",
    "href": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html#use-the-spyder-ide-with-the-anaconda-distribution",
    "title": "Python Programming Environments",
    "section": "Use the Spyder IDE with the Anaconda Distribution",
    "text": "Use the Spyder IDE with the Anaconda Distribution\nAs the complexity of the coding project increases, there will likely come a time when it is advantageous to shift the programming environment away from computational notebooks (Jupyter Notebook, Google Colab notebooks, etc.) towards a more robust integrated development environment (IDE) that includes a code smart text editor, an interactive test run environment, and enhanced debugging tools. One such IDE that comes with the Anaconda distribution is the Spyder app that will be installed automatically in the base environment. The Spyder documentation offers a good overview of the basic features available (Spyder Doc Contributors, 2024). Figure 5 shows the default opening screen.\n\n\n\n\n\n\n\n\n\n\na.\n\n\n\n\n\n\n\nb.\n\n\n\n\n\n\n\n\n\nc.\n\n\n\n\n\n\n\nd.\n\n\n\n\n\n\n\n\nFigure 5: :Default Spyder windows. a) Toolbar (outlined in red); b) Text Editor; c) Help Window; d) IPython console.\n\n\n\nThe Spyder text editor will color Python key words and variable names that have been used. It will check syntax for errors.\nOne method of using Spyder with a different environment is to use Navigator to install the Spyder package in the appropriate environment. A link to the specific version of Spyder will be added n the application listing. You can also change the environment used by Spyder in the Preferences tab.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Python Programming Environments</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html#references",
    "href": "appendices/AppendixA/AppA_PythonProgrammingEnvironments.html#references",
    "title": "Python Programming Environments",
    "section": "References",
    "text": "References\n\nActiveState Software Inc. (2024). ActiveState Python Distribtution. ActiveState. https://www.activestate.com/products/python/\nAnaconda, Inc. (2024). Anaconda Distribution. Anaconda. https://www.anaconda.com/download\nEnthought, Inc. (2024). Enthought Downloads. https://assets.enthought.com/downloads/\nSpyder Doc Contributors. (2024). Quickstart—Spyder 5 documentation. https://docs.spyder-ide.org/current/quickstart.html\n\n\n\n\n\nActiveState Software Inc. (2024). ActiveState Python Distribtution. ActiveState. https://www.activestate.com/products/python/\n\n\nAnaconda, Inc. (2024). Anaconda Distribution. Anaconda. https://www.anaconda.com/download\n\n\nEnthought, Inc. (2024). Enthought Downloads. https://assets.enthought.com/downloads/\n\n\nSpyder Doc Contributors. (2024). Quickstart — Spyder 5 documentation. https://docs.spyder-ide.org/current/quickstart.html",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Python Programming Environments</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixB/AppB_AdvancedPlotting.html",
    "href": "appendices/AppendixB/AppB_AdvancedPlotting.html",
    "title": "Advanced Plotting with Matplotlib",
    "section": "",
    "text": "The Two Matplotlib Interfaces\nIn this appendix, we will explore the following advanced visualization topics:\nUp until this point we have used the Matplotlib interface functions available in the pyplot submodule. This interface was designed to duplicate the user interface in the application MATLAB, a proprietary programming language and programming environment used by many engineers and scientists. The pyplot interface uses a procedural programming model where a program executes using the control structures we introduced earlier: sequential, conditional, and iterative, and where blocks of code that can be reused are packaged in a procedure, which is a function in Python.\nThe other programming model that can be used with Matplotlib is the Object-Oriented Programming model (OOP). In the OOP model a program is composed of objects that have properties and codes (called methods) that can change properties of the object. At a fundamental level, Python is an object-oriented programming language, although we have not been emphasizing that aspect until now. Even basic data types such integers, floats, and strings are objects in Python.\nTwo important objects that are used to create matplotlib graphs are the Figure object and the Axes object. An instance of the Figure object can contain one or more Axes objects. The Axes object is a rectangular area that will hold the elements of a graph: x-axis line, y-axis line, data symbols, lines, etc. We can create an empty Figure object called fig with the code\nNote that we can use any legal variable name we want for the Figure object. Calling it fig is a common choice.\nAn Axes object can be created using the add_subplot method of the Figure object. Here is an example of creating an Axes object named ax1 in the Figure instance fig.\nA plot can be added to an Axes object using the plot method for Axes objects. Let’s put this all together and create a simple graph using the Object-Oriented interface. The code is in Figure 1 and the resulting figure is shown as Figure 2.\nThe next section will describe details of using the add_subplot method.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Advanced Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixB/AppB_AdvancedPlotting.html#the-two-matplotlib-interfaces",
    "href": "appendices/AppendixB/AppB_AdvancedPlotting.html#the-two-matplotlib-interfaces",
    "title": "Advanced Plotting with Matplotlib",
    "section": "",
    "text": "fig = plt.figure()\n\n\nax1 = fig.add_subplot(1,1,1)\n\n\n\n\n\"\"\"\nProgram: Simple Example of Subplot\nAuthor: C.D. Wentworth\nVersion: 2.20.2022.1\nSummary:\n    This program illustrates the basic syntax for creating a Figure object\n    instance and an Axes object instance.\nVersion History:\n    2.20.2022.1: base\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Set up numpy random number generator\nnp_rng = np.random.default_rng(seed=314159) \n\n# Create some random data\nrandomData = np_rng.random(100)\n\n# Plot the data\nfig = plt.figure()\nax1 = fig.add_subplot(1,1,1)\nax1.plot(randomData)\nplt.savefig('randomPlot.png' , dpi=300)\n\n\nFigure 1: :Code for setting up subplots using the OOP interface.\n\n\n\n\n\n\n\n\n\nFigure 2: Output from the code of Figure 1.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Advanced Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixB/AppB_AdvancedPlotting.html#subplots",
    "href": "appendices/AppendixB/AppB_AdvancedPlotting.html#subplots",
    "title": "Advanced Plotting with Matplotlib",
    "section": "Subplots",
    "text": "Subplots\nThere will be many times in communicating scientific information that two or more different properties can best be compared by putting them in the same figure. If both properties are to be visualized by a 2d graph then we need to place multiple graphs in the same figure, so that comparisons can be easily made. Let’s consider a biomechanics-related example. Suppose we want to understand the mechanics of performing a standing long jump. A simple first step might be to video a person performing the motion and extract some of the quantitative motion data from the video. Figure 3 shows a man performing a standing long jump. Using video analysis software, a researcher obtained the position as a function of time of the jumper’s approximate center of mass. One interesting comparison to make is the y-component of the position and the velocity as functions of time. Since these are physically different properties they need to be on different graphs, but to aid in comparing them, we should put the two graphs in the same figure, as shown in Figure 4.\n\n\n\n\n\n\nFigure 3: Composite image of a man performing a standing long jump.\n\n\n\n\n\n\n\n\n\nFigure 4: y-component of position and velocity for the center of mass of a standing long jumper.\n\n\n\nHow was this figure created? We are going to use the Objected-Oriented Matplotlib interface discussed above. Figure 5 shows a listing of the program that created Figure 4. In line 20, we create an instance of the figure class that is defined in the matplotlib library, and we call the instance fig. All the methods associated with the figure class can now be used by the fig instance. We will use some of those methods to create the desired figure.\n\n\n\n\"\"\"\nTitle: Standing Long Jump Subplots\nAuthor: C.D. Wentworth \nVersion: 03.1.2019.1\nSummary: This program illustrates a method for creating\n         subplots in a single figure.\n\"\"\"\nimport numpy as np\nimport matplotlib.pylab as plt \n\n#--Main Program \n\n# Read in data\ndata = np.loadtxt(\"StandingLJ_Data.txt\",skiprows=7)\ntData = data[:,0]\nyData = data[:,2]\nvyData = data[:,4] \n\n# Plot data\nfig = plt.figure()\nf1 = fig.add_subplot(2,1,1)\nf1.plot(tData,yData,linestyle='',marker='d',\ncolor='g',markersize=6.0)\n#f1.set_xlabel(r'$t [h]$',fontsize=14)\nf1.set_ylabel(r'$y \\ [m]$',fontsize=14)\nf1.set_title(r'$y-coordinate$')\nf2 = fig.add_subplot(2,1,2)\nf2.plot(tData,vyData,linestyle='',marker='d',\n               color='g',markersize=6.0)\nf2.set_xlabel(r'$t \\ [h]$',fontsize=14)\nf2.set_ylabel(r'$v_y \\ [m/s]$',fontsize=14)\nf2.set_title(r'$y-component \\ of \\ velocity$')\nplt.tight_layout()\nplt.savefig('StandingLJ_subplots.png',dpi=300)\nplt.show() \n\n\nFigure 5: :Program listing for StandingLJ_subplots.py.\n\n\n\nIn line 21 we use the add_subplot() method to create a subplot in fig, and we call the subplot f1. The meaning of the arguments are given in the following\nadd_subplot(nrows, ncols, index, **kwargs)\nwhere\nnrows, the number of rows in the figure\nncols, the number of columns in the figure\nindex, a positive integer indicating the subplot being constructed\n**kwargs, corresponds to a variety of optional keyword arguments\nSo, add_subplot(2,1,1) means that we are creating a figure with 2 rows and 1 column for subplots, and we are currently focused on the first subplot, which would be the top one. Line 22-23 creates the actual subplot. Lines 25 and 26 illustrate how we can add properties to the subplot. Line 27 creates the second subplot by using the index 2 as the third argument value. The set_tight_layout(True) method applied in line 33 allows padding to be added between parts of a figure. It has other possible arguments that can be specified to give the programming considerable control over the appearance, but often the value True will achieve the desired results.\nThe xlabel and ylabel arguments in the code of Figure 5 illustrate how to use the mathematics typesetting language TeX to create labels that contain more sophisticated mathematical formatting. A string enclosed by $ signs, as in $v_y \\ [m/s]$, is interpreted as TeX code. The matplotlib documentation gives some basic examples of using TeX to create professional mathematical formatting (The Matplotlib Development Team, 2023b).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Advanced Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixB/AppB_AdvancedPlotting.html#uncertainty-bars",
    "href": "appendices/AppendixB/AppB_AdvancedPlotting.html#uncertainty-bars",
    "title": "Advanced Plotting with Matplotlib",
    "section": "Uncertainty Bars",
    "text": "Uncertainty Bars\nQuantitative experimental measurements always carry some uncertainty due to random variations that can occur when the same measurement is repeated. If a measurement is repeated several times to give a sample of the measurement, then typically the sample mean will be used as the value associated with the data point and the uncertainty in the mean due to random variation is given by the sample standard error. In a graph of the measurements, we want to communicate the estimated uncertainty in a particular data point, and we can do this by adding an uncertainty, or error, bar above and below the actual data point. This communicates to the reader that the actual value has a range of possible values.\nAs a specific example, consider vertical position data taken from a video of a dropped ball Table 1 gives the data from the data file.\n\n\n\nTable 1: Position-time data.\n\n\n\n\n\nt[s]\nx [m]\nDx [m]\n\n\n\n\n0\n0\n0\n\n\n0.2\n0.094\n0.06\n\n\n0.4\n0.336\n0.25\n\n\n0.6\n0.46\n0.4\n\n\n0.8\n1.344\n0.2\n\n\n1\n2.1\n0.42\n\n\n1.2\n3.324\n0.32\n\n\n1.4\n4.116\n0.32\n\n\n1.6\n5.376\n0.42\n\n\n1.8\n6.804\n0.42\n\n\n2\n8.4\n0.42\n\n\n\n\n\n\nFigure 6 shows a plot of the ball’s position as a function of time. The uncertainty of each position measurement is indicated with the red bar drawn through the data points. The value of the uncertainty was read from the data file in the third column.\n\n\n\n\n\n\nFigure 6: Position as a function of time for a ball dropped from rest vertically.\n\n\n\nThe key to adding error bars is to use the errorbar() method instead of the plot method when constructing the plot. Most of the arguments of errorbar() are the same as for plot(), but there is the additional keyword argument yerr, which specifies the list containing the uncertainty estimates for each data point. Line 21 of Figure 7 shows how errorbar() was used to create the graph in Figure 6.\n\n\n\n\"\"\"\nTitle: Plot Data Error Bars\nAuthor: C.D. Wentworth \nVersion: 12.31.2018.1\nSummary: This program illustrates how to add errobars\n         (or uncertainty bars) to a data point based on\n         uncertainty estimates imported from the data file. \n\n\"\"\"\nimport numpy as np\nimport matplotlib.pyplot as plt\n# Read in data\ndata = np.loadtxt(\"droppedBallData.txt\",skiprows=2)\ntData = data[:,0]\nxData = data[:,1]\ndxData = data[:,2] \n\n# Plot data\nfig = plt.figure()\nf1 = fig.add_subplot(1,1,1)\nf1.errorbar(tData,xData,linestyle='',marker='d',\n        color='g',markersize=6.0,yerr=dxData, ecolor='r')\nf1.set_xlabel(r'$t [h]$',fontsize=14)\nf1.set_ylabel(r'$x [m]$',fontsize=14)\nplt.savefig('droppedBallWithErrorBars.png',dpi=300) \n\n\nFigure 7: :Code for creating error bars from droppedBallPlotWithErrorBars.py.\n\n\n\nThe matplotlib documentation gives many examples of other plot types that might be useful (The Matplotlib Development Team, 2023a).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Advanced Plotting with Matplotlib</span>"
    ]
  },
  {
    "objectID": "appendices/AppendixB/AppB_AdvancedPlotting.html#B4-references",
    "href": "appendices/AppendixB/AppB_AdvancedPlotting.html#B4-references",
    "title": "Advanced Plotting with Matplotlib",
    "section": "References",
    "text": "References\n\nThe Matplotlib Development Team. (2023a). Plot types—Matplotlib 3.7.1 documentation. https://matplotlib.org/stable/plot_types/index.html\nThe Matplotlib Development Team. (2023b). Writing mathematical expressions—Matplotlib 3.7.1 documentation. https://matplotlib.org/stable/tutorials/text/mathtext.html\n\n\n\n\n\nThe Matplotlib Development Team. (2023a). Plot types — Matplotlib 3.7.1 documentation. https://matplotlib.org/stable/plot_types/index.html\n\n\nThe Matplotlib Development Team. (2023b). Writing mathematical expressions — Matplotlib 3.7.1 documentation. https://matplotlib.org/stable/tutorials/text/mathtext.html",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Advanced Plotting with Matplotlib</span>"
    ]
  }
]